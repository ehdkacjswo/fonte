diff --git a/gen/com/google/javascript/jscomp/FunctionInfo.java b/gen/com/google/javascript/jscomp/FunctionInfo.java
index 2e0668cf..098e49a0 100644
--- a/gen/com/google/javascript/jscomp/FunctionInfo.java
+++ b/gen/com/google/javascript/jscomp/FunctionInfo.java
@@ -23,7 +23,7 @@ public final class FunctionInfo {
   static
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internal_static_jscomp_FunctionInformationMap_Module_fieldAccessorTable;
-  
+
   public static com.google.protobuf.Descriptors.FileDescriptor
       getDescriptor() {
     return descriptor;
@@ -80,8 +80,8 @@ public final class FunctionInfo {
         new com.google.protobuf.Descriptors.FileDescriptor[] {
         }, assigner);
   }
-  
+
   public static void internalForceInit() {}
-  
+
   // @@protoc_insertion_point(outer_class_scope)
 }
diff --git a/gen/com/google/javascript/jscomp/FunctionInformationMap.java b/gen/com/google/javascript/jscomp/FunctionInformationMap.java
index 15b29cd6..62a02306 100644
--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java
+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java
@@ -9,26 +9,26 @@ public  final class FunctionInformationMap extends
     initFields();
   }
   private FunctionInformationMap(boolean noInit) {}
-  
+
   private static final FunctionInformationMap defaultInstance;
   public static FunctionInformationMap getDefaultInstance() {
     return defaultInstance;
   }
-  
+
   public FunctionInformationMap getDefaultInstanceForType() {
     return defaultInstance;
   }
-  
+
   public static final com.google.protobuf.Descriptors.Descriptor
       getDescriptor() {
     return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_descriptor;
   }
-  
+
   protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internalGetFieldAccessorTable() {
     return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_fieldAccessorTable;
   }
-  
+
   public static final class Entry extends
       com.google.protobuf.GeneratedMessage {
     // Use Entry.newBuilder() to construct.
@@ -36,75 +36,75 @@ public  final class FunctionInformationMap extends
       initFields();
     }
     private Entry(boolean noInit) {}
-    
+
     private static final Entry defaultInstance;
     public static Entry getDefaultInstance() {
       return defaultInstance;
     }
-    
+
     public Entry getDefaultInstanceForType() {
       return defaultInstance;
     }
-    
+
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_descriptor;
     }
-    
+
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_fieldAccessorTable;
     }
-    
+
     // required int32 id = 2;
     public static final int ID_FIELD_NUMBER = 2;
     private boolean hasId;
     private int id_ = 0;
     public boolean hasId() { return hasId; }
     public int getId() { return id_; }
-    
+
     // required string source_name = 3;
     public static final int SOURCE_NAME_FIELD_NUMBER = 3;
     private boolean hasSourceName;
     private java.lang.String sourceName_ = "";
     public boolean hasSourceName() { return hasSourceName; }
     public java.lang.String getSourceName() { return sourceName_; }
-    
+
     // required int32 line_number = 4;
     public static final int LINE_NUMBER_FIELD_NUMBER = 4;
     private boolean hasLineNumber;
     private int lineNumber_ = 0;
     public boolean hasLineNumber() { return hasLineNumber; }
     public int getLineNumber() { return lineNumber_; }
-    
+
     // required string module_name = 5;
     public static final int MODULE_NAME_FIELD_NUMBER = 5;
     private boolean hasModuleName;
     private java.lang.String moduleName_ = "";
     public boolean hasModuleName() { return hasModuleName; }
     public java.lang.String getModuleName() { return moduleName_; }
-    
+
     // required int32 size = 6;
     public static final int SIZE_FIELD_NUMBER = 6;
     private boolean hasSize;
     private int size_ = 0;
     public boolean hasSize() { return hasSize; }
     public int getSize() { return size_; }
-    
+
     // required string name = 7;
     public static final int NAME_FIELD_NUMBER = 7;
     private boolean hasName;
     private java.lang.String name_ = "";
     public boolean hasName() { return hasName; }
     public java.lang.String getName() { return name_; }
-    
+
     // required string compiled_source = 8;
     public static final int COMPILED_SOURCE_FIELD_NUMBER = 8;
     private boolean hasCompiledSource;
     private java.lang.String compiledSource_ = "";
     public boolean hasCompiledSource() { return hasCompiledSource; }
     public java.lang.String getCompiledSource() { return compiledSource_; }
-    
+
     private void initFields() {
     }
     public final boolean isInitialized() {
@@ -117,7 +117,7 @@ public  final class FunctionInformationMap extends
       if (!hasCompiledSource) return false;
       return true;
     }
-    
+
     public void writeTo(com.google.protobuf.CodedOutputStream output)
                         throws java.io.IOException {
       getSerializedSize();
@@ -144,12 +144,12 @@ public  final class FunctionInformationMap extends
       }
       getUnknownFields().writeTo(output);
     }
-    
+
     private int memoizedSerializedSize = -1;
     public int getSerializedSize() {
       int size = memoizedSerializedSize;
       if (size != -1) return size;
-    
+
       size = 0;
       if (hasId()) {
         size += com.google.protobuf.CodedOutputStream
@@ -183,7 +183,7 @@ public  final class FunctionInformationMap extends
       memoizedSerializedSize = size;
       return size;
     }
-    
+
     public static com.google.javascript.jscomp.FunctionInformationMap.Entry parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
@@ -250,31 +250,31 @@ public  final class FunctionInformationMap extends
       return newBuilder().mergeFrom(input, extensionRegistry)
                .buildParsed();
     }
-    
+
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
     public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap.Entry prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
-    
+
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder> {
       private com.google.javascript.jscomp.FunctionInformationMap.Entry result;
-      
+
       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Entry.newBuilder()
       private Builder() {}
-      
+
       private static Builder create() {
         Builder builder = new Builder();
         builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
         return builder;
       }
-      
+
       protected com.google.javascript.jscomp.FunctionInformationMap.Entry internalGetResult() {
         return result;
       }
-      
+
       public Builder clear() {
         if (result == null) {
           throw new IllegalStateException(
@@ -283,20 +283,20 @@ public  final class FunctionInformationMap extends
         result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
         return this;
       }
-      
+
       public Builder clone() {
         return create().mergeFrom(result);
       }
-      
+
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
         return com.google.javascript.jscomp.FunctionInformationMap.Entry.getDescriptor();
       }
-      
+
       public com.google.javascript.jscomp.FunctionInformationMap.Entry getDefaultInstanceForType() {
         return com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance();
       }
-      
+
       public boolean isInitialized() {
         return result.isInitialized();
       }
@@ -306,7 +306,7 @@ public  final class FunctionInformationMap extends
         }
         return buildPartial();
       }
-      
+
       private com.google.javascript.jscomp.FunctionInformationMap.Entry buildParsed()
           throws com.google.protobuf.InvalidProtocolBufferException {
         if (!isInitialized()) {
@@ -315,7 +315,7 @@ public  final class FunctionInformationMap extends
         }
         return buildPartial();
       }
-      
+
       public com.google.javascript.jscomp.FunctionInformationMap.Entry buildPartial() {
         if (result == null) {
           throw new IllegalStateException(
@@ -325,7 +325,7 @@ public  final class FunctionInformationMap extends
         result = null;
         return returnMe;
       }
-      
+
       public Builder mergeFrom(com.google.protobuf.Message other) {
         if (other instanceof com.google.javascript.jscomp.FunctionInformationMap.Entry) {
           return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap.Entry)other);
@@ -334,7 +334,7 @@ public  final class FunctionInformationMap extends
           return this;
         }
       }
-      
+
       public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap.Entry other) {
         if (other == com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance()) return this;
         if (other.hasId()) {
@@ -361,7 +361,7 @@ public  final class FunctionInformationMap extends
         this.mergeUnknownFields(other.getUnknownFields());
         return this;
       }
-      
+
       public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
@@ -414,8 +414,8 @@ public  final class FunctionInformationMap extends
           }
         }
       }
-      
-      
+
+
       // required int32 id = 2;
       public boolean hasId() {
         return result.hasId();
@@ -433,7 +433,7 @@ public  final class FunctionInformationMap extends
         result.id_ = 0;
         return this;
       }
-      
+
       // required string source_name = 3;
       public boolean hasSourceName() {
         return result.hasSourceName();
@@ -454,7 +454,7 @@ public  final class FunctionInformationMap extends
         result.sourceName_ = getDefaultInstance().getSourceName();
         return this;
       }
-      
+
       // required int32 line_number = 4;
       public boolean hasLineNumber() {
         return result.hasLineNumber();
@@ -472,7 +472,7 @@ public  final class FunctionInformationMap extends
         result.lineNumber_ = 0;
         return this;
       }
-      
+
       // required string module_name = 5;
       public boolean hasModuleName() {
         return result.hasModuleName();
@@ -493,7 +493,7 @@ public  final class FunctionInformationMap extends
         result.moduleName_ = getDefaultInstance().getModuleName();
         return this;
       }
-      
+
       // required int32 size = 6;
       public boolean hasSize() {
         return result.hasSize();
@@ -511,7 +511,7 @@ public  final class FunctionInformationMap extends
         result.size_ = 0;
         return this;
       }
-      
+
       // required string name = 7;
       public boolean hasName() {
         return result.hasName();
@@ -532,7 +532,7 @@ public  final class FunctionInformationMap extends
         result.name_ = getDefaultInstance().getName();
         return this;
       }
-      
+
       // required string compiled_source = 8;
       public boolean hasCompiledSource() {
         return result.hasCompiledSource();
@@ -553,19 +553,19 @@ public  final class FunctionInformationMap extends
         result.compiledSource_ = getDefaultInstance().getCompiledSource();
         return this;
       }
-      
+
       // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap.Entry)
     }
-    
+
     static {
       defaultInstance = new Entry(true);
       com.google.javascript.jscomp.FunctionInfo.internalForceInit();
       defaultInstance.initFields();
     }
-    
+
     // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap.Entry)
   }
-  
+
   public static final class Module extends
       com.google.protobuf.GeneratedMessage {
     // Use Module.newBuilder() to construct.
@@ -573,40 +573,40 @@ public  final class FunctionInformationMap extends
       initFields();
     }
     private Module(boolean noInit) {}
-    
+
     private static final Module defaultInstance;
     public static Module getDefaultInstance() {
       return defaultInstance;
     }
-    
+
     public Module getDefaultInstanceForType() {
       return defaultInstance;
     }
-    
+
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_descriptor;
     }
-    
+
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_fieldAccessorTable;
     }
-    
+
     // required string name = 102;
     public static final int NAME_FIELD_NUMBER = 102;
     private boolean hasName;
     private java.lang.String name_ = "";
     public boolean hasName() { return hasName; }
     public java.lang.String getName() { return name_; }
-    
+
     // required string compiled_source = 103;
     public static final int COMPILED_SOURCE_FIELD_NUMBER = 103;
     private boolean hasCompiledSource;
     private java.lang.String compiledSource_ = "";
     public boolean hasCompiledSource() { return hasCompiledSource; }
     public java.lang.String getCompiledSource() { return compiledSource_; }
-    
+
     private void initFields() {
     }
     public final boolean isInitialized() {
@@ -614,7 +614,7 @@ public  final class FunctionInformationMap extends
       if (!hasCompiledSource) return false;
       return true;
     }
-    
+
     public void writeTo(com.google.protobuf.CodedOutputStream output)
                         throws java.io.IOException {
       getSerializedSize();
@@ -626,12 +626,12 @@ public  final class FunctionInformationMap extends
       }
       getUnknownFields().writeTo(output);
     }
-    
+
     private int memoizedSerializedSize = -1;
     public int getSerializedSize() {
       int size = memoizedSerializedSize;
       if (size != -1) return size;
-    
+
       size = 0;
       if (hasName()) {
         size += com.google.protobuf.CodedOutputStream
@@ -645,7 +645,7 @@ public  final class FunctionInformationMap extends
       memoizedSerializedSize = size;
       return size;
     }
-    
+
     public static com.google.javascript.jscomp.FunctionInformationMap.Module parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
@@ -712,31 +712,31 @@ public  final class FunctionInformationMap extends
       return newBuilder().mergeFrom(input, extensionRegistry)
                .buildParsed();
     }
-    
+
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
     public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap.Module prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
-    
+
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder> {
       private com.google.javascript.jscomp.FunctionInformationMap.Module result;
-      
+
       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Module.newBuilder()
       private Builder() {}
-      
+
       private static Builder create() {
         Builder builder = new Builder();
         builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
         return builder;
       }
-      
+
       protected com.google.javascript.jscomp.FunctionInformationMap.Module internalGetResult() {
         return result;
       }
-      
+
       public Builder clear() {
         if (result == null) {
           throw new IllegalStateException(
@@ -745,20 +745,20 @@ public  final class FunctionInformationMap extends
         result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
         return this;
       }
-      
+
       public Builder clone() {
         return create().mergeFrom(result);
       }
-      
+
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
         return com.google.javascript.jscomp.FunctionInformationMap.Module.getDescriptor();
       }
-      
+
       public com.google.javascript.jscomp.FunctionInformationMap.Module getDefaultInstanceForType() {
         return com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance();
       }
-      
+
       public boolean isInitialized() {
         return result.isInitialized();
       }
@@ -768,7 +768,7 @@ public  final class FunctionInformationMap extends
         }
         return buildPartial();
       }
-      
+
       private com.google.javascript.jscomp.FunctionInformationMap.Module buildParsed()
           throws com.google.protobuf.InvalidProtocolBufferException {
         if (!isInitialized()) {
@@ -777,7 +777,7 @@ public  final class FunctionInformationMap extends
         }
         return buildPartial();
       }
-      
+
       public com.google.javascript.jscomp.FunctionInformationMap.Module buildPartial() {
         if (result == null) {
           throw new IllegalStateException(
@@ -787,7 +787,7 @@ public  final class FunctionInformationMap extends
         result = null;
         return returnMe;
       }
-      
+
       public Builder mergeFrom(com.google.protobuf.Message other) {
         if (other instanceof com.google.javascript.jscomp.FunctionInformationMap.Module) {
           return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap.Module)other);
@@ -796,7 +796,7 @@ public  final class FunctionInformationMap extends
           return this;
         }
       }
-      
+
       public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap.Module other) {
         if (other == com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance()) return this;
         if (other.hasName()) {
@@ -808,7 +808,7 @@ public  final class FunctionInformationMap extends
         this.mergeUnknownFields(other.getUnknownFields());
         return this;
       }
-      
+
       public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
@@ -841,8 +841,8 @@ public  final class FunctionInformationMap extends
           }
         }
       }
-      
-      
+
+
       // required string name = 102;
       public boolean hasName() {
         return result.hasName();
@@ -863,7 +863,7 @@ public  final class FunctionInformationMap extends
         result.name_ = getDefaultInstance().getName();
         return this;
       }
-      
+
       // required string compiled_source = 103;
       public boolean hasCompiledSource() {
         return result.hasCompiledSource();
@@ -884,19 +884,19 @@ public  final class FunctionInformationMap extends
         result.compiledSource_ = getDefaultInstance().getCompiledSource();
         return this;
       }
-      
+
       // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap.Module)
     }
-    
+
     static {
       defaultInstance = new Module(true);
       com.google.javascript.jscomp.FunctionInfo.internalForceInit();
       defaultInstance.initFields();
     }
-    
+
     // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap.Module)
   }
-  
+
   // repeated group Entry = 1 {
   public static final int ENTRY_FIELD_NUMBER = 1;
   private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =
@@ -908,7 +908,7 @@ public  final class FunctionInformationMap extends
   public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {
     return entry_.get(index);
   }
-  
+
   // repeated group Module = 101 {
   public static final int MODULE_FIELD_NUMBER = 101;
   private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =
@@ -920,7 +920,7 @@ public  final class FunctionInformationMap extends
   public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {
     return module_.get(index);
   }
-  
+
   private void initFields() {
   }
   public final boolean isInitialized() {
@@ -932,7 +932,7 @@ public  final class FunctionInformationMap extends
     }
     return true;
   }
-  
+
   public void writeTo(com.google.protobuf.CodedOutputStream output)
                       throws java.io.IOException {
     getSerializedSize();
@@ -944,12 +944,12 @@ public  final class FunctionInformationMap extends
     }
     getUnknownFields().writeTo(output);
   }
-  
+
   private int memoizedSerializedSize = -1;
   public int getSerializedSize() {
     int size = memoizedSerializedSize;
     if (size != -1) return size;
-  
+
     size = 0;
     for (com.google.javascript.jscomp.FunctionInformationMap.Entry element : getEntryList()) {
       size += com.google.protobuf.CodedOutputStream
@@ -963,7 +963,7 @@ public  final class FunctionInformationMap extends
     memoizedSerializedSize = size;
     return size;
   }
-  
+
   public static com.google.javascript.jscomp.FunctionInformationMap parseFrom(
       com.google.protobuf.ByteString data)
       throws com.google.protobuf.InvalidProtocolBufferException {
@@ -1030,31 +1030,31 @@ public  final class FunctionInformationMap extends
     return newBuilder().mergeFrom(input, extensionRegistry)
              .buildParsed();
   }
-  
+
   public static Builder newBuilder() { return Builder.create(); }
   public Builder newBuilderForType() { return newBuilder(); }
   public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap prototype) {
     return newBuilder().mergeFrom(prototype);
   }
   public Builder toBuilder() { return newBuilder(this); }
-  
+
   public static final class Builder extends
       com.google.protobuf.GeneratedMessage.Builder<Builder> {
     private com.google.javascript.jscomp.FunctionInformationMap result;
-    
+
     // Construct using com.google.javascript.jscomp.FunctionInformationMap.newBuilder()
     private Builder() {}
-    
+
     private static Builder create() {
       Builder builder = new Builder();
       builder.result = new com.google.javascript.jscomp.FunctionInformationMap();
       return builder;
     }
-    
+
     protected com.google.javascript.jscomp.FunctionInformationMap internalGetResult() {
       return result;
     }
-    
+
     public Builder clear() {
       if (result == null) {
         throw new IllegalStateException(
@@ -1063,20 +1063,20 @@ public  final class FunctionInformationMap extends
       result = new com.google.javascript.jscomp.FunctionInformationMap();
       return this;
     }
-    
+
     public Builder clone() {
       return create().mergeFrom(result);
     }
-    
+
     public com.google.protobuf.Descriptors.Descriptor
         getDescriptorForType() {
       return com.google.javascript.jscomp.FunctionInformationMap.getDescriptor();
     }
-    
+
     public com.google.javascript.jscomp.FunctionInformationMap getDefaultInstanceForType() {
       return com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance();
     }
-    
+
     public boolean isInitialized() {
       return result.isInitialized();
     }
@@ -1086,7 +1086,7 @@ public  final class FunctionInformationMap extends
       }
       return buildPartial();
     }
-    
+
     private com.google.javascript.jscomp.FunctionInformationMap buildParsed()
         throws com.google.protobuf.InvalidProtocolBufferException {
       if (!isInitialized()) {
@@ -1095,7 +1095,7 @@ public  final class FunctionInformationMap extends
       }
       return buildPartial();
     }
-    
+
     public com.google.javascript.jscomp.FunctionInformationMap buildPartial() {
       if (result == null) {
         throw new IllegalStateException(
@@ -1113,7 +1113,7 @@ public  final class FunctionInformationMap extends
       result = null;
       return returnMe;
     }
-    
+
     public Builder mergeFrom(com.google.protobuf.Message other) {
       if (other instanceof com.google.javascript.jscomp.FunctionInformationMap) {
         return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap)other);
@@ -1122,7 +1122,7 @@ public  final class FunctionInformationMap extends
         return this;
       }
     }
-    
+
     public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap other) {
       if (other == com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance()) return this;
       if (!other.entry_.isEmpty()) {
@@ -1140,7 +1140,7 @@ public  final class FunctionInformationMap extends
       this.mergeUnknownFields(other.getUnknownFields());
       return this;
     }
-    
+
     public Builder mergeFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
@@ -1177,8 +1177,8 @@ public  final class FunctionInformationMap extends
         }
       }
     }
-    
-    
+
+
     // repeated group Entry = 1 {
     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {
       return java.util.Collections.unmodifiableList(result.entry_);
@@ -1229,7 +1229,7 @@ public  final class FunctionInformationMap extends
       result.entry_ = java.util.Collections.emptyList();
       return this;
     }
-    
+
     // repeated group Module = 101 {
     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {
       return java.util.Collections.unmodifiableList(result.module_);
@@ -1280,16 +1280,16 @@ public  final class FunctionInformationMap extends
       result.module_ = java.util.Collections.emptyList();
       return this;
     }
-    
+
     // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap)
   }
-  
+
   static {
     defaultInstance = new FunctionInformationMap(true);
     com.google.javascript.jscomp.FunctionInfo.internalForceInit();
     defaultInstance.initFields();
   }
-  
+
   // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap)
 }
 
diff --git a/gen/com/google/javascript/jscomp/Instrumentation.java b/gen/com/google/javascript/jscomp/Instrumentation.java
index b0c845e2..03ba821b 100644
--- a/gen/com/google/javascript/jscomp/Instrumentation.java
+++ b/gen/com/google/javascript/jscomp/Instrumentation.java
@@ -9,47 +9,47 @@ public  final class Instrumentation extends
     initFields();
   }
   private Instrumentation(boolean noInit) {}
-  
+
   private static final Instrumentation defaultInstance;
   public static Instrumentation getDefaultInstance() {
     return defaultInstance;
   }
-  
+
   public Instrumentation getDefaultInstanceForType() {
     return defaultInstance;
   }
-  
+
   public static final com.google.protobuf.Descriptors.Descriptor
       getDescriptor() {
     return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_descriptor;
   }
-  
+
   protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internalGetFieldAccessorTable() {
     return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_fieldAccessorTable;
   }
-  
+
   // optional string report_defined = 1;
   public static final int REPORT_DEFINED_FIELD_NUMBER = 1;
   private boolean hasReportDefined;
   private java.lang.String reportDefined_ = "";
   public boolean hasReportDefined() { return hasReportDefined; }
   public java.lang.String getReportDefined() { return reportDefined_; }
-  
+
   // optional string report_call = 2;
   public static final int REPORT_CALL_FIELD_NUMBER = 2;
   private boolean hasReportCall;
   private java.lang.String reportCall_ = "";
   public boolean hasReportCall() { return hasReportCall; }
   public java.lang.String getReportCall() { return reportCall_; }
-  
+
   // optional string report_exit = 6;
   public static final int REPORT_EXIT_FIELD_NUMBER = 6;
   private boolean hasReportExit;
   private java.lang.String reportExit_ = "";
   public boolean hasReportExit() { return hasReportExit; }
   public java.lang.String getReportExit() { return reportExit_; }
-  
+
   // repeated string declaration_to_remove = 3;
   public static final int DECLARATION_TO_REMOVE_FIELD_NUMBER = 3;
   private java.util.List<java.lang.String> declarationToRemove_ =
@@ -61,7 +61,7 @@ public  final class Instrumentation extends
   public java.lang.String getDeclarationToRemove(int index) {
     return declarationToRemove_.get(index);
   }
-  
+
   // repeated string init = 4;
   public static final int INIT_FIELD_NUMBER = 4;
   private java.util.List<java.lang.String> init_ =
@@ -73,20 +73,20 @@ public  final class Instrumentation extends
   public java.lang.String getInit(int index) {
     return init_.get(index);
   }
-  
+
   // optional string app_name_setter = 5;
   public static final int APP_NAME_SETTER_FIELD_NUMBER = 5;
   private boolean hasAppNameSetter;
   private java.lang.String appNameSetter_ = "";
   public boolean hasAppNameSetter() { return hasAppNameSetter; }
   public java.lang.String getAppNameSetter() { return appNameSetter_; }
-  
+
   private void initFields() {
   }
   public final boolean isInitialized() {
     return true;
   }
-  
+
   public void writeTo(com.google.protobuf.CodedOutputStream output)
                       throws java.io.IOException {
     getSerializedSize();
@@ -110,12 +110,12 @@ public  final class Instrumentation extends
     }
     getUnknownFields().writeTo(output);
   }
-  
+
   private int memoizedSerializedSize = -1;
   public int getSerializedSize() {
     int size = memoizedSerializedSize;
     if (size != -1) return size;
-  
+
     size = 0;
     if (hasReportDefined()) {
       size += com.google.protobuf.CodedOutputStream
@@ -155,7 +155,7 @@ public  final class Instrumentation extends
     memoizedSerializedSize = size;
     return size;
   }
-  
+
   public static com.google.javascript.jscomp.Instrumentation parseFrom(
       com.google.protobuf.ByteString data)
       throws com.google.protobuf.InvalidProtocolBufferException {
@@ -222,31 +222,31 @@ public  final class Instrumentation extends
     return newBuilder().mergeFrom(input, extensionRegistry)
              .buildParsed();
   }
-  
+
   public static Builder newBuilder() { return Builder.create(); }
   public Builder newBuilderForType() { return newBuilder(); }
   public static Builder newBuilder(com.google.javascript.jscomp.Instrumentation prototype) {
     return newBuilder().mergeFrom(prototype);
   }
   public Builder toBuilder() { return newBuilder(this); }
-  
+
   public static final class Builder extends
       com.google.protobuf.GeneratedMessage.Builder<Builder> {
     private com.google.javascript.jscomp.Instrumentation result;
-    
+
     // Construct using com.google.javascript.jscomp.Instrumentation.newBuilder()
     private Builder() {}
-    
+
     private static Builder create() {
       Builder builder = new Builder();
       builder.result = new com.google.javascript.jscomp.Instrumentation();
       return builder;
     }
-    
+
     protected com.google.javascript.jscomp.Instrumentation internalGetResult() {
       return result;
     }
-    
+
     public Builder clear() {
       if (result == null) {
         throw new IllegalStateException(
@@ -255,20 +255,20 @@ public  final class Instrumentation extends
       result = new com.google.javascript.jscomp.Instrumentation();
       return this;
     }
-    
+
     public Builder clone() {
       return create().mergeFrom(result);
     }
-    
+
     public com.google.protobuf.Descriptors.Descriptor
         getDescriptorForType() {
       return com.google.javascript.jscomp.Instrumentation.getDescriptor();
     }
-    
+
     public com.google.javascript.jscomp.Instrumentation getDefaultInstanceForType() {
       return com.google.javascript.jscomp.Instrumentation.getDefaultInstance();
     }
-    
+
     public boolean isInitialized() {
       return result.isInitialized();
     }
@@ -278,7 +278,7 @@ public  final class Instrumentation extends
       }
       return buildPartial();
     }
-    
+
     private com.google.javascript.jscomp.Instrumentation buildParsed()
         throws com.google.protobuf.InvalidProtocolBufferException {
       if (!isInitialized()) {
@@ -287,7 +287,7 @@ public  final class Instrumentation extends
       }
       return buildPartial();
     }
-    
+
     public com.google.javascript.jscomp.Instrumentation buildPartial() {
       if (result == null) {
         throw new IllegalStateException(
@@ -305,7 +305,7 @@ public  final class Instrumentation extends
       result = null;
       return returnMe;
     }
-    
+
     public Builder mergeFrom(com.google.protobuf.Message other) {
       if (other instanceof com.google.javascript.jscomp.Instrumentation) {
         return mergeFrom((com.google.javascript.jscomp.Instrumentation)other);
@@ -314,7 +314,7 @@ public  final class Instrumentation extends
         return this;
       }
     }
-    
+
     public Builder mergeFrom(com.google.javascript.jscomp.Instrumentation other) {
       if (other == com.google.javascript.jscomp.Instrumentation.getDefaultInstance()) return this;
       if (other.hasReportDefined()) {
@@ -344,7 +344,7 @@ public  final class Instrumentation extends
       this.mergeUnknownFields(other.getUnknownFields());
       return this;
     }
-    
+
     public Builder mergeFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
@@ -393,8 +393,8 @@ public  final class Instrumentation extends
         }
       }
     }
-    
-    
+
+
     // optional string report_defined = 1;
     public boolean hasReportDefined() {
       return result.hasReportDefined();
@@ -415,7 +415,7 @@ public  final class Instrumentation extends
       result.reportDefined_ = getDefaultInstance().getReportDefined();
       return this;
     }
-    
+
     // optional string report_call = 2;
     public boolean hasReportCall() {
       return result.hasReportCall();
@@ -436,7 +436,7 @@ public  final class Instrumentation extends
       result.reportCall_ = getDefaultInstance().getReportCall();
       return this;
     }
-    
+
     // optional string report_exit = 6;
     public boolean hasReportExit() {
       return result.hasReportExit();
@@ -457,7 +457,7 @@ public  final class Instrumentation extends
       result.reportExit_ = getDefaultInstance().getReportExit();
       return this;
     }
-    
+
     // repeated string declaration_to_remove = 3;
     public java.util.List<java.lang.String> getDeclarationToRemoveList() {
       return java.util.Collections.unmodifiableList(result.declarationToRemove_);
@@ -497,7 +497,7 @@ public  final class Instrumentation extends
       result.declarationToRemove_ = java.util.Collections.emptyList();
       return this;
     }
-    
+
     // repeated string init = 4;
     public java.util.List<java.lang.String> getInitList() {
       return java.util.Collections.unmodifiableList(result.init_);
@@ -537,7 +537,7 @@ public  final class Instrumentation extends
       result.init_ = java.util.Collections.emptyList();
       return this;
     }
-    
+
     // optional string app_name_setter = 5;
     public boolean hasAppNameSetter() {
       return result.hasAppNameSetter();
@@ -558,16 +558,16 @@ public  final class Instrumentation extends
       result.appNameSetter_ = getDefaultInstance().getAppNameSetter();
       return this;
     }
-    
+
     // @@protoc_insertion_point(builder_scope:jscomp.Instrumentation)
   }
-  
+
   static {
     defaultInstance = new Instrumentation(true);
     com.google.javascript.jscomp.InstrumentationTemplate.internalForceInit();
     defaultInstance.initFields();
   }
-  
+
   // @@protoc_insertion_point(class_scope:jscomp.Instrumentation)
 }
 
diff --git a/gen/com/google/javascript/jscomp/InstrumentationTemplate.java b/gen/com/google/javascript/jscomp/InstrumentationTemplate.java
index 73f329e7..8c857d78 100644
--- a/gen/com/google/javascript/jscomp/InstrumentationTemplate.java
+++ b/gen/com/google/javascript/jscomp/InstrumentationTemplate.java
@@ -13,7 +13,7 @@ public final class InstrumentationTemplate {
   static
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internal_static_jscomp_Instrumentation_fieldAccessorTable;
-  
+
   public static com.google.protobuf.Descriptors.FileDescriptor
       getDescriptor() {
     return descriptor;
@@ -50,8 +50,8 @@ public final class InstrumentationTemplate {
         new com.google.protobuf.Descriptors.FileDescriptor[] {
         }, assigner);
   }
-  
+
   public static void internalForceInit() {}
-  
+
   // @@protoc_insertion_point(outer_class_scope)
 }
diff --git a/src/com/google/javascript/jscomp/CheckRegExp.java b/src/com/google/javascript/jscomp/CheckRegExp.java
index 72febcff..264d3c18 100644
--- a/src/com/google/javascript/jscomp/CheckRegExp.java
+++ b/src/com/google/javascript/jscomp/CheckRegExp.java
@@ -22,7 +22,7 @@ import com.google.javascript.rhino.Node;
 /**
  * Look for references to the global RegExp object that would cause
  * regular expressions to be unoptimizable.
- * 
+ *
  * @author johnlenz@google.com (John Lenz)
  */
 class CheckRegExp extends AbstractPostOrderCallback implements CompilerPass {
@@ -54,7 +54,7 @@ class CheckRegExp extends AbstractPostOrderCallback implements CompilerPass {
       String name = n.getString();
       if (name.equals("RegExp") && t.getScope().getVar(name) == null) {
         int parentType = parent.getType();
-        boolean first = (n == parent.getFirstChild()); 
+        boolean first = (n == parent.getFirstChild());
         if (!((parentType == Token.NEW && first)
                || (parentType == Token.CALL && first)
                || (parentType == Token.INSTANCEOF && !first))) {
diff --git a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java
index 01a9cc78..3e0fb1ec 100644
--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java
+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java
@@ -272,7 +272,7 @@ class FunctionToBlockMutator {
 
         Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);
         newRoot.addChildrenToBack(label);
-        
+
 
         // The label is now the root.
         root = newRoot;
diff --git a/src/com/google/javascript/jscomp/JoinOp.java b/src/com/google/javascript/jscomp/JoinOp.java
index a4b084f4..3e0a94fe 100644
--- a/src/com/google/javascript/jscomp/JoinOp.java
+++ b/src/com/google/javascript/jscomp/JoinOp.java
@@ -47,7 +47,7 @@ interface JoinOp<L extends LatticeElement> extends Function<List<L>, L> {
             apply(values.subList(mid, size)));
       }
     }
-    
+
     /**
      * Creates a new lattice that will be the join of two input lattices.
      *
diff --git a/src/com/google/javascript/jscomp/JsMessageVisitor.java b/src/com/google/javascript/jscomp/JsMessageVisitor.java
index a217e243..6e47634f 100644
--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java
+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java
@@ -247,12 +247,12 @@ abstract class JsMessageVisitor extends AbstractPostOrderCallback
     JsMessage extractedMessage = builder.build(idGenerator);
 
     // If asked to check named internal messages.
-    if (needToCheckDuplications 
-        && !isUnnamedMsg 
+    if (needToCheckDuplications
+        && !isUnnamedMsg
         && !extractedMessage.isExternal()) {
       checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode);
-    }    
-    
+    }
+
     if (extractedMessage.isEmpty()) {
       // value of the message is an empty string. Translators do not like it.
       compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,
diff --git a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
index eab4ba76..6e4990f8 100644
--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
@@ -328,7 +328,7 @@ class MakeDeclaredNamesUnique
         nameMap.remove(name);
       }
     }
- 
+
     /**
      * Find a name usable in the local scope.
      */
@@ -337,7 +337,7 @@ class MakeDeclaredNamesUnique
       String newName = original;
       int i = 0;
       while (!isValidName(newName)) {
-        newName = original + 
+        newName = original +
             ContextualRenamer.UNIQUE_ID_SEPARATOR + String.valueOf(i++);
       }
       return newName;
@@ -549,7 +549,7 @@ class MakeDeclaredNamesUnique
   static class BoilerplateRenamer extends ContextualRenamer {
     private final Supplier<String> uniqueIdSupplier;
     private final String idPrefix;
-    
+
     BoilerplateRenamer(
         Supplier<String> uniqueIdSupplier,
         String idPrefix) {
diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java
index 3717add2..508ff8f5 100644
--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java
+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java
@@ -205,7 +205,7 @@ class MinimizeExitPoints
 
   /**
    * Look for exits (returns, breaks, or continues, depending on the context) at
-   * the end of a block and removes them by moving the if node's siblings, 
+   * the end of a block and removes them by moving the if node's siblings,
    * if any, into the opposite condition block.
    *
    * @param srcBlock The block to inspect.
diff --git a/src/com/google/javascript/jscomp/OptimizeCalls.java b/src/com/google/javascript/jscomp/OptimizeCalls.java
index f47932a0..7260627c 100644
--- a/src/com/google/javascript/jscomp/OptimizeCalls.java
+++ b/src/com/google/javascript/jscomp/OptimizeCalls.java
@@ -28,22 +28,22 @@ import java.util.List;
  *   - optimize parameters
  *   - optimize returns
  *   - devirtualize prototype methods
- * 
+ *
  * @author johnlenz@google.com (John Lenz)
  */
 class OptimizeCalls implements CompilerPass {
   List<CallGraphCompilerPass> passes = Lists.newArrayList();
   private AbstractCompiler compiler;
-  
+
   OptimizeCalls(AbstractCompiler compiler) {
     this.compiler = compiler;
   }
-  
+
   OptimizeCalls addPass(CallGraphCompilerPass pass) {
     passes.add(pass);
     return this;
   }
-  
+
   interface CallGraphCompilerPass {
     void process(Node externs, Node root, SimpleDefinitionFinder definitions);
   }
diff --git a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java
index 91e1892c..c85f96f6 100644
--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java
+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java
@@ -23,19 +23,19 @@ import com.google.javascript.rhino.jstype.JSType;
 
 /**
  * Performs type-aware peephole optimizations.
- * 
+ *
  * These peephole optimizations are in their own class because
  * type information may not always be available (such as during pre-processing)
  * or may not be turned on.
- * 
+ *
  * Currently only Token.TYPEOF is folded -- in the future it may be possible to
  * fold Token.INSTANCEOF as well. Another possibility is folding when
  * non-nullable objects are used in boolean logic, such as:
  * "if (x) {" or "(!x) ? a : b" or "x && foo()"
- * 
+ *
  * TODO(dcc): Support folding Token.INSTANCEOF and non-nullable objects
  * in boolean logic.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {
@@ -49,11 +49,11 @@ class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {
         return subtree;
     }
   }
-  
+
   /**
    * Folds "typeof expression" based on the JSType of "expression" if the
    * expression  has no side effects.
-   * 
+   *
    * <p>E.g.,
    * <pre>
    * var x = 6;
@@ -66,24 +66,24 @@ class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {
    * if ("number" == "number") {
    * }
    * </pre>
-   * 
+   *
    * <p>This method doesn't fold literal values -- we leave that to
    * PeepholeFoldConstants.
    */
   private Node tryFoldTypeof(Node typeofNode) {
     Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);
     Preconditions.checkArgument(typeofNode.getFirstChild() != null);
-    
+
     Node argumentNode = typeofNode.getFirstChild();
-    
+
     // We'll let PeepholeFoldConstants handle folding literals
     // and we can't remove arguments with possible side effects.
     if (!NodeUtil.isLiteralValue(argumentNode, true) &&
         !mayHaveSideEffects(argumentNode)) {
       JSType argumentType = argumentNode.getJSType();
-            
+
       String typeName = null;
-      
+
       if (argumentType != null) {
         // typeof null is "object" in JavaScript
         if (argumentType.isObject() || argumentType.isNullType()) {
@@ -102,16 +102,16 @@ class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {
           // in the future.
           typeName = null;
         }
-               
+
         if (typeName != null) {
           Node newNode = Node.newString(typeName);
           typeofNode.getParent().replaceChild(typeofNode, newNode);
           reportCodeChange();
-          
+
           return newNode;
         }
-      }     
-    }  
+      }
+    }
     return typeofNode;
   }
 }
diff --git a/src/com/google/javascript/jscomp/ProcessTweaks.java b/src/com/google/javascript/jscomp/ProcessTweaks.java
index 1d0cd988..a676e45e 100644
--- a/src/com/google/javascript/jscomp/ProcessTweaks.java
+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java
@@ -51,7 +51,7 @@ class ProcessTweaks implements CompilerPass {
   private final AbstractCompiler compiler;
   private final boolean stripTweaks;
   private final SortedMap<String, Node> compilerDefaultValueOverrides;
-  
+
   private static final CharMatcher ID_MATCHER = CharMatcher.inRange('a', 'z').
       or(CharMatcher.inRange('A', 'Z')).or(CharMatcher.anyOf("0123456789_."));
 
@@ -70,7 +70,7 @@ class ProcessTweaks implements CompilerPass {
       DiagnosticType.error(
           "JSC_NON_LITERAL_TWEAK_ID_ERROR",
           "tweak ID must be a string literal");
-  
+
   static final DiagnosticType INVALID_TWEAK_DEFAULT_VALUE_WARNING =
       DiagnosticType.warning(
           "JSC_INVALID_TWEAK_DEFAULT_VALUE_WARNING",
@@ -81,13 +81,13 @@ class ProcessTweaks implements CompilerPass {
       DiagnosticType.error(
           "JSC_NON_GLOBAL_TWEAK_INIT_ERROR",
           "tweak declaration {0} must occur in the global scope");
-  
+
   static final DiagnosticType TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR =
       DiagnosticType.error(
           "JSC_TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR",
           "Cannot override the default value of tweak {0} after it has been " +
           "registered");
-  
+
   static final DiagnosticType TWEAK_WRONG_GETTER_TYPE_WARNING =
       DiagnosticType.warning(
           "JSC_TWEAK_WRONG_GETTER_TYPE_WARNING",
@@ -118,11 +118,11 @@ class ProcessTweaks implements CompilerPass {
     final int validNodeTypeA;
     final int validNodeTypeB;
     final TweakFunction registerFunction;
-    
+
     TweakFunction(String name) {
       this(name, null, Token.ERROR, Token.ERROR, null);
     }
-    
+
     TweakFunction(String name, String expectedTypeName,
         int validNodeTypeA) {
       this(name, expectedTypeName, validNodeTypeA, Token.ERROR, null);
@@ -146,16 +146,16 @@ class ProcessTweaks implements CompilerPass {
       this.validNodeTypeB = validNodeTypeB;
       this.registerFunction = registerFunction;
     }
-    
+
     boolean isValidNodeType(int type) {
       return type == validNodeTypeA || type == validNodeTypeB;
     }
-    
+
     boolean isCorrectRegisterFunction(TweakFunction registerFunction) {
       Preconditions.checkNotNull(registerFunction);
       return this.registerFunction == registerFunction;
     }
-    
+
     boolean isGetterFunction() {
       return registerFunction != null;
     }
@@ -167,7 +167,7 @@ class ProcessTweaks implements CompilerPass {
     String getExpectedTypeName() {
       return expectedTypeName;
     }
-    
+
     Node createDefaultValueNode() {
       switch (this) {
         case REGISTER_BOOLEAN:
@@ -180,7 +180,7 @@ class ProcessTweaks implements CompilerPass {
       throw new IllegalStateException();
     }
   }
-  
+
   // A map of function name -> TweakFunction.
   private static final Map<String, TweakFunction> TWEAK_FUNCTIONS_MAP;
   static {
@@ -189,7 +189,7 @@ class ProcessTweaks implements CompilerPass {
       TWEAK_FUNCTIONS_MAP.put(func.getName(), func);
     }
   }
-          
+
   ProcessTweaks(AbstractCompiler compiler, boolean stripTweaks,
       Map<String, Node> compilerDefaultValueOverrides) {
     this.compiler = compiler;
@@ -266,7 +266,7 @@ class ProcessTweaks implements CompilerPass {
   }
 
   /**
-   * Creates a JS object that holds a map of tweakId -> default value override. 
+   * Creates a JS object that holds a map of tweakId -> default value override.
    */
   private Node createCompilerDefaultValueOverridesVarNode(
       Node sourceInformationNode) {
@@ -313,18 +313,18 @@ class ProcessTweaks implements CompilerPass {
   private CollectTweaksResult collectTweaks(Node root) {
     CollectTweaks pass = new CollectTweaks();
     NodeTraversal.traverse(compiler, root, pass);
-    
+
     Map<String, TweakInfo> tweakInfos = pass.allTweaks;
     for (TweakInfo tweakInfo: tweakInfos.values()) {
       tweakInfo.emitAllWarnings();
     }
     return new CollectTweaksResult(tweakInfos, pass.getOverridesCalls);
   }
-  
+
   private final static class CollectTweaksResult {
     final Map<String, TweakInfo> tweakInfos;
     final List<TweakFunctionCall> getOverridesCalls;
-    
+
     CollectTweaksResult(Map<String, TweakInfo> tweakInfos,
         List<TweakFunctionCall> getOverridesCalls) {
       this.tweakInfos = tweakInfos;
@@ -350,7 +350,7 @@ class ProcessTweaks implements CompilerPass {
       if (tweakFunc == null) {
         return;
       }
-      
+
       if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {
         getOverridesCalls.add(
             new TweakFunctionCall(t.getSourceName(), tweakFunc, n));
@@ -364,14 +364,14 @@ class ProcessTweaks implements CompilerPass {
         return;
       }
       String tweakId = tweakIdNode.getString();
-      
+
       // Make sure there is a TweakInfo structure for it.
       TweakInfo tweakInfo = allTweaks.get(tweakId);
       if (tweakInfo == null) {
         tweakInfo = new TweakInfo(tweakId);
         allTweaks.put(tweakId, tweakInfo);
       }
-      
+
       switch (tweakFunc) {
         case REGISTER_BOOLEAN:
         case REGISTER_NUMBER:
@@ -387,14 +387,14 @@ class ProcessTweaks implements CompilerPass {
                 t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));
             break;
           }
-          
+
           // Ensure tweaks are registered only once.
           if (tweakInfo.isRegistered()) {
             compiler.report(
                 t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));
             break;
           }
-          
+
           Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();
           tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,
               tweakDefaultValueNode);
@@ -438,7 +438,7 @@ class ProcessTweaks implements CompilerPass {
         Node callNode) {
       this(sourceName, tweakFunc, callNode, null);
     }
-    
+
     TweakFunctionCall(String sourceName, TweakFunction tweakFunc, Node callNode,
         Node valueNode) {
       this.sourceName = sourceName;
@@ -446,12 +446,12 @@ class ProcessTweaks implements CompilerPass {
       this.tweakFunc = tweakFunc;
       this.valueNode = valueNode;
     }
-    
+
     Node getIdNode() {
       return callNode.getFirstChild().getNext();
     }
   }
-  
+
   /**
    * Stores information about a single tweak.
    */
@@ -460,16 +460,16 @@ class ProcessTweaks implements CompilerPass {
     final List<TweakFunctionCall> functionCalls;
     TweakFunctionCall registerCall;
     Node defaultValueNode;
-    
+
     TweakInfo(String tweakId) {
       this.tweakId = tweakId;
       functionCalls = Lists.newArrayList();
     }
-    
+
     /**
      * If this tweak is registered, then looks for type warnings in default
      * value parameters and getter functions. If it is not registered, emits an
-     * error for each function call. 
+     * error for each function call.
      */
     void emitAllWarnings() {
       if (isRegistered()) {
@@ -489,7 +489,7 @@ class ProcessTweaks implements CompilerPass {
         TweakFunction tweakFunc = call.tweakFunc;
         TweakFunction registerFunc = registerCall.tweakFunc;
         if (valueNode != null) {
-          // For register* and overrideDefaultValue calls, ensure the default  
+          // For register* and overrideDefaultValue calls, ensure the default
           // value is a literal of the correct type.
           if (!registerFunc.isValidNodeType(valueNode.getType())) {
             compiler.report(JSError.make(call.sourceName,
@@ -507,7 +507,7 @@ class ProcessTweaks implements CompilerPass {
         }
       }
     }
-    
+
     /**
      * Emits an error for each function call that was found.
      */
@@ -524,14 +524,14 @@ class ProcessTweaks implements CompilerPass {
           defaultValueNode);
       functionCalls.add(registerCall);
     }
-    
+
     void addOverrideDefaultValueCall(String sourceName,
         TweakFunction tweakFunc, Node callNode, Node defaultValueNode) {
       functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode,
           defaultValueNode));
       this.defaultValueNode = defaultValueNode;
     }
-    
+
     void addGetterCall(String sourceName, TweakFunction tweakFunc,
         Node callNode) {
       functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode));
@@ -540,7 +540,7 @@ class ProcessTweaks implements CompilerPass {
     boolean isRegistered() {
       return registerCall != null;
     }
-    
+
     Node getDefaultValueNode() {
       Preconditions.checkState(isRegistered());
       // Use calls to goog.tweak.overrideDefaultValue() first.
diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
index 7abedc4f..e3edbb4d 100644
--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
@@ -106,7 +106,7 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
   public Set<Var> getReferencedVariables() {
     return referenceMap.keySet();
   }
-  
+
   /**
    * Gets the reference collection for the given variable.
    */
diff --git a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java
index 8bcd4359..8fd49165 100644
--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java
+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java
@@ -36,22 +36,22 @@ import java.util.Set;
 /**
  * A pass that analyzes side effects to determine when it is safe to move
  * code from one program point to another.
- * 
+ *
  * In its current form, SideEffectsAnalysis is very incomplete; this is
  * mostly a sketch to prototype the interface and the broad strokes of
  * a possible implementation based on flow-insensitive MOD and REF sets.
- * 
+ *
  * See:
- * 
+ *
  * Banning, John. An efficient way to find the side effects of procedure
  *      calls and the aliases of variables. POPL 79.
- * 
+ *
  * For an introduction to MOD and REF sets.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
  class SideEffectsAnalysis implements CompilerPass {
-  
+
    /**
     * The type of location abstraction to use for this analysis.
     */
@@ -61,43 +61,43 @@ import java.util.Set;
     /** See {@link VisibilityLocationAbstraction} for details. */
     VISIBILITY_BASED
   }
-  
-  private static final Predicate<Node> NOT_FUNCTION_PREDICATE = 
+
+  private static final Predicate<Node> NOT_FUNCTION_PREDICATE =
       new Predicate<Node>() {
     @Override
     public boolean apply(Node input) {
       return !NodeUtil.isFunction(input);
     }
   };
-  
+
   private AbstractCompiler compiler;
-  
+
   /** The location abstraction used to calculate the effects of code */
   private LocationAbstraction locationAbstraction;
-  
+
   /** The kind of location abstraction to use */
   private final LocationAbstractionMode locationAbstractionIdentifier;
-  
+
   /**
    * Constructs a new SideEffectsAnalysis with the given location abstraction.
-   * 
+   *
    * @param compiler A compiler instance
    * @param locationAbstractionMode The location abstration to use. {@code
    *    DEGENERATE} will use {@link DegenerateLocationAbstraction} while
    *    {@code VISIBILITY_BASED} will use {@link VisibilityLocationAbstraction}
-   *    
+   *
    */
   public SideEffectsAnalysis(AbstractCompiler compiler,
       LocationAbstractionMode locationAbstractionMode) {
     this.compiler = compiler;
-    
+
     this.locationAbstractionIdentifier = locationAbstractionMode;
   }
-  
+
   public SideEffectsAnalysis(AbstractCompiler compiler) {
     this(compiler, LocationAbstractionMode.DEGENERATE);
   }
-  
+
   @Override
   public void process(Node externs, Node root) {
     switch(locationAbstractionIdentifier) {
@@ -105,71 +105,71 @@ import java.util.Set;
         locationAbstraction = new DegenerateLocationAbstraction();
         break;
       case VISIBILITY_BASED:
-        locationAbstraction = createVisibilityAbstraction(externs, root); 
+        locationAbstraction = createVisibilityAbstraction(externs, root);
         break;
       default:
         throw new IllegalStateException("Unrecognized location abstraction " +
             "identifier: " + locationAbstractionIdentifier);
     }
-    
+
     // In the future, this method
     // will construct a callgraph and calculate side effects summaries
     // for all functions.
     // TODO(dcc): Add per-function side effects summaries.
   }
-  
+
   private LocationAbstraction createVisibilityAbstraction(Node externs,
       Node root) {
     VariableVisibilityAnalysis variableVisibility =
         new VariableVisibilityAnalysis(compiler);
-  
+
     variableVisibility.process(externs, root);
-  
+
     VariableUseDeclarationMap variableMap =
         new VariableUseDeclarationMap(compiler);
-  
+
     variableMap.mapUses(root);
-  
+
    return new VisibilityLocationAbstraction(compiler,
        variableVisibility, variableMap);
   }
-  
+
   /**
-   * Determines whether it is safe to move code ({@code source}) across 
+   * Determines whether it is safe to move code ({@code source}) across
    * an environment to another program point (immediately preceding
    * {@code destination}).
-   * 
-   * <p>The notion of "environment" is optimization-specific, but it should 
+   *
+   * <p>The notion of "environment" is optimization-specific, but it should
    * include any code that could be executed between the source program point
    * and the destination program point.
-   * 
-   * {@code destination} must not be a descendant of {@code source}. 
-   *  
+   *
+   * {@code destination} must not be a descendant of {@code source}.
+   *
    * @param source The node that would be moved
    * @param environment An environment representing the code across which
    *    the source will be moved.
    * @param destination The node before which the source would be moved
    * @return Whether it is safe to move the source to the destination
    */
-  public boolean safeToMoveBefore(Node source, 
+  public boolean safeToMoveBefore(Node source,
       AbstractMotionEnvironment environment,
       Node destination) {
     Preconditions.checkNotNull(locationAbstraction);
     Preconditions.checkArgument(!nodeHasAncestor(destination, source));
-    
+
     // It is always safe to move pure code.
     if (isPure(source)) {
       return true;
     }
 
-    // Don't currently support interprocedural analysis   
+    // Don't currently support interprocedural analysis
     if (nodeHasCall(source)) {
       return false;
     }
-    
+
     LocationSummary sourceLocationSummary =
         locationAbstraction.calculateLocationSummary(source);
-    
+
     EffectLocation sourceModSet = sourceLocationSummary.getModSet();
 
     // If the source has side effects, then we require that the source
@@ -182,16 +182,16 @@ import java.util.Set;
     EffectLocation sourceRefSet = sourceLocationSummary.getRefSet();
 
     Set<Node> environmentNodes = environment.calculateEnvironment();
-    
+
     for (Node environmentNode : environmentNodes) {
       if (nodeHasCall(environmentNode)) {
         return false;
       }
     }
-      
+
     LocationSummary environmentLocationSummary =
         locationAbstraction.calculateLocationSummary(environmentNodes);
-    
+
     EffectLocation environmentModSet = environmentLocationSummary.getModSet();
 
     EffectLocation environmentRefSet = environmentLocationSummary.getRefSet();
@@ -210,13 +210,13 @@ import java.util.Set;
         && !environmentRefSet.intersectsLocation(sourceModSet)
         && !environmentModSet.intersectsLocation(sourceModSet)) {
       return true;
-    } 
+    }
 
     return false;
   }
-  
+
   /**
-   * Returns true if the node is pure, that is it side effect free and does it 
+   * Returns true if the node is pure, that is it side effect free and does it
    * not depend on its environment?
    */
   private boolean isPure(Node node) {
@@ -224,47 +224,47 @@ import java.util.Set;
     // TODO(dcc): Implement isPure().
     return false;
   }
-  
+
   /**
-   * Returns true if the two nodes have the same control flow properties, 
+   * Returns true if the two nodes have the same control flow properties,
    * that is, is node1 be executed every time node2 is executed and vice versa?
    */
   private static boolean nodesHaveSameControlFlow(Node node1, Node node2) {
     /*
      * We conservatively approximate this with the following criteria:
-     * 
+     *
      * Define the "deepest control dependent block" for a node to be the
      * closest ancestor whose *parent* is a control structure and where that
      * ancestor may or may be executed depending on the parent.
-     * 
+     *
      * So, for example, in:
      * if (a) {
      *  b;
      * } else {
      *  c;
      * }
-     * 
+     *
      * a has not deepest control dependent block.
      * b's deepest control dependent block is the "then" block of the IF.
      * c's deepest control dependent block is the "else" block of the IF.
-     * 
+     *
      * We'll say two nodes have the same control flow if
-     * 
+     *
      * 1) they have the same deepest control dependent block
      * 2) that block is either a CASE (which can't have early exits) or it
      * doesn't have any early exits (e.g. breaks, continues, returns.)
-     * 
+     *
      */
-    
+
     Node node1DeepestControlDependentBlock =
         closestControlDependentAncestor(node1);
-    
+
     Node node2DeepestControlDependentBlock =
       closestControlDependentAncestor(node2);
-    
-    if (node1DeepestControlDependentBlock == 
+
+    if (node1DeepestControlDependentBlock ==
         node2DeepestControlDependentBlock) {
-      
+
       if (node2DeepestControlDependentBlock != null) {
         // CASE is complicated because we have to deal with fall through and
         // because some BREAKs are early exits and some are not.
@@ -274,7 +274,7 @@ import java.util.Set;
         if (node2DeepestControlDependentBlock.getType() == Token.CASE) {
           return false;
         }
-        
+
         // Don't allow breaks, continues, returns in control dependent
         // block because we don't actually create a control-flow graph
         // and so don't know if early exits site between the source
@@ -284,7 +284,7 @@ import java.util.Set;
         // moving in the following case:
         // while (a) {
         //   source();
-        //  
+        //
         //   while(b) {
         //     break;
         //   }
@@ -300,13 +300,13 @@ import java.util.Set;
           @Override
           public boolean apply(Node input) {
             int nodeType = input.getType();
-            
+
             return nodeType == Token.RETURN
                 || nodeType == Token.BREAK
                 || nodeType == Token.CONTINUE;
           }
         };
-        
+
         return !NodeUtil.has(node2DeepestControlDependentBlock,
             isEarlyExitPredicate, NOT_FUNCTION_PREDICATE);
       } else {
@@ -316,28 +316,28 @@ import java.util.Set;
       return false;
     }
   }
-  
+
   /**
    * Returns true if the number of times the child executes depends on the
    * parent.
-   * 
+   *
    * For example, the guard of an IF is not control dependent on the
    * IF, but its two THEN/ELSE blocks are.
-   * 
+   *
    * Also, the guard of WHILE and DO are control dependent on the parent
    * since the number of times it executes depends on the parent.
    */
   private static boolean isControlDependentChild(Node child) {
     Node parent = child.getParent();
-    
+
     if (parent == null) {
       return false;
     }
-    
+
     ArrayList<Node> siblings = Lists.newArrayList(parent.children());
-    
+
     int indexOfChildInParent = siblings.indexOf(child);
-    
+
     switch(parent.getType()) {
       case Token.IF:
       case Token.HOOK:
@@ -356,43 +356,43 @@ import java.util.Set;
         return true;
       case Token.FUNCTION:
         return true;
-      
+
       default:
         return false;
     }
   }
-  
-  private static Node closestControlDependentAncestor(Node node) { 
+
+  private static Node closestControlDependentAncestor(Node node) {
     if (isControlDependentChild(node)) {
       return node;
     }
-    
+
     // Note: node is not considered one of its ancestors
     for (Node ancestor : node.getAncestors()) {
       if (isControlDependentChild(ancestor)) {
         return ancestor;
       }
     }
-      
+
     return null;
   }
-  
+
   /**
    * Returns true if {@code possibleAncestor} is an ancestor of{@code node}.
    * A node is not considered to be an ancestor of itself.
    */
   private static boolean nodeHasAncestor(Node node, Node possibleAncestor) {
     // Note node is not in node.getAncestors()
-    
+
     for (Node ancestor : node.getAncestors()) {
       if (ancestor == possibleAncestor) {
         return true;
       }
     }
-   
+
     return false;
   }
-  
+
   /**
    * Returns true if a node has a CALL or a NEW descendant.
    */
@@ -404,27 +404,27 @@ import java.util.Set;
       }},
       NOT_FUNCTION_PREDICATE);
   }
-   
+
   /**
    * Represents an environment across which code might be moved, i.e. the set
    * of code that could be run in between the source and the destination.
-   * 
+   *
    * SideEffectAnalysis characterizes the code to be moved and the environment
    * in order to determine if they interact in such a way as to make the move
    * unsafe.
-   * 
+   *
    * Since determining the environment for an optimization can be tricky,
    * we provide several concrete subclasses that common classes of optimizations
    * may be able to reuse.
    */
   public abstract static class AbstractMotionEnvironment {
-    
+
     /**
      * Calculates the set of nodes that this environment represnts.
      */
     public abstract Set<Node> calculateEnvironment();
   }
-  
+
   /**
    * An environment for motion within a function. Given a
    * control flow graph and a source and destination node in the control
@@ -433,30 +433,30 @@ import java.util.Set;
    */
   public static class IntraproceduralMotionEnvironment
       extends AbstractMotionEnvironment {
-       
+
     /**
      * Creates an intraprocedural motion environment.
-     * 
+     *
      * @param controlFlowGraph A control flow graph for function in which
      * code will be moved
      * @param cfgSource The code to be moved
-     * @param cfgDestination The node immediately before which cfgSource 
+     * @param cfgDestination The node immediately before which cfgSource
      * will be moved
      */
     public IntraproceduralMotionEnvironment(
         ControlFlowGraph<Node> controlFlowGraph,
         Node cfgSource,
         Node cfgDestination) {
-      
+
     }
-    
+
     @Override
     public Set<Node> calculateEnvironment() {
       // TODO(dcc): Implement IntraproceduralMotionEnvironment
       return null;
-    } 
+    }
   }
-  
+
   /**
    * An environment for motion between modules. Given a
    * module graph and as well as source and destination nodes and modules,
@@ -468,7 +468,7 @@ import java.util.Set;
 
     /**
      * Creates a cross module code motion environment.
-     * 
+     *
      * @param sourceNode The code to be moved
      * @param sourceModule The module for the code to be moved
      * @param destinationNode The node before which sourceNode will be inserted
@@ -480,9 +480,9 @@ import java.util.Set;
         Node destinationNode,
         JSModule destinationModule,
         JSModuleGraph moduleGraph) {
-      
+
     }
-    
+
     @Override
     public Set<Node> calculateEnvironment() {
       // TODO(dcc): Implement CrossModuleMotionEnvironment
@@ -501,61 +501,61 @@ import java.util.Set;
     public RawMotionEnvironment(Set<Node> environment) {
       this.environment = environment;
     }
-    
+
     @Override
     public Set<Node> calculateEnvironment() {
       return environment;
     }
   }
-  
+
   /*
    * A combined representation for location set summaries.
-   * 
+   *
    * Basically, it is often easier to shuffle MOD/REF around together; this is
    * a value class for that purpose.
    */
   private static class LocationSummary {
-    
+
     private EffectLocation modSet;
     private EffectLocation refSet;
-    
+
     public LocationSummary(EffectLocation modSet, EffectLocation refSet) {
       this.modSet = modSet;
       this.refSet = refSet;
     }
-    
+
     public EffectLocation getModSet() {
       return modSet;
     }
-    
+
     public EffectLocation getRefSet() {
       return refSet;
-    }   
+    }
   }
-  
+
   /**
    * Interface representing the notion of an effect location -- an abstract
    * location that can be modified or referenced.
-   * 
+   *
    * <p>Since there are an infinite number of possible concrete locations
    * in a running program, this abstraction must be imprecise (i.e. there
    * will be some distinct concrete locations that are indistinguishable
    * under the abstraction).
-   * 
+   *
    * <p>Different location abstractions will provide their
    * own implementations of this interface, based on the level and kind
    * of precision they provide.
    */
   private static interface EffectLocation {
-    
+
     /**
      * Does the receiver's effect location intersect a given effect location?
-     * That is, could any of the concrete storage locations (fields, variables, 
+     * That is, could any of the concrete storage locations (fields, variables,
      * etc.) represented by the receiver be contained in the set of concrete
      * storage locations represented by the given abstract effect location.
      */
     public boolean intersectsLocation(EffectLocation otherLocation);
-    
+
     /**
      * Returns the result of merging the given effect location with
      * the receiver. The concrete locations represented by the result must
@@ -564,52 +564,52 @@ import java.util.Set;
      * introduce a loss of precision).
      */
     public EffectLocation join(EffectLocation otherLocation);
-    
+
     /**
      * Does the effect location represent any possible concrete locations?
      */
     public boolean isEmpty();
   }
-  
+
   /**
    * An abstract class representing a location abstraction. (Here "abstraction"
    * means an imprecise representation of concrete side effects.)
-   * 
-   * <p>Implementations of this class will each provide own their 
+   *
+   * <p>Implementations of this class will each provide own their
    * implementation(s) of SideEffectLocation and methods to determine the side
    * effect locations of a given piece of code.
    */
   private abstract static class LocationAbstraction  {
-       
+
     /** Calculates the abstraction-specific side effects
      * for the node.
      */
     abstract LocationSummary calculateLocationSummary(Node node);
-    
+
     /**
      * Returns an abstraction-specific EffectLocation representing
      * no location.
-     * 
+     *
      * <p>The bottom location joined with any location should return
      * that location.
      */
     abstract EffectLocation getBottomLocation();
 
-    /** 
+    /**
      * Calculates the abstraction-specific side effects
      * for the node.
      */
-    public LocationSummary calculateLocationSummary(Set<Node> nodes) {     
+    public LocationSummary calculateLocationSummary(Set<Node> nodes) {
       EffectLocation modAccumulator = getBottomLocation();
       EffectLocation refAccumulator = getBottomLocation();
-          
+
       for (Node node : nodes) {
         LocationSummary nodeLocationSummary = calculateLocationSummary(node);
-         
+
         modAccumulator = modAccumulator.join(nodeLocationSummary.getModSet());
         refAccumulator = refAccumulator.join(nodeLocationSummary.getRefSet());
       }
-     
+
       return new LocationSummary(modAccumulator, refAccumulator);
     }
   }
@@ -617,30 +617,30 @@ import java.util.Set;
    * A very imprecise location abstraction in which there are only two abstract
    * locations: one representing all concrete locations and one for bottom
    * (no concrete locations).
-   * 
+   *
    * This implementation is a thin wrapper on NodeUtil.mayHaveSideEffects()
    * and NodeUtil.canBeSideEffected() -- it doesn't add any real value other
    * than to prototype the LocationAbstraction interface.
    */
-  private static class DegenerateLocationAbstraction 
+  private static class DegenerateLocationAbstraction
       extends LocationAbstraction {
-    
+
     private static final EffectLocation EVERY_LOCATION =
         new DegenerateEffectLocation();
-    
+
     private static final EffectLocation NO_LOCATION =
         new DegenerateEffectLocation();
-    
+
     @Override
     EffectLocation getBottomLocation() {
       return NO_LOCATION;
     }
-    
+
     @Override
     public LocationSummary calculateLocationSummary(Node node) {
       return new LocationSummary(calculateModSet(node), calculateRefSet(node));
     }
-    
+
     EffectLocation calculateRefSet(Node node) {
       if (NodeUtil.canBeSideEffected(node)) {
         return EVERY_LOCATION;
@@ -648,7 +648,7 @@ import java.util.Set;
         return NO_LOCATION;
       }
     }
-    
+
     EffectLocation calculateModSet(Node node) {
       if (NodeUtil.mayHaveSideEffects(node)) {
         return EVERY_LOCATION;
@@ -656,7 +656,7 @@ import java.util.Set;
         return NO_LOCATION;
       }
     }
-    
+
     private static class DegenerateEffectLocation implements EffectLocation {
        public EffectLocation join(EffectLocation otherLocation) {
         if (otherLocation == EVERY_LOCATION) {
@@ -665,65 +665,65 @@ import java.util.Set;
           return this;
         }
       }
-      
+
       public boolean intersectsLocation(EffectLocation otherLocation) {
         return this == EVERY_LOCATION && otherLocation == EVERY_LOCATION;
       }
-      
+
       public boolean isEmpty() {
         return this == NO_LOCATION;
       }
     }
   }
-  
+
   /**
    * A location abstraction based on the visibility of concrete locations.
-   * 
+   *
    * A global variables are treated as one common location, as are all heap
    * storage locations.
-   * 
+   *
    * Local variables are broken up into two classes, one for truly local
    * variables and one for local variables captured by an inner scope. Each
    * of these classes has their own separate location representing the
    * variables in the class.
-   * 
+   *
    * Parameter variables are considered to be heap locations since they
    * can be accessed via the arguments object which itself can be aliased.
-   * 
+   *
    * A more precise analysis could:
    *    1) put parameters on the heap only when "arguments" is actually used
    *        in a method
    *    2) recognize that GETPROPs cannot access or modify parameters, only
    *        GETELEMs
-   *        
+   *
    * TODO(dcc): Don't merge parameters with the heap unless necessary.
-   * 
+   *
    * Internally, abstract locations are represented as integers
    * with bits set (masks) representing the storage classes in the location, so
    * that joining is bit-wise ORing and intersection is bitwise AND.
    */
-  private static class VisibilityLocationAbstraction 
+  private static class VisibilityLocationAbstraction
       extends LocationAbstraction {
 
     /** The "bottom" location. Used to signify an empty location set */
     private static final int VISIBILITY_LOCATION_NONE = 0;
-    
+
     /** The "top" location. Used to signify the set containing all locations */
     private static final int UNKNOWN_LOCATION_MASK = 0xFFFFFFFF;
-    
+
     private static final int LOCAL_VARIABLE_LOCATION_MASK = 1 << 1;
-        
+
     private static final int CAPTURED_LOCAL_VARIABLE_LOCATION_MASK = 1 << 2;
-    
+
     private static final int GLOBAL_VARIABLE_LOCATION_MASK = 1 << 3;
-    
+
     private static final int HEAP_LOCATION_MASK = 1 << 4;
-    
+
     AbstractCompiler compiler;
-    
+
     VariableVisibilityAnalysis variableVisibilityAnalysis;
     VariableUseDeclarationMap variableUseMap;
-    
+
     private VisibilityLocationAbstraction(AbstractCompiler compiler,
         VariableVisibilityAnalysis variableVisibilityAnalysis,
         VariableUseDeclarationMap variableUseMap) {
@@ -731,41 +731,41 @@ import java.util.Set;
       this.variableVisibilityAnalysis = variableVisibilityAnalysis;
       this.variableUseMap = variableUseMap;
     }
-    
+
     /**
      * Calculates the MOD/REF summary for the given node.
      */
     @Override
     LocationSummary calculateLocationSummary(Node node) {
       int visibilityRefLocations = VISIBILITY_LOCATION_NONE;
-      int visibilityModLocations = VISIBILITY_LOCATION_NONE;    
-      
+      int visibilityModLocations = VISIBILITY_LOCATION_NONE;
+
       for (Node reference : findStorageLocationReferences(node)) {
         int effectMask;
-        
+
         if (NodeUtil.isName(reference)) {
           // Variable access
           effectMask = effectMaskForVariableReference(reference);
          } else {
-          // Heap access       
+          // Heap access
           effectMask = HEAP_LOCATION_MASK;
         }
-        
+
         if (storageNodeIsLValue(reference)) {
           visibilityModLocations |= effectMask;
         }
-        
+
         if (storageNodeIsRValue(reference)) {
           visibilityRefLocations |= effectMask;
         }
-      }      
-          
+      }
+
       VisibilityBasedEffectLocation modSet =
           new VisibilityBasedEffectLocation(visibilityModLocations);
-      
+
       VisibilityBasedEffectLocation refSet =
         new VisibilityBasedEffectLocation(visibilityRefLocations);
-            
+
       return new LocationSummary(modSet, refSet);
     }
 
@@ -775,35 +775,35 @@ import java.util.Set;
      */
     private Set<Node> findStorageLocationReferences(Node root) {
       final Set<Node> references = Sets.newHashSet();
- 
+
       NodeTraversal.traverse(compiler, root, new AbstractShallowCallback() {
         @Override
         public void visit(NodeTraversal t, Node n, Node parent) {
           if (NodeUtil.isGet(n)
               || (NodeUtil.isName(n) && !NodeUtil.isFunction(parent))) {
             references.add(n);
-          } 
-        }       
+          }
+        }
       });
-      
+
       return references;
     }
-    
+
     /**
      * Calculates the effect mask for a variable reference.
      */
-    private int effectMaskForVariableReference(Node variableReference) { 
+    private int effectMaskForVariableReference(Node variableReference) {
       Preconditions.checkArgument(NodeUtil.isName(variableReference));
-      
+
       int effectMask = VISIBILITY_LOCATION_NONE;
-      
-      Node declaringNameNode = 
+
+      Node declaringNameNode =
         variableUseMap.findDeclaringNameNodeForUse(variableReference);
-      
+
       if (declaringNameNode != null) {
-        VariableVisibility visibility = 
+        VariableVisibility visibility =
           variableVisibilityAnalysis.getVariableVisibility(declaringNameNode);
-                  
+
         switch (visibility) {
           case LOCAL:
             effectMask = LOCAL_VARIABLE_LOCATION_MASK;
@@ -820,101 +820,101 @@ import java.util.Set;
             effectMask = GLOBAL_VARIABLE_LOCATION_MASK;
             break;
           default:
-            throw new IllegalStateException("Unrecognized variable" + 
+            throw new IllegalStateException("Unrecognized variable" +
                 " visibility: " + visibility);
         }
       } else {
         // Couldn't find a variable for the reference
         effectMask = UNKNOWN_LOCATION_MASK;
       }
-           
+
       return effectMask;
     }
-    
+
     @Override
     EffectLocation getBottomLocation() {
       return new VisibilityBasedEffectLocation(VISIBILITY_LOCATION_NONE);
     }
-    
+
     /**
      * Returns true if the node is a storage node.
-     * 
+     *
      * Only NAMEs, GETPROPs, and GETELEMs are storage nodes.
      */
     private static boolean isStorageNode(Node node) {
       return NodeUtil.isName(node) || NodeUtil.isGet(node);
     }
-    
+
     /**
      * Return true if the storage node is an r-value.
      */
     private static boolean storageNodeIsRValue(Node node) {
       Preconditions.checkArgument(isStorageNode(node));
-        
+
       // We consider all names to be r-values unless
       // LHS of Token.ASSIGN
       // LHS of of for in expression
       // Child of VAR
-      
+
       Node parent = node.getParent();
-      
+
       if (storageNodeIsLValue(node)) {
         // Assume l-value is NOT an r-value
         // unless it is a non-simple assign
         // or an increment/decrement
-        
-        boolean nonSimpleAssign = 
+
+        boolean nonSimpleAssign =
           NodeUtil.isAssignmentOp(parent) && parent.getType() != Token.ASSIGN;
-          
-        return (nonSimpleAssign 
+
+        return (nonSimpleAssign
             || parent.getType() == Token.DEC
-            || parent.getType() == Token.INC);      
+            || parent.getType() == Token.INC);
       }
-        
+
       return true;
     }
-    
+
     /**
      * Return true if the storage node is an l-value.
      */
     private static boolean storageNodeIsLValue(Node node) {
       Preconditions.checkArgument(isStorageNode(node));
-     
+
       Node parent = node.getParent();
-   
+
       return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)
           || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)
           || NodeUtil.isVar(parent)
           || parent.getType() == Token.DEC
           || parent.getType() == Token.INC;
     }
-    
+
     /**
      * An abstract effect location based the visibility of the
      * concrete storage location.
-     * 
+     *
      * See {@link VisibilityLocationAbstraction} for deeper description
      * of this abstraction.
-     * 
+     *
      * The effect locations are stored as bits set on an integer, so
      * intersect, join, etc. are the standard bitwise operations.
      */
-    private static class VisibilityBasedEffectLocation 
+    private static class VisibilityBasedEffectLocation
         implements EffectLocation {
       int visibilityMask = VISIBILITY_LOCATION_NONE;
-      
+
       public VisibilityBasedEffectLocation(int visibilityMask) {
         this.visibilityMask = visibilityMask;
       }
-      
+
       @Override
       public boolean intersectsLocation(EffectLocation otherLocation) {
-        Preconditions.checkArgument(otherLocation instanceof 
+        Preconditions.checkArgument(otherLocation instanceof
             VisibilityBasedEffectLocation);
-        
-        int otherMask = 
+
+        int otherMask =
             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;
-        
+
         return (visibilityMask & otherMask) > 0;
       }
 
@@ -925,19 +925,19 @@ import java.util.Set;
 
       @Override
       public EffectLocation join(EffectLocation otherLocation) {
-        Preconditions.checkArgument(otherLocation instanceof 
+        Preconditions.checkArgument(otherLocation instanceof
             VisibilityBasedEffectLocation);
-        
-        int otherMask = 
+
+        int otherMask =
             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;
-        
+
         int joinedMask = visibilityMask | otherMask;
-        
-        return new VisibilityBasedEffectLocation(joinedMask);       
-      }   
+
+        return new VisibilityBasedEffectLocation(joinedMask);
+      }
     }
   }
-  
+
   /**
    * Maps NAME nodes that refer to variables to the NAME
    * nodes that declared them.
@@ -945,43 +945,43 @@ import java.util.Set;
   private static class VariableUseDeclarationMap {
 
     private AbstractCompiler compiler;
-    
+
     // Maps a using name to its declaring name
     private Map<Node, Node> referencesByNameNode;
-    
+
     public VariableUseDeclarationMap(AbstractCompiler compiler) {
       this.compiler = compiler;
     }
-    
+
     /**
      * Adds a map from each use NAME in {@code root} to its corresponding
      * declaring name, *provided the declaration is also under root*.
-     * 
+     *
      * If the declaration is not under root, then the reference will
      * not be added to the map.
      */
     public void mapUses(Node root) {
       referencesByNameNode = Maps.newHashMap();
-      
-      ReferenceCollectingCallback callback = 
-        new ReferenceCollectingCallback(compiler, 
+
+      ReferenceCollectingCallback callback =
+        new ReferenceCollectingCallback(compiler,
             ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);
-      
+
       NodeTraversal.traverse(compiler, root, callback);
-      
+
       for (Var variable : callback.getReferencedVariables()) {
         ReferenceCollection referenceCollection =
             callback.getReferenceCollection(variable);
-             
-        for (Reference reference : referenceCollection.references) {      
+
+        for (Reference reference : referenceCollection.references) {
          Node referenceNameNode = reference.getNameNode();
-          
+
           // Note that this counts a declaration as a reference to itself
           referencesByNameNode.put(referenceNameNode, variable.getNameNode());
         }
       }
     }
-    
+
     /**
      * Returns the NAME node for the declaration of the variable
      * that {@code usingNameNode} refers to, if it is in the map,
@@ -989,7 +989,7 @@ import java.util.Set;
      */
     public Node findDeclaringNameNodeForUse(Node usingNameNode) {
       Preconditions.checkArgument(NodeUtil.isName(usingNameNode));
-      
+
       return referencesByNameNode.get(usingNameNode);
     }
   }
diff --git a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java
index 33704f80..11a8f88b 100644
--- a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java
+++ b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java
@@ -26,85 +26,85 @@ import java.util.Set;
 /**
  * Uses {@link SimpleDefinitionFinder} to determine if a function has been
  * aliased or exposed to .call() or .apply().
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 class SimpleFunctionAliasAnalysis {
   private Set<Node> aliasedFunctions;
-  
+
   private Set<Node> functionsExposedToCallOrApply;
-  
+
   /**
    * Returns true if the function is aliased.
-   * 
+   *
    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}
    * has been called.
    */
   public boolean isAliased(Node functionNode) {
     Preconditions.checkNotNull(aliasedFunctions);
     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));
-    
+
     return aliasedFunctions.contains(functionNode);
   }
-  
+
   /**
    * Returns true if the function ever exposed to .call() or .apply().
-   * 
+   *
    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}
    * has been called.
    */
   public boolean isExposedToCallOrApply(Node functionNode) {
     Preconditions.checkNotNull(functionsExposedToCallOrApply);
     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));
-    
+
     return functionsExposedToCallOrApply.contains(functionNode);
   }
-  
+
   /**
    * Uses the provided {@link SimpleDefinitionFinder} to determine
    * which functions are aliased or exposed to .call() or .apply().
    */
   public void analyze(SimpleDefinitionFinder finder) {
     Preconditions.checkState(aliasedFunctions == null);
-    
+
     aliasedFunctions = Sets.newHashSet();
     functionsExposedToCallOrApply = Sets.newHashSet();
-    
+
     for (DefinitionSite definitionSite : finder.getDefinitionSites()) {
       Definition definition = definitionSite.definition;
-      
+
       if (!definition.isExtern()) {
         Node rValue = definition.getRValue();
-        
+
         if (rValue != null && NodeUtil.isFunction(rValue)) {
           // rValue is a Token.FUNCTION from a definition
-          
+
           for (UseSite useSite : finder.getUseSites(definition)) {
             updateFunctionForUse(rValue, useSite.node);
-          }          
-        }     
+          }
+        }
       }
-    }   
+    }
   }
-  
+
   /**
    * Updates alias and exposure information based a site where the function is
    * used.
-   * 
+   *
    * Note: this method may be called multiple times per Function, each time
    * with a different useNode.
    */
   private void updateFunctionForUse(Node function, Node useNode) {
     Node useParent = useNode.getParent();
     int parentType = useParent.getType();
-    
+
     if ((parentType == Token.CALL || parentType == Token.NEW)
         && useParent.getFirstChild() == useNode) {
       // Regular call sites don't count as aliases
     } else if (NodeUtil.isGet(useParent)) {
       // GET{PROP,ELEM} don't count as aliases
       // but we have to check for using them in .call and .apply.
-      
+
       if (NodeUtil.isGetProp(useParent)) {
         Node gramps = useParent.getParent();
         if (NodeUtil.isFunctionObjectApply(gramps) ||
diff --git a/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java b/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java
index e9a878b4..1f31bec1 100644
--- a/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java
+++ b/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java
@@ -17,9 +17,9 @@ package com.google.javascript.jscomp;
 
 /**
  * Interface indicating a CompilerPass is specialization aware.
- * 
+ *
  * See {@link SpecializeModule} for details of module specialization.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  *
  */
diff --git a/src/com/google/javascript/jscomp/Tracer.java b/src/com/google/javascript/jscomp/Tracer.java
index 0f69695f..7559850a 100644
--- a/src/com/google/javascript/jscomp/Tracer.java
+++ b/src/com/google/javascript/jscomp/Tracer.java
@@ -121,23 +121,6 @@ import javax.annotation.Nullable;
  * several useful statistics such as cpu time, wait time, and memory usage.
  * If you add your own tracing statistics, the output is not quite as pretty,
  * but includes additional useful information.
- * <pre>
- *    31.980 Start        [LockManager] Waiting for user lock
- *   9 31.989 Done    9 ms    0ms cpu;  5944bytes;  [LockManager] Waiting for user lock
- *   0 31.989 Start        [CssClientImpl] ThreadGet (1 thread)
- *   5 31.994 Done    5 ms    0ms cpu;  2832bytes;  [CssClientImpl] ThreadGet (1 thread)
- *   0 31.994 Start        [MessageSorter] sort
- *   0 31.994 Done    0 ms    0ms cpu;   600bytes;  [MessageSorter] sort
- *   0 31.994 Start        [ConversationView] getMessageSummaries
- *   0 31.994 Start        [ConversationView] creating message summary 0
- *   1 31.995 Done    1 ms    0ms cpu;  5800bytes;  [ConversationView] creating message summary 0
- *   0 31.995 Start        [ConversationView] creating message summary 1
- *   0 31.995 Done    0 ms    0ms cpu;  5464bytes;  [ConversationView] creating message summary 1
- *   . . .
- * TOTAL NameDetector 3 (0 ms; 0 ms cpu;  784 bytes)
- * TOTAL Format 4 (1 ms; 0 ms cpu; 7344 bytes)
- * TOTAL ConversationView 5 (4 ms; 0 ms cpu; 55456 bytes)
- </pre>
 
  * <p>If a Trace is given a type (the first argument to the constructor) and
  * multiple Traces are done on that type then a "TOTAL line will be
@@ -186,8 +169,9 @@ final class Tracer {
    */
   private static volatile boolean defaultPrettyPrint;
 
-  /* This list is guaranteed to only increase in length.  It contains a list of additional
-   * statistics that the user wants to keep track of.
+  /* This list is guaranteed to only increase in length.  It contains
+   * a list of additional statistics that the user wants to keep track
+   * of.
    */
   private static List<TracingStatistic> extraTracingStatistics =
       new CopyOnWriteArrayList<TracingStatistic>();
@@ -390,7 +374,8 @@ final class Tracer {
     if (tracingStatistic.enable()) {
       // No synchronization needed, since this is a copy-on-write array.
       extraTracingStatistics.add(tracingStatistic);
-      // 99.9% of the time, this will be O(1) and return extraTracingStatistics.length - 1
+      // 99.9% of the time, this will be O(1) and return
+      // extraTracingStatistics.length - 1
       return extraTracingStatistics.lastIndexOf(tracingStatistic);
     } else {
       return -1;
@@ -398,8 +383,9 @@ final class Tracer {
   }
 
   /**
-   * For testing purposes only.  These removes all current tracers.  Severe errors can occur
-   * if there are any active tracers going on when this is called.
+   * For testing purposes only.  These removes all current tracers.
+   * Severe errors can occur if there are any active tracers going on
+   * when this is called.
    *
    * The test suite uses this to remove any tracers that it has added.
    */
@@ -428,8 +414,9 @@ final class Tracer {
 
     stopTimeMs = clock.currentTimeMillis();
     if (extraTracingValues != null) {
-      // We use extraTracingValues.length rather than extraTracingStatistics.size() because
-      // a new statistic may have been added
+      // We use extraTracingValues.length rather than
+      // extraTracingStatistics.size() because a new statistic may
+      // have been added
       for (int i = 0; i < extraTracingValues.length; i++) {
         long value = extraTracingStatistics.get(i).stop(startThread);
         extraTracingValues[i] = value - extraTracingValues[i];
@@ -680,7 +667,8 @@ final class Tracer {
       if (prevEventTime == -1) {
         appendSpaces(sb, digitsColWidth);
       } else {
-        sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth));
+        sb.append(longToPaddedString(
+            eventTime() - prevEventTime, digitsColWidth));
       }
 
       sb.append(' ');
@@ -835,10 +823,12 @@ final class Tracer {
         }
 
         if (stat.extraInfo != null && t.extraTracingValues != null) {
-          int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length);
+          int overlapLength =
+              Math.min(stat.extraInfo.length, t.extraTracingValues.length);
           for (int i = 0; i < overlapLength; i++) {
             stat.extraInfo[i] += t.extraTracingValues[i];
-            AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat();
+            AtomicTracerStatMap map =
+                extraTracingStatistics.get(i).getTracingStat();
             if (map != null) {
               map.incrementBy(t.type, t.extraTracingValues[i]);
             }
@@ -958,7 +948,8 @@ final class Tracer {
   }
 
   /** Holds the ThreadTrace for each thread.  */
-  private static ThreadLocal<ThreadTrace> traces = new ThreadLocal<ThreadTrace>();
+  private static ThreadLocal<ThreadTrace> traces =
+      new ThreadLocal<ThreadTrace>();
 
   /**
    * Get the ThreadTrace for the current thread, creating one if necessary.
@@ -979,36 +970,42 @@ final class Tracer {
   }
 
   /**
-   * A TracingStatistic allows the program to add additional optional statistics to the trace
-   * output.
+   * A TracingStatistic allows the program to add additional optional
+   * statistics to the trace output.
    *
-   * The class {@link com.google.monitoring.tracing.TracingStatistics} contains several
-   * useful tracing statistics
+   * The class {@link com.google.monitoring.tracing.TracingStatistics}
+   * contains several useful tracing statistics
    *
    */
   static interface TracingStatistic {
     /**
-     * This method is called at the start of the trace.  It should return a numeric result
-     * indicating the amount of the specific resource in use before the call started
+     * This method is called at the start of the trace.  It should
+     * return a numeric result indicating the amount of the specific
+     * resource in use before the call started
      * @param thread  The current thread
-     * @return   A numeric value indicating the amount of the resource already used.
+     * @return A numeric value indicating the amount of the resource
+     * already used.
      */
     long start(Thread thread);
 
     /**
-     * This method is called at the end of the trace.  It should return a numeric result
-     * indicating the amount of the specific resource in use after the call ends. The actual
-     * reported result will be the result end() - start()
+     * This method is called at the end of the trace.  It should
+     * return a numeric result indicating the amount of the specific
+     * resource in use after the call ends. The actual reported result
+     * will be the result end() - start()
      * @param thread  The current thread
-     * @return   A numeric value indicating the amount of the resource currently used.
+     * @return A numeric value indicating the amount of the resource
+     * currently used.
      */
     long stop(Thread thread);
 
     /**
-     * Called when this tracing statistic is first enabled.  A return value of True indicates that
-     * this statistic can successfully run in the current JVM.
+     * Called when this tracing statistic is first enabled.  A return
+     * value of True indicates that this statistic can successfully
+     * run in the current JVM.
      *
-     * @return  An indication of whether this statistic can be implemented in the current JVM.
+     * @return An indication of whether this statistic can be
+     * implemented in the current JVM.
      */
     boolean enable();
 
@@ -1018,7 +1015,8 @@ final class Tracer {
      */
     AtomicTracerStatMap getTracingStat();
 
-    /** A string that should be appended to the numeric output indicating what this is.
+    /** A string that should be appended to the numeric output
+     * indicating what this is.
      *
      * @return  A string indicating the units of this statistic and what it is.
      */
@@ -1031,7 +1029,8 @@ final class Tracer {
    *
    */
   static final class AtomicTracerStatMap {
-    private ConcurrentMap<String, Long> map = new ConcurrentHashMap<String, Long>();
+    private ConcurrentMap<String, Long> map =
+        new ConcurrentHashMap<String, Long>();
 
     /**
      * Atomically increment the specified field by the specified amount.
@@ -1039,7 +1038,8 @@ final class Tracer {
      * @param key      the name of the field
      * @param delta    the amount by which to increment the field
      */
-    // Nullness checker is not powerful enough to prove null-safety of this method
+    // Nullness checker is not powerful enough to prove null-safety of
+    // this method
     @SuppressWarnings("nullness")
         void incrementBy(String key, long delta) {
       // We use a compareAndSet strategy to update the map, which is much
@@ -1054,7 +1054,8 @@ final class Tracer {
           // The slot was still empty when we set it
           return;
         } else {
-          // Someone filled in the slot behind our back.  oldValue has its current value
+          // Someone filled in the slot behind our back.  oldValue has
+          // its current value
         }
       }
       while (true) {
diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
index e6d4320a..acc43880 100644
--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java
@@ -206,7 +206,8 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
         return;
 
       case Token.BLOCK:
-        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs
+        // BLOCKs are used in several ways including wrapping CATCH
+        // blocks in TRYs
         if (parent.getType() == Token.TRY) {
           if (NodeUtil.isTryCatchNodeContainer(n)) {
             return;
diff --git a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java
index 83caf941..4562983c 100644
--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java
+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java
@@ -29,60 +29,60 @@ import java.util.Map;
  * An analysis pass that determines the visibility of variables -- that is,
  * whether a variable is truly local, a local captured by an inner scope, a
  * parameter, or a global variable.
- * 
+ *
  * SideEffectsAnalysis uses this class to partition a potentially infinite
  * number of concrete storage locations into a (small) finite number of
  * abstract storage locations based on a variable's storage visibility.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 class VariableVisibilityAnalysis implements CompilerPass {
 
   enum VariableVisibility {
-    
+
     /** Local variable, not captured by closure */
     LOCAL,
-    
+
     /** Local variable captured by a closure */
     CAPTURED_LOCAL,
-    
-    /** 
+
+    /**
      * Formal parameter declaration variable
-     * 
+     *
      * Parameters are different than local variables because they can be
      * aliased by elements of the arguments object.
      */
     PARAMETER,
-    
+
     /** A global variable */
     GLOBAL
   }
-  
+
   private AbstractCompiler compiler;
-  
+
   /**
    * Maps the declaring name node for a variable to that variable's
    * visibility.
    */
   private Map<Node, VariableVisibility> visibilityByDeclaringNameNode;
-  
+
   public VariableVisibilityAnalysis(AbstractCompiler compiler) {
     this.compiler = compiler;
-   
+
     visibilityByDeclaringNameNode = Maps.newHashMap();
   }
-  
+
   /**
    * Returns the visibility of of a variable, given that variable's declaring
    * name node.
-   * 
+   *
    * The name node's parent must be one of:
    * <pre>
    *    Token.VAR (for a variable declaration)
    *    Token.FUNCTION (for a function declaration)
    *    Token.LP (for a function formal parameter)
-   * </pre> 
-   * 
+   * </pre>
+   *
    * The returned visibility will be one of:
    * <pre>
    *    LOCAL_VARIABLE : the variable is a local variable used only in its
@@ -91,44 +91,44 @@ class VariableVisibilityAnalysis implements CompilerPass {
    *        closure
    *     PARAMETER_VARIABLE : the variable is a formal parameter
    *     GLOBAL_VARIABLE : the variable is declared in the global scope
-   *  </pre>  
-   *    
+   *  </pre>
+   *
    * @param declaringNameNode The name node for a declaration.
    */
   public VariableVisibility getVariableVisibility(Node declaringNameNode) {
     Node parent = declaringNameNode.getParent();
-    
+
     Preconditions.checkArgument(NodeUtil.isVar(parent)
         || NodeUtil.isFunction(parent)
         || parent.getType() == Token.LP);
-    
+
     return visibilityByDeclaringNameNode.get(declaringNameNode);
   }
- 
+
   /**
    * Determines the visibility class for each variable in root.
    */
   @Override
   public void process(Node externs, Node root) {
-    ReferenceCollectingCallback callback = 
-      new ReferenceCollectingCallback(compiler, 
+    ReferenceCollectingCallback callback =
+      new ReferenceCollectingCallback(compiler,
           ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);
-    
+
     NodeTraversal.traverse(compiler, root, callback);
-    
+
     for (Var variable : callback.getReferencedVariables()) {
       ReferenceCollection referenceCollection =
           callback.getReferenceCollection(variable);
-      
+
       VariableVisibility visibility;
-      
+
       if (variableIsParameter(variable)) {
-        visibility = VariableVisibility.PARAMETER;     
+        visibility = VariableVisibility.PARAMETER;
       } else if (variable.isLocal()) {
         if (referenceCollection.isEscaped()) {
-          visibility = VariableVisibility.CAPTURED_LOCAL;        
+          visibility = VariableVisibility.CAPTURED_LOCAL;
         } else {
-          visibility = VariableVisibility.LOCAL;          
+          visibility = VariableVisibility.LOCAL;
         }
       } else if (variable.isGlobal()) {
         visibility = VariableVisibility.GLOBAL;
@@ -136,17 +136,17 @@ class VariableVisibilityAnalysis implements CompilerPass {
         throw new IllegalStateException("Un-handled variable visibility for " +
             variable);
       }
-      
+
       visibilityByDeclaringNameNode.put(variable.getNameNode(), visibility);
-    }   
+    }
   }
-  
+
   /**
    * Returns true if the variable is a formal parameter.
    */
   private static boolean variableIsParameter(Var variable) {
     Node variableParent = variable.getParentNode();
-    
+
     return variableParent != null && variableParent.getType() == Token.LP;
   }
 }
diff --git a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java
index 86972467..2a013d28 100644
--- a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java
+++ b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java
@@ -29,23 +29,24 @@ import java.util.regex.Pattern;
 
 /**
  * A parser that can extract dependency information from a .js file.
- * 
+ *
  * @author agrieve@google.com (Andrew Grieve)
  * @author ielashi@google.com (Islam El-Ashi)
  */
 public class JsFunctionParser extends JsFileLineParser {
-  
+
   public static class SymbolInfo {
     public final String functionName;
     public final String symbol;
-    
+
     private SymbolInfo(String functionName, String symbol) {
       this.functionName = functionName;
       this.symbol = symbol;
     }
   }
 
-  private static Logger logger = Logger.getLogger(JsFunctionParser.class.getName());
+  private static Logger logger =
+      Logger.getLogger(JsFunctionParser.class.getName());
 
   /** Pattern for matching functions. */
   private Pattern pattern;
@@ -55,7 +56,7 @@ public class JsFunctionParser extends JsFileLineParser {
 
   /** Symbols parsed. */
   private Collection<SymbolInfo> symbols;
-  
+
   /** Functions to parse */
   private Collection<String> functionsToParse;
 
@@ -65,7 +66,8 @@ public class JsFunctionParser extends JsFileLineParser {
    * @param functions Functions to parse.
    * @param errorManager Handles parse errors.
    */
-  public JsFunctionParser(Collection<String> functions, ErrorManager errorManager) {
+  public JsFunctionParser(
+      Collection<String> functions, ErrorManager errorManager) {
     super(errorManager);
     functionsToParse = functions;
     pattern = getPattern(functions);
@@ -74,24 +76,24 @@ public class JsFunctionParser extends JsFileLineParser {
 
   /**
    * Constructs a pattern to extract the arguments of the given functions.
-   * 
+   *
    * @param functions Functions to parse.
    * @return A pattern to extract {@code functions}' arguments.
    */
   private Pattern getPattern(Collection<String> functions) {
     StringBuilder sb = new StringBuilder("(?:^|;)\\s*(");
-    
+
     for (String function : functions) {
       sb.append(Pattern.quote(function) + "|");
     }
-    
+
     // remove last '|'
     sb.deleteCharAt(sb.length() - 1);
     sb.append(")\\s*\\((.*?)\\)");
-    
+
     return Pattern.compile(sb.toString());
   }
-  
+
   /**
    * Parses the given file and returns the dependency information that it
    * contained.
@@ -101,11 +103,13 @@ public class JsFunctionParser extends JsFileLineParser {
    * @return A collection containing all symbols found in the
    *     file.
    */
-  public Collection<SymbolInfo> parseFile(String filePath, String fileContents) {
+  public Collection<SymbolInfo> parseFile(
+      String filePath, String fileContents) {
     return parseReader(filePath, new StringReader(fileContents));
   }
 
-  private Collection<SymbolInfo> parseReader(String filePath, Reader fileContents) {
+  private Collection<SymbolInfo> parseReader(
+      String filePath, Reader fileContents) {
     symbols = Lists.newArrayList();
 
     logger.fine("Parsing Source: " + filePath);
@@ -113,7 +117,7 @@ public class JsFunctionParser extends JsFileLineParser {
 
     return symbols;
   }
-  
+
   /**
    * Parses a line of javascript, extracting dependency information.
    */
@@ -130,13 +134,13 @@ public class JsFunctionParser extends JsFileLineParser {
         break;
       }
     }
-    
+
     if (parseLine) {
       matcher.reset(line);
       while (matcher.find()) {
         hasFunctions = true;
         String functionName = matcher.group(1);
-        String arg = parseJsString(matcher.group(2)); // Parse the param.  
+        String arg = parseJsString(matcher.group(2)); // Parse the param.
         symbols.add(new SymbolInfo(functionName, arg));
       }
     }
diff --git a/src/com/google/javascript/rhino/Decompiler.java b/src/com/google/javascript/rhino/Decompiler.java
index e5309b63..fe038a34 100644
--- a/src/com/google/javascript/rhino/Decompiler.java
+++ b/src/com/google/javascript/rhino/Decompiler.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
@@ -747,7 +747,7 @@ public class Decompiler
             case Token.CONST:
                 result.append("const ");
                 break;
-            
+
             case Token.NOT:
                 result.append('!');
                 break;
diff --git a/src/com/google/javascript/rhino/FunctionNode.java b/src/com/google/javascript/rhino/FunctionNode.java
index f81f9237..baa22183 100644
--- a/src/com/google/javascript/rhino/FunctionNode.java
+++ b/src/com/google/javascript/rhino/FunctionNode.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
diff --git a/src/com/google/javascript/rhino/JSDocInfoBuilder.java b/src/com/google/javascript/rhino/JSDocInfoBuilder.java
index b452bc85..b3d50dab 100644
--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java
+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java
@@ -159,8 +159,8 @@ final public class JSDocInfoBuilder {
   /**
    * Adds a textual block to the current marker.
    */
-  public void markText(String text, int startLineno, int startCharno, int endLineno,
-                int endCharno) {
+  public void markText(String text, int startLineno, int startCharno,
+      int endLineno, int endCharno) {
     if (currentMarker != null) {
       currentMarker.description = new JSDocInfo.StringPosition();
       currentMarker.description.setItem(text);
@@ -172,8 +172,8 @@ final public class JSDocInfoBuilder {
   /**
    * Adds a type declaration to the current marker.
    */
-  public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,
-                    boolean hasLC) {
+  public void markTypeNode(Node typeNode, int lineno, int startCharno,
+      int endCharno, boolean hasLC) {
     if (currentMarker != null) {
       currentMarker.type = new JSDocInfo.TypePosition();
       currentMarker.type.setItem(typeNode);
@@ -243,7 +243,8 @@ final public class JSDocInfoBuilder {
    * @return {@code true} if the parameter's description was recorded and
    *     {@code false} if a parameter with the same name was already defined
    */
-  public boolean recordParameterDescription(String parameterName, String description) {
+  public boolean recordParameterDescription(
+      String parameterName, String description) {
     if (currentInfo.documentParam(parameterName, description)) {
       populated = true;
       return true;
@@ -285,7 +286,8 @@ final public class JSDocInfoBuilder {
    * @return {@code true} if the type's description was recorded and
    *     {@code false} if a description with the same type was already defined
    */
-  public boolean recordThrowDescription(JSTypeExpression type, String description) {
+  public boolean recordThrowDescription(
+      JSTypeExpression type, String description) {
     if (currentInfo.documentThrows(type, description)) {
       populated = true;
       return true;
diff --git a/src/com/google/javascript/rhino/Kit.java b/src/com/google/javascript/rhino/Kit.java
index 19c6fd4e..5570d379 100644
--- a/src/com/google/javascript/rhino/Kit.java
+++ b/src/com/google/javascript/rhino/Kit.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
diff --git a/src/com/google/javascript/rhino/ObjArray.java b/src/com/google/javascript/rhino/ObjArray.java
index 4cd30fda..b8964648 100644
--- a/src/com/google/javascript/rhino/ObjArray.java
+++ b/src/com/google/javascript/rhino/ObjArray.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
@@ -44,9 +44,10 @@ import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 
 /**
-Implementation of resizable array with focus on minimizing memory usage by storing few initial array elements in object fields. Can also be used as a stack.
-*/
-
+ * Implementation of resizable array with focus on minimizing memory
+ * usage by storing few initial array elements in object fields. Can also
+ * be used as a stack.
+ */
 public class ObjArray implements Serializable
 {
     static final long serialVersionUID = 4174889037736658296L;
diff --git a/src/com/google/javascript/rhino/Parser.java b/src/com/google/javascript/rhino/Parser.java
index dcd046bd..95b720ff 100644
--- a/src/com/google/javascript/rhino/Parser.java
+++ b/src/com/google/javascript/rhino/Parser.java
@@ -1040,8 +1040,9 @@ public class Parser
                     decompiler.addEOL(Token.LC);
 
                     nf.addChildToBack(catchblocks,
-                        nf.createCatch(varName, nameLineno, nameCharno, catchCond,
-                             statements(), catchLineno, catchCharno));
+                        nf.createCatch(
+                            varName, nameLineno, nameCharno, catchCond,
+                            statements(), catchLineno, catchCharno));
 
                     mustMatchToken(Token.RC, "msg.no.brace.after.body");
                     decompiler.addEOL(Token.RC);
@@ -1514,7 +1515,8 @@ public class Parser
             int lineno = ts.getLineno();
             int charno = ts.getCharno();
             decompiler.addToken(Token.BITXOR);
-            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit), lineno,
+            pn = nf.createBinary(
+                Token.BITXOR, pn, bitAndExpr(inForInit), lineno,
                 charno);
         }
         return pn;
@@ -1880,9 +1882,11 @@ public class Parser
              * do we claim to support?
              */
 
-            /* Experimental syntax:  allow an object literal to follow a new expression,
-             * which will mean a kind of anonymous class built with the JavaAdapter.
-             * the object literal will be passed as an additional argument to the constructor.
+            /* Experimental syntax: allow an object literal to follow
+             * a new expression, which will mean a kind of anonymous
+             * class built with the JavaAdapter.  the object literal
+             * will be passed as an additional argument to the
+             * constructor.
              */
             tt = peekToken();
             if (tt == Token.LC) {
@@ -1941,7 +1945,8 @@ public class Parser
                             // Dot's position
                             lineno, charno,
                             // Name's position
-                            ts.getLineno(), ts.getCharno());                        break;
+                            ts.getLineno(), ts.getCharno());
+                        break;
 
                       // handles: *, *::name, *::*, *::[expr]
                       case Token.MUL:
diff --git a/src/com/google/javascript/rhino/ScriptOrFnNode.java b/src/com/google/javascript/rhino/ScriptOrFnNode.java
index 89391227..b242bbb6 100644
--- a/src/com/google/javascript/rhino/ScriptOrFnNode.java
+++ b/src/com/google/javascript/rhino/ScriptOrFnNode.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java
index b215cfb5..23e31497 100644
--- a/src/com/google/javascript/rhino/TokenStream.java
+++ b/src/com/google/javascript/rhino/TokenStream.java
@@ -193,24 +193,43 @@ public class TokenStream
                 else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }
                 break L;
             case 3: switch (s.charAt(0)) {
-                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;
-                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;
-                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;
-                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;
-                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;
+                case 'f':
+                  if (s.charAt(2)=='r' && s.charAt(1)=='o') {
+                    id=Id_for; break L0;
+                  } break L;
+                case 'i':
+                  if (s.charAt(2)=='t' && s.charAt(1)=='n') {
+                    id=Id_int; break L0;
+                  } break L;
+                case 'n':
+                  if (s.charAt(2)=='w' && s.charAt(1)=='e') {
+                    id=Id_new; break L0;
+                  } break L;
+                case 't':
+                  if (s.charAt(2)=='y' && s.charAt(1)=='r') {
+                    id=Id_try; break L0;
+                  } break L;
+                case 'v':
+                  if (s.charAt(2)=='r' && s.charAt(1)=='a') {
+                    id=Id_var; break L0;
+                  } break L;
                 } break L;
             case 4: switch (s.charAt(0)) {
                 case 'b': X="byte";id=Id_byte; break L;
                 case 'c': c=s.charAt(3);
                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {
                             id=Id_case; break L0;} }
-                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {
-                            id=Id_char; break L0;} }
+                    else if (c=='r') {
+                      if (s.charAt(2)=='a' && s.charAt(1)=='h') {
+                        id=Id_char; break L0;
+                      }
+                    }
                     break L;
                 case 'e': c=s.charAt(3);
                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {
                             id=Id_else; break L0;} }
-                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {
+                    else if (c=='m') {
+                      if (s.charAt(2)=='u' && s.charAt(1)=='n') {
                             id=Id_enum; break L0;} }
                     break L;
                 case 'g': X="goto";id=Id_goto; break L;
@@ -219,7 +238,8 @@ public class TokenStream
                 case 't': c=s.charAt(3);
                     if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {
                             id=Id_true; break L0;} }
-                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {
+                    else if (c=='s') {
+                      if (s.charAt(2)=='i' && s.charAt(1)=='h') {
                             id=Id_this; break L0;} }
                     break L;
                 case 'v': X="void";id=Id_void; break L;
diff --git a/src/com/google/javascript/rhino/jstype/SimpleSlot.java b/src/com/google/javascript/rhino/jstype/SimpleSlot.java
index 50567536..d2dd7265 100644
--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java
+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java
@@ -1,4 +1,4 @@
-/* 
+/*
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0
@@ -36,7 +36,7 @@
  * file under either the MPL or the GPL.
  *
  * ***** END LICENSE BLOCK ***** */
- 
+
 package com.google.javascript.rhino.jstype;
 
 /**
diff --git a/test/com/google/javascript/jscomp/CallGraphTest.java b/test/com/google/javascript/jscomp/CallGraphTest.java
index 238c4eae..2f45952d 100644
--- a/test/com/google/javascript/jscomp/CallGraphTest.java
+++ b/test/com/google/javascript/jscomp/CallGraphTest.java
@@ -30,122 +30,122 @@ import java.util.Set;
 
 /**
  * Tests for CallGraph.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 public class CallGraphTest extends CompilerTestCase {
 
   private CallGraph currentProcessor;
-  
+
   private boolean createForwardCallGraph;
   private boolean createBackwardCallGraph;
-  
+
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     // We store the new callgraph so it can be tested later
     currentProcessor = new CallGraph(compiler, createForwardCallGraph,
         createBackwardCallGraph);
-    
+
     return currentProcessor;
   }
-  
-  static final String SHARED_EXTERNS = 
+
+  static final String SHARED_EXTERNS =
       "var ExternalFunction = function(a) {}\n" +
       "var externalnamespace = {}\n" +
       "externalnamespace.prop = function(){};\n";
-  
+
   public void testGetFunctionForAstNode() {
     String source = "function A() {};\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     Node functionANode = functionA.getAstNode();
-    
+
     assertEquals(functionA, callgraph.getFunctionForAstNode(functionANode));
   }
-  
-  public void testGetAllFunctions() {  
-    String source = 
+
+  public void testGetAllFunctions() {
+    String source =
         "function A() {}\n" +
         "var B = function() {\n" +
-        "(function C(){A()})()\n" + 
+        "(function C(){A()})()\n" +
         "};\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     Collection<CallGraph.Function> functions = callgraph.getAllFunctions();
-    
+
     // 3 Functions, plus one for the main function
     assertEquals(4, functions.size());
-    
-    CallGraph.Function functionA = 
+
+    CallGraph.Function functionA =
         callgraph.getUniqueFunctionWithName("A");
     CallGraph.Function functionB =
         callgraph.getUniqueFunctionWithName("B");
     CallGraph.Function functionC =
         callgraph.getUniqueFunctionWithName("C");
-    
+
     assertEquals("A", NodeUtil.getFunctionName(functionA.getAstNode()));
     assertEquals("B", NodeUtil.getFunctionName(functionB.getAstNode()));
     assertEquals("C", NodeUtil.getFunctionName(functionC.getAstNode()));
   }
-  
+
   public void testGetAllFunctionsContainsNormalFunction() {
     String source = "function A(){}\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-        
+
     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();
-    
+
     // 2 functions: one for A() and one for the main function
     assertEquals(2, allFunctions.size());
-    
+
    assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName("A")));
    assertTrue(allFunctions.contains(callgraph.getMainFunction()));
   }
-  
+
   public void testGetAllFunctionsContainsVarAssignedLiteralFunction() {
     String source = "var A = function(){}\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-        
+
     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();
-    
+
     // 2 functions: one for A() and one for the global function
     assertEquals(2, allFunctions.size());
 
     Function functionA = callgraph.getUniqueFunctionWithName("A");
-    assertTrue(allFunctions.contains(functionA));  
+    assertTrue(allFunctions.contains(functionA));
     assertTrue(allFunctions.contains(callgraph.getMainFunction()));
   }
 
   public void testGetAllFunctionsContainsNamespaceAssignedLiteralFunction() {
-    String source = 
+    String source =
         "var namespace = {};\n" +
         "namespace.A = function(){};\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-        
+
     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();
-    
+
     // 2 functions: one for namespace.A() and one for the global function
     assertEquals(2, allFunctions.size());
 
     assertTrue(allFunctions.contains(
-        callgraph.getUniqueFunctionWithName("namespace.A")));  
+        callgraph.getUniqueFunctionWithName("namespace.A")));
     assertTrue(allFunctions.contains(callgraph.getMainFunction()));
   }
- 
+
   public void testGetAllFunctionsContainsLocalFunction() {
-    String source = 
+    String source =
         "var A = function(){var B = function(){}};\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-        
+
     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();
-    
+
     // 3 functions: one for A, B, and global function
     assertEquals(3, allFunctions.size());
 
@@ -155,13 +155,13 @@ public class CallGraphTest extends CompilerTestCase {
   }
 
   public void testGetAllFunctionsContainsAnonymousFunction() {
-    String source = 
+    String source =
         "var A = function(){(function(){})();};\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-        
+
     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();
-    
+
     // 3 functions: A, anonymous, and global function
     assertEquals(3, allFunctions.size());
 
@@ -170,190 +170,190 @@ public class CallGraphTest extends CompilerTestCase {
         allFunctions.contains(callgraph.getUniqueFunctionWithName(null)));
     assertTrue(allFunctions.contains(callgraph.getMainFunction()));
   }
-  
+
   public void testGetCallsiteForAstNode() {
     String source =
         "function A() {B()};\n" +
         "function B(){};\n";
-    
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");   
+
+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
     CallGraph.Callsite callToB =
         functionA.getCallsitesInFunction().iterator().next();
-    
+
     Node callsiteNode = callToB.getAstNode();
-    
+
     assertEquals(callToB, callgraph.getCallsiteForAstNode(callsiteNode));
   }
-    
-  public void testFunctionGetCallsites() {  
-    String source = 
+
+  public void testFunctionGetCallsites() {
+    String source =
         "function A() {var x; x()}\n" +
         "var B = function() {\n" +
-        "(function C(){A()})()\n" + 
+        "(function C(){A()})()\n" +
         "};\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-    
-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
+
+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
     Collection<CallGraph.Callsite> callsitesInA =
         functionA.getCallsitesInFunction();
-    
+
     assertEquals(1, callsitesInA.size());
-    
+
     CallGraph.Callsite firstCallsiteInA =
         callsitesInA.iterator().next();
-    
+
     Node aTargetExpression = firstCallsiteInA.getAstNode().getFirstChild();
     assertEquals(Token.NAME, aTargetExpression.getType());
     assertEquals("x", aTargetExpression.getString());
-       
+
     CallGraph.Function functionB =
         callgraph.getUniqueFunctionWithName("B");
-    
+
     Collection<CallGraph.Callsite> callsitesInB =
         functionB.getCallsitesInFunction();
-    
+
     assertEquals(1, callsitesInB.size());
-    
+
     CallGraph.Callsite firstCallsiteInB =
       callsitesInB.iterator().next();
-    
+
     Node bTargetExpression = firstCallsiteInB.getAstNode().getFirstChild();
     assertEquals(Token.FUNCTION, bTargetExpression.getType());
     assertEquals("C", NodeUtil.getFunctionName(bTargetExpression));
-    
+
     CallGraph.Function functionC =
         callgraph.getUniqueFunctionWithName("C");
-    
+
     Collection<CallGraph.Callsite> callsitesInC =
         functionC.getCallsitesInFunction();
     assertEquals(1, callsitesInC.size());
-    
+
     CallGraph.Callsite firstCallsiteInC =
       callsitesInC.iterator().next();
-    
+
     Node cTargetExpression = firstCallsiteInC.getAstNode().getFirstChild();
     assertEquals(Token.NAME, aTargetExpression.getType());
     assertEquals("A", cTargetExpression.getString());
   }
-  
+
   public void testFindNewInFunction() {
     String source = "function A() {var x; new x(1,2)}\n;";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     CallGraph.Function functionA =
         callgraph.getUniqueFunctionWithName("A");
     Collection<CallGraph.Callsite> callsitesInA =
         functionA.getCallsitesInFunction();
     assertEquals(1, callsitesInA.size());
-    
+
     Node callsiteInA = callsitesInA.iterator().next().getAstNode();
     assertEquals(Token.NEW, callsiteInA.getType());
-    
+
     Node aTargetExpression = callsiteInA.getFirstChild();
     assertEquals(Token.NAME, aTargetExpression.getType());
     assertEquals("x", aTargetExpression.getString());
   }
-  
+
   public void testFindCallsiteTargetGlobalName() {
-    String source = 
+    String source =
       "function A() {}\n" +
       "function B() {}\n" +
       "function C() {A()}\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     CallGraph.Function functionC =
         callgraph.getUniqueFunctionWithName("C");
     assertNotNull(functionC);
-    
+
     CallGraph.Callsite callsiteInC =
         functionC.getCallsitesInFunction().iterator().next();
     assertNotNull(callsiteInC);
-    
+
     Collection<CallGraph.Function> targetsOfCallsiteInC =
         callsiteInC.getPossibleTargets();
-    
+
     assertNotNull(targetsOfCallsiteInC);
-    assertEquals(1, targetsOfCallsiteInC.size());    
+    assertEquals(1, targetsOfCallsiteInC.size());
   }
-  
+
   public void testFindCallsiteTargetAliasedGlobalProperty() {
-    String source = 
+    String source =
         "var namespace = {};\n" +
         "namespace.A = function() {};\n" +
         "function C() {namespace.A()}\n";
-    
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     CallGraph.Function functionC =
         callgraph.getUniqueFunctionWithName("C");
     assertNotNull(functionC);
-    
+
     CallGraph.Callsite callsiteInC =
         functionC.getCallsitesInFunction().iterator().next();
-    
+
     assertNotNull(callsiteInC);
-    
+
     Collection<CallGraph.Function> targetsOfCallsiteInC =
         callsiteInC.getPossibleTargets();
-    
+
     assertNotNull(targetsOfCallsiteInC);
-    assertEquals(1, targetsOfCallsiteInC.size());    
+    assertEquals(1, targetsOfCallsiteInC.size());
   }
-  
+
   public void testGetAllCallsitesContainsMultiple() {
-    String source = 
+    String source =
         "function A() {}\n" +
         "var B = function() {\n" +
-        "(function (){A()})()\n" + 
+        "(function (){A()})()\n" +
         "};\n" +
         "A();\n" +
         "B();\n";
-    
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();
-    
+
     assertEquals(4, allCallsites.size());
   }
-  
+
   public void testGetAllCallsitesContainsGlobalSite() {
     String source =
         "function A(){}\n" +
         "A();\n";
-    
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();
     assertEquals(1, allCallsites.size());
-    
+
     Node callsiteNode = allCallsites.iterator().next().getAstNode();
     assertEquals(Token.CALL, callsiteNode.getType());
-    assertEquals("A", callsiteNode.getFirstChild().getString()); 
+    assertEquals("A", callsiteNode.getFirstChild().getString());
   }
-  
+
   public void testGetAllCallsitesContainsLocalSite() {
     String source =
         "function A(){}\n" +
         "function B(){A();}\n";
-  
+
     CallGraph callgraph = compileAndRunBackward(source);
-  
+
     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();
     assertEquals(1, allCallsites.size());
-  
+
     Node callsiteNode = allCallsites.iterator().next().getAstNode();
     assertEquals(Token.CALL, callsiteNode.getType());
     assertEquals("A", callsiteNode.getFirstChild().getString());
   }
-  
+
   public void testGetAllCallsitesContainsLiteralSite() {
     String source = "function A(){(function(a){})();}\n";
-    
+
     CallGraph callgraph = compileAndRunBackward(source);
 
     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();
@@ -361,9 +361,9 @@ public class CallGraphTest extends CompilerTestCase {
 
     Node callsiteNode = allCallsites.iterator().next().getAstNode();
     assertEquals(Token.CALL, callsiteNode.getType());
-    assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());    
+    assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());
   }
-  
+
   public void testGetAllCallsitesContainsConstructorSite() {
     String source =
         "function A(){}\n" +
@@ -378,17 +378,17 @@ public class CallGraphTest extends CompilerTestCase {
     assertEquals(Token.NEW, callsiteNode.getType());
     assertEquals("A", callsiteNode.getFirstChild().getString());
   }
-  
+
   /**
    * Test getting a backward directed graph on a backward call graph
    * and propagating over it.
    */
-  public void testGetDirectedGraph_backwardOnBackward() { 
+  public void testGetDirectedGraph_backwardOnBackward() {
     // For this test we create a simple callback that when, applied until a
     // fixedpoint, computes whether a function is "poisoned" by an extern.
     // A function is poisoned if it calls an extern or if it calls another
     // poisoned function.
-    
+
     String source =
         "function A(){};\n" +
         "function B(){ExternalFunction(6); C(); D();}\n" +
@@ -396,18 +396,18 @@ public class CallGraphTest extends CompilerTestCase {
         "function D(){A();};\n" +
         "function E(){C()};\n" +
         "A();\n";
-        
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     final Set<Function> poisonedFunctions = Sets.newHashSet();
-    
+
     // Set up initial poisoned functions
     for (Callsite callsite : callgraph.getAllCallsites()) {
       if (callsite.hasExternTarget()) {
         poisonedFunctions.add(callsite.getContainingFunction());
       }
     }
-    
+
     // Propagate poison from callees to callers
     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =
         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {
@@ -415,41 +415,41 @@ public class CallGraphTest extends CompilerTestCase {
           public boolean traverseEdge(Function callee, Callsite callsite,
               Function caller) {
             boolean changed;
-            
+
             if (poisonedFunctions.contains(callee)) {
               changed = poisonedFunctions.add(caller); // Returns true if added
             } else {
               changed = false;
             }
-            
+
             return changed;
           }
     };
-    
+
     FixedPointGraphTraversal.newTraversal(edgeCallback)
-        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  
-    
+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());
+
     // We expect B, C, and E to poisoned.
     assertEquals(3, poisonedFunctions.size());
-    
+
     assertTrue(poisonedFunctions.contains(
         callgraph.getUniqueFunctionWithName("B")));
     assertTrue(poisonedFunctions.contains(
         callgraph.getUniqueFunctionWithName("C")));
     assertTrue(poisonedFunctions.contains(
-        callgraph.getUniqueFunctionWithName("E")));   
+        callgraph.getUniqueFunctionWithName("E")));
   }
-  
+
   /**
    * Test getting a backward directed graph on a forward call graph
    * and propagating over it.
    */
-  public void testGetDirectedGraph_backwardOnForward() { 
+  public void testGetDirectedGraph_backwardOnForward() {
     // For this test we create a simple callback that when, applied until a
     // fixedpoint, computes whether a function is "poisoned" by an extern.
     // A function is poisoned if it calls an extern or if it calls another
     // poisoned function.
-    
+
     String source =
         "function A(){};\n" +
         "function B(){ExternalFunction(6); C(); D();}\n" +
@@ -457,18 +457,18 @@ public class CallGraphTest extends CompilerTestCase {
         "function D(){A();};\n" +
         "function E(){C()};\n" +
         "A();\n";
-        
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     final Set<Function> poisonedFunctions = Sets.newHashSet();
-    
+
     // Set up initial poisoned functions
     for (Callsite callsite : callgraph.getAllCallsites()) {
       if (callsite.hasExternTarget()) {
         poisonedFunctions.add(callsite.getContainingFunction());
       }
     }
-    
+
     // Propagate poison from callees to callers
     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =
         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {
@@ -476,40 +476,40 @@ public class CallGraphTest extends CompilerTestCase {
           public boolean traverseEdge(Function callee, Callsite callsite,
               Function caller) {
             boolean changed;
-            
+
             if (poisonedFunctions.contains(callee)) {
               changed = poisonedFunctions.add(caller); // Returns true if added
             } else {
               changed = false;
             }
-            
+
             return changed;
           }
     };
-    
+
     FixedPointGraphTraversal.newTraversal(edgeCallback)
-        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  
-    
+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());
+
     // We expect B, C, and E to poisoned.
     assertEquals(3, poisonedFunctions.size());
-    
+
     assertTrue(poisonedFunctions.contains(
         callgraph.getUniqueFunctionWithName("B")));
     assertTrue(poisonedFunctions.contains(
         callgraph.getUniqueFunctionWithName("C")));
     assertTrue(poisonedFunctions.contains(
-        callgraph.getUniqueFunctionWithName("E")));   
+        callgraph.getUniqueFunctionWithName("E")));
   }
-  
+
   /**
    * Test getting a forward directed graph on a forward call graph
    * and propagating over it.
    */
-  public void testGetDirectedGraph_forwardOnForward() { 
+  public void testGetDirectedGraph_forwardOnForward() {
     // For this test we create a simple callback that when, applied until a
     // fixedpoint, computes whether a function is reachable from an initial
     // set of "root" nodes.
-    
+
     String source =
         "function A(){B()};\n" +
         "function B(){C();D()}\n" +
@@ -517,45 +517,45 @@ public class CallGraphTest extends CompilerTestCase {
         "function D(){};\n" +
         "function E(){C()};\n" +
         "function X(){Y()};\n" +
-        "function Y(){Z()};\n" + 
+        "function Y(){Z()};\n" +
         "function Z(){};" +
         "B();\n";
-        
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     final Set<Function> reachableFunctions = Sets.newHashSet();
-    
+
     // We assume the main function and X are our roots
     reachableFunctions.add(callgraph.getMainFunction());
     reachableFunctions.add(callgraph.getUniqueFunctionWithName("X"));
-    
+
     // Propagate reachability from callers to callees
-    
+
     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =
         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {
           @Override
           public boolean traverseEdge(Function caller, Callsite callsite,
               Function callee) {
             boolean changed;
-            
+
             if (reachableFunctions.contains(caller)) {
               changed = reachableFunctions.add(callee); // Returns true if added
             } else {
               changed = false;
             }
-            
+
             return changed;
           }
     };
-    
+
     FixedPointGraphTraversal.newTraversal(edgeCallback)
-        .computeFixedPoint(callgraph.getForwardDirectedGraph());  
-    
+        .computeFixedPoint(callgraph.getForwardDirectedGraph());
+
     // We expect B, C, D, X, Y, Z and the main function should be reachable.
     // A and E should not be reachable.
-    
+
     assertEquals(7, reachableFunctions.size());
-  
+
     assertTrue(reachableFunctions.contains(
         callgraph.getUniqueFunctionWithName("B")));
     assertTrue(reachableFunctions.contains(
@@ -570,22 +570,22 @@ public class CallGraphTest extends CompilerTestCase {
         callgraph.getUniqueFunctionWithName("Z")));
     assertTrue(reachableFunctions.contains(
         callgraph.getMainFunction()));
-    
+
     assertFalse(reachableFunctions.contains(
         callgraph.getUniqueFunctionWithName("A")));
     assertFalse(reachableFunctions.contains(
-        callgraph.getUniqueFunctionWithName("E"))); 
+        callgraph.getUniqueFunctionWithName("E")));
   }
-  
+
   /**
    * Test getting a backward directed graph on a forward call graph
    * and propagating over it.
    */
-  public void testGetDirectedGraph_forwardOnBackward() { 
+  public void testGetDirectedGraph_forwardOnBackward() {
     // For this test we create a simple callback that when, applied until a
     // fixedpoint, computes whether a function is reachable from an initial
     // set of "root" nodes.
-    
+
     String source =
         "function A(){B()};\n" +
         "function B(){C();D()}\n" +
@@ -593,45 +593,45 @@ public class CallGraphTest extends CompilerTestCase {
         "function D(){};\n" +
         "function E(){C()};\n" +
         "function X(){Y()};\n" +
-        "function Y(){Z()};\n" + 
+        "function Y(){Z()};\n" +
         "function Z(){};" +
         "B();\n";
-        
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     final Set<Function> reachableFunctions = Sets.newHashSet();
-    
+
     // We assume the main function and X are our roots
     reachableFunctions.add(callgraph.getMainFunction());
     reachableFunctions.add(callgraph.getUniqueFunctionWithName("X"));
-    
+
     // Propagate reachability from callers to callees
-    
+
     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =
         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {
           @Override
           public boolean traverseEdge(Function caller, Callsite callsite,
               Function callee) {
             boolean changed;
-            
+
             if (reachableFunctions.contains(caller)) {
               changed = reachableFunctions.add(callee); // Returns true if added
             } else {
               changed = false;
             }
-            
+
             return changed;
           }
     };
-    
+
     FixedPointGraphTraversal.newTraversal(edgeCallback)
-        .computeFixedPoint(callgraph.getForwardDirectedGraph());  
-    
+        .computeFixedPoint(callgraph.getForwardDirectedGraph());
+
     // We expect B, C, D, X, Y, Z and the main function should be reachable.
     // A and E should not be reachable.
-    
+
     assertEquals(7, reachableFunctions.size());
-  
+
     assertTrue(reachableFunctions.contains(
         callgraph.getUniqueFunctionWithName("B")));
     assertTrue(reachableFunctions.contains(
@@ -646,191 +646,191 @@ public class CallGraphTest extends CompilerTestCase {
         callgraph.getUniqueFunctionWithName("Z")));
     assertTrue(reachableFunctions.contains(
         callgraph.getMainFunction()));
-    
+
     assertFalse(reachableFunctions.contains(
         callgraph.getUniqueFunctionWithName("A")));
     assertFalse(reachableFunctions.contains(
-        callgraph.getUniqueFunctionWithName("E"))); 
+        callgraph.getUniqueFunctionWithName("E")));
   }
-  
+
   public void testFunctionIsMain() {
     String source =
         "function A(){};\n" +
         "A();\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
 
     CallGraph.Function mainFunction = callgraph.getMainFunction();
-    
+
     assertTrue(mainFunction.isMain());
     assertNotNull(mainFunction.getBodyNode());
     assertTrue(mainFunction.getBodyNode().getType() == Token.BLOCK);
-    
+
     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     assertFalse(functionA.isMain());
   }
-  
+
   public void testFunctionGetAstNode() {
     String source =
         "function A(){};\n" +
         "A();\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     CallGraph.Function mainFunction = callgraph.getMainFunction();
-    
+
     // Main function's AST node should be the global block
     assertTrue(mainFunction.getAstNode().getType() == Token.BLOCK);
-    
+
     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     // Regular function's AST node should be the function for A
     assertTrue(functionA.getAstNode().getType() == Token.FUNCTION);
     assertEquals("A", NodeUtil.getFunctionName(functionA.getAstNode()));
   }
-  
+
   public void testFunctionGetBodyNode() {
     String source =
         "function A(){};\n" +
         "A();\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     CallGraph.Function mainFunction = callgraph.getMainFunction();
-    
+
     // Main function's body node should its AST node
     assertEquals(mainFunction.getAstNode(), mainFunction.getBodyNode());
-    
+
     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     // Regular function's body node should be the block for A
     assertTrue(functionA.getBodyNode().getType() == Token.BLOCK);
     assertEquals(NodeUtil.getFunctionBody(functionA.getAstNode()),
         functionA.getBodyNode());
   }
- 
+
   public void testFunctionGetName() {
     String source =
         "function A(){};\n" +
         "A();\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     CallGraph.Function mainFunction = callgraph.getMainFunction();
-    
+
     // Main function's name should be CallGraph.MAIN_FUNCTION_NAME
     assertEquals(CallGraph.MAIN_FUNCTION_NAME, mainFunction.getName());
-    
+
     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     // Regular function's name should be its name
     assertEquals(NodeUtil.getFunctionName(functionA.getAstNode()),
         functionA.getName());
   }
-  
+
   public void testFunctionGetCallsitesInFunction() {
     String source =
         "function A(){};\n" +
         "function B(){A()};\n" +
         "A();\n" +
         "B();\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     // Main function calls A and B
     CallGraph.Function mainFunction = callgraph.getMainFunction();
     List<String> callsiteNamesInMain =
         getCallsiteTargetNames(mainFunction.getCallsitesInFunction());
-     
+
     assertEquals(2, callsiteNamesInMain.size());
-    assertTrue(callsiteNamesInMain.contains("A"));    
+    assertTrue(callsiteNamesInMain.contains("A"));
     assertTrue(callsiteNamesInMain.contains("B"));
-    
+
     // A calls no functions
-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
     assertEquals(0, functionA.getCallsitesInFunction().size());
-    
+
     // B calls A
     CallGraph.Function functionB = callgraph.getUniqueFunctionWithName("B");
     List<String> callsiteNamesInB =
         getCallsiteTargetNames(functionB.getCallsitesInFunction());
-    
+
     assertEquals(1, callsiteNamesInB.size());
     assertTrue(callsiteNamesInMain.contains("A"));
   }
-  
+
   public void testFunctionGetCallsitesInFunction_ignoreInnerFunction() {
     String source =
         "function A(){var B = function(){C();}};\n" +
         "function C(){};\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     // A calls no functions (and especially not C)
-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");
     assertEquals(0, functionA.getCallsitesInFunction().size());
   }
-  
+
   public void testFunctionGetCallsitesPossiblyTargetingFunction() {
     String source =
         "function A(){B()};\n" +
         "function B(){C();C();};\n" +
         "function C(){C()};\n" +
         "A();\n";
-    
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     Function main = callgraph.getMainFunction();
     Function functionA = callgraph.getUniqueFunctionWithName("A");
     Function functionB = callgraph.getUniqueFunctionWithName("B");
     Function functionC = callgraph.getUniqueFunctionWithName("C");
-    
+
     assertEquals(0, main.getCallsitesPossiblyTargetingFunction().size());
-    
+
     Collection<Callsite> callsitesTargetingA =
         functionA.getCallsitesPossiblyTargetingFunction();
-       
+
     // A is called only from the main function
     assertEquals(1, callsitesTargetingA.size());
     assertEquals(main,
         callsitesTargetingA.iterator().next().getContainingFunction());
-    
+
     Collection<Callsite> callsitesTargetingB =
       functionB.getCallsitesPossiblyTargetingFunction();
-  
+
     // B is called only from A
     assertEquals(1, callsitesTargetingB.size());
     assertEquals(functionA,
         callsitesTargetingB.iterator().next().getContainingFunction());
-    
+
     Collection<Callsite> callsitesTargetingC =
       functionC.getCallsitesPossiblyTargetingFunction();
-    
+
     // C is called 3 times: twice from B and once from C
     assertEquals(3, callsitesTargetingC.size());
-    
+
     Collection<Callsite> expectedFunctionsCallingC =
         Sets.newHashSet(functionB.getCallsitesInFunction());
     expectedFunctionsCallingC.addAll(functionC.getCallsitesInFunction());
-    
-    assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC)); 
+
+    assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC));
   }
-  
+
   public void testFunctionGetCallsitesInFunction_newIsCallsite() {
     String source =
         "function A(){};\n" +
         "function C(){new A()};\n";
-      
+
     CallGraph callgraph = compileAndRunForward(source);
-  
+
     // The call to new A() in C() should count as a callsite
-    CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C");  
+    CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C");
     assertEquals(1, functionC.getCallsitesInFunction().size());
   }
-  
-  public void testFunctionGetIsAliased() { 
-    // Aliased by VAR assignment   
+
+  public void testFunctionGetIsAliased() {
+    // Aliased by VAR assignment
     String source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -841,15 +841,15 @@ public class CallGraphTest extends CompilerTestCase {
         "var aliasB = ns.B;\n" +
         "var aliasC = C;\n" +
         "D();";
-      
+
     compileAndRunForward(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "D");
-    
-    // Aliased by normal assignment   
+
+    // Aliased by normal assignment
     source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -863,15 +863,15 @@ public class CallGraphTest extends CompilerTestCase {
         "var aliasC;\n" +
         "aliasC = C;\n" +
         "ns.D();";
-      
+
     compileAndRunForward(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "ns.D");
-    
-    // Aliased by passing as parameter  
+
+    // Aliased by passing as parameter
     source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -883,14 +883,14 @@ public class CallGraphTest extends CompilerTestCase {
         "foo(ns.B)\n" +
         "foo(C);\n" +
         "D();";
-      
+
     compileAndRunForward(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "D");
-    
+
     // Not aliased by being target of call
     source =
         "function A(){};\n" +
@@ -900,13 +900,13 @@ public class CallGraphTest extends CompilerTestCase {
         "A();\n" +
         "ns.B();\n" +
         "C();\n";
-        
+
     compileAndRunForward(source);
-    
+
     assertFunctionAliased(false, "A");
     assertFunctionAliased(false, "ns.B");
     assertFunctionAliased(false, "C");
-    
+
     // Not aliased by GET{PROP,ELEM}
     source =
         "function A(){};\n" +
@@ -916,15 +916,15 @@ public class CallGraphTest extends CompilerTestCase {
         "A.foo;\n" +
         "ns.B.prototype;\n" +
         "C[0];\n";
-        
+
     compileAndRunForward(source);
-    
+
     assertFunctionAliased(false, "A");
     assertFunctionAliased(false, "ns.B");
     assertFunctionAliased(false, "C");
   }
-   
-  public void testFunctionGetIsExposedToCallOrApply() { 
+
+  public void testFunctionGetIsExposedToCallOrApply() {
     // Exposed to call
     String source =
         "function A(){};\n" +
@@ -934,126 +934,126 @@ public class CallGraphTest extends CompilerTestCase {
         "A.call(x);\n" +
         "B.apply(x);\n" +
         "C();\n";
-    
+
     CallGraph callGraph = compileAndRunForward(source);
-  
+
     Function functionA = callGraph.getUniqueFunctionWithName("A");
     Function functionB = callGraph.getUniqueFunctionWithName("B");
     Function functionC = callGraph.getUniqueFunctionWithName("C");
-    
+
     assertTrue(functionA.isExposedToCallOrApply());
     assertTrue(functionB.isExposedToCallOrApply());
     assertFalse(functionC.isExposedToCallOrApply());
   }
-  
+
   public void testCallsiteGetAstNode() {
     String source =
       "function A(){B()};\n" +
       "function B(){};\n";
-  
+
     CallGraph callgraph = compileAndRunForward(source);
-    
-    Function functionA = callgraph.getUniqueFunctionWithName("A");   
+
+    Function functionA = callgraph.getUniqueFunctionWithName("A");
     Callsite callToB = functionA.getCallsitesInFunction().iterator().next();
-    
+
     assertTrue(callToB.getAstNode().getType() == Token.CALL);
   }
-  
+
   public void testCallsiteGetContainingFunction() {
     String source =
       "function A(){B()};\n" +
       "function B(){};\n" +
       "A();\n";
-  
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     Function mainFunction = callgraph.getMainFunction();
     Callsite callToA = mainFunction.getCallsitesInFunction().iterator().next();
     assertEquals(mainFunction, callToA.getContainingFunction());
-    
+
     Function functionA = callgraph.getUniqueFunctionWithName("A");
     Callsite callToB = functionA.getCallsitesInFunction().iterator().next();
     assertEquals(functionA, callToB.getContainingFunction());
   }
-  
+
   public void testCallsiteGetKnownTargets() {
     String source =
       "function A(){B()};\n" +
       "function B(){};\n" +
       "A();\n";
-  
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     Function mainFunction = callgraph.getMainFunction();
     Function functionA = callgraph.getUniqueFunctionWithName("A");
     Function functionB = callgraph.getUniqueFunctionWithName("B");
-    
+
     Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()
         .next();
-    
+
     Collection<Function> targetsOfCallInMain = callInMain.getPossibleTargets();
-    
+
     assertEquals(1, targetsOfCallInMain.size());
     assertTrue(targetsOfCallInMain.contains(functionA));
-    
+
     Callsite callInA = functionA.getCallsitesInFunction().iterator().next();
     Collection<Function> targetsOfCallInA = callInA.getPossibleTargets();
-    
+
     assertTrue(targetsOfCallInA.contains(functionB));
   }
-  
+
   public void testCallsiteHasUnknownTarget() {
     String source =
       "var A = externalnamespace.prop;\n" +
       "function B(){A();};\n" +
       "B();\n";
-  
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     Function mainFunction = callgraph.getMainFunction();
     Function functionB = callgraph.getUniqueFunctionWithName("B");
-    
+
     Callsite callInMain =
         mainFunction.getCallsitesInFunction().iterator().next();
-    
+
     // B()'s target function is known, and it is functionB
     assertFalse(callInMain.hasUnknownTarget());
     assertEquals("B", callInMain.getAstNode().getFirstChild().getString());
-        
+
     Callsite callInB = functionB.getCallsitesInFunction().iterator().next();
-    
+
     // A() has an unknown target and no known targets
     assertTrue(callInB.hasUnknownTarget());
     assertEquals(0, callInB.getPossibleTargets().size());
   }
-  
+
   public void testCallsiteHasExternTarget() {
     String source =
       "var A = function(){}\n" +
       "function B(){ExternalFunction(6);};\n" +
       "A();\n";
-  
+
     CallGraph callgraph = compileAndRunForward(source);
-    
+
     Function mainFunction = callgraph.getMainFunction();
     Function functionB = callgraph.getUniqueFunctionWithName("B");
-    
+
     Callsite callInMain =
         mainFunction.getCallsitesInFunction().iterator().next();
-    
+
     // A()'s target function is not an extern
     assertFalse(callInMain.hasExternTarget());
-    
+
     Callsite callInB = functionB.getCallsitesInFunction().iterator().next();
-    
+
     assertEquals("ExternalFunction",
         callInB.getAstNode().getFirstChild().getString());
-    
+
     // ExternalFunction(6) is a call to an extern function
     assertTrue(callInB.hasExternTarget());
-    assertEquals(0, callInB.getPossibleTargets().size());  
+    assertEquals(0, callInB.getPossibleTargets().size());
   }
-  
+
   public void testThrowForBackwardOpOnForwardGraph() {
     String source =
       "function A(){B()};\n" +
@@ -1066,55 +1066,55 @@ public class CallGraphTest extends CompilerTestCase {
     Function functionA = callgraph.getUniqueFunctionWithName("A");
 
     UnsupportedOperationException caughtException = null;
-    
+
     try {
       functionA.getCallsitesPossiblyTargetingFunction();
     } catch (UnsupportedOperationException e) {
       caughtException = e;
     }
-   
-    assertNotNull(caughtException);    
+
+    assertNotNull(caughtException);
   }
-  
+
   public void testThrowForForwardOpOnBackwardGraph() {
     String source =
       "function A(){B()};\n" +
       "function B(){};\n" +
       "A();\n";
-  
+
     CallGraph callgraph = compileAndRunBackward(source);
-    
+
     Function mainFunction = callgraph.getMainFunction();
     Function functionA = callgraph.getUniqueFunctionWithName("A");
-    
+
     Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()
         .next();
-      
+
     UnsupportedOperationException caughtException = null;
-    
+
     try {
       callInMain.getPossibleTargets();
     } catch (UnsupportedOperationException e) {
       return;
     }
-    fail();   
+    fail();
   }
-  
+
   /**
    * Helper function that, given a collection of callsites, returns a
    * collection of the names of the target expression nodes, e.g.
    * if the callsites are [A(), B.b()], the collection returned is
    * ["A", "B"].
-   * 
+   *
    * This makes it easier to test methods that return collections of callsites.
-   * 
+   *
    * An exception is thrown if the callsite target is not a simple name
    * (e.g. "a.bar()").
    */
   private List<String> getCallsiteTargetNames(Collection<Callsite>
-      callsites) { 
+      callsites) {
     List<String> result = Lists.newArrayList();
-    
+
     for (Callsite callsite : callsites) {
       Node targetExpressionNode = callsite.getAstNode().getFirstChild();
       if (targetExpressionNode.getType() == Token.NAME) {
@@ -1124,34 +1124,34 @@ public class CallGraphTest extends CompilerTestCase {
             "a complex callsite.");
       }
     }
-    
+
     return result;
   }
- 
+
   private void assertFunctionAliased(boolean aliased, String name) {
     Function function = currentProcessor.getUniqueFunctionWithName(name);
-    
+
     assertEquals(aliased, function.isAliased());
   }
-  
+
   private CallGraph compileAndRunBackward(String js) {
     return compileAndRun(SHARED_EXTERNS, js, false, true);
   }
-  
+
   private CallGraph compileAndRunForward(String js) {
     return compileAndRun(SHARED_EXTERNS, js, true, false);
   }
-  
+
   private CallGraph compileAndRun(String externs,
       String js,
       boolean forward,
       boolean backward) {
-    
+
     createBackwardCallGraph = backward;
     createForwardCallGraph = forward;
-    
+
     testSame(externs, js, null);
-    
+
     return currentProcessor;
   }
 }
diff --git a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
index fc0ffd12..abc6f585 100644
--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java
@@ -57,7 +57,7 @@ public class CheckGlobalNamesTest extends CompilerTestCase {
     STRICT_MODULE_DEP_QNAME.level = CheckLevel.WARNING;
   }
 
-  private static final String GET_NAMES = 
+  private static final String GET_NAMES =
       "var a = {get d() {return 1}}; a.b = 3; a.c = {get e() {return 5}};";
   private static final String SET_NAMES =
       "var a = {set d(x) {}}; a.b = 3; a.c = {set e(y) {}};";
@@ -113,12 +113,12 @@ public class CheckGlobalNamesTest extends CompilerTestCase {
     testSame(GET_NAMES + "alert(a.c.x);", UNDEFINED_NAME_WARNING);
     testSame(SET_NAMES + "alert(a.c.x);", UNDEFINED_NAME_WARNING);
   }
-  
+
   public void testRefToUndefinedProperty4() {
     testSame(NAMES + "alert(a.d.x);");
     testSame(GET_NAMES + "alert(a.d.x);");
     testSame(SET_NAMES + "alert(a.d.x);");
-  }  
+  }
 
   public void testRefToDescendantOfUndefinedProperty1() {
     testSame(NAMES + "var c = a.x.b;", UNDEFINED_NAME_WARNING);
diff --git a/test/com/google/javascript/jscomp/CheckRegExpTest.java b/test/com/google/javascript/jscomp/CheckRegExpTest.java
index 4db8a6bf..b0023e7f 100644
--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java
+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java
@@ -65,7 +65,7 @@ public class CheckRegExpTest extends CompilerTestCase {
 
     // No RegExp reference is ok
     testReference("var x;", false);
-    
+
     // Local RegExp is ok
     testReference("function f() {var RegExp; RegExp.test();}", false);
   }
diff --git a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
index 041550e6..ebcee4a7 100644
--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
@@ -136,15 +136,15 @@ public class ClosureCodingConventionTest extends TestCase {
   public void testInheritanceDetection11() {
     assertNotClassDefining("A.mixin(B)");
   }
-  
+
   public void testInheritanceDetection12() {
     assertNotClassDefining("goog.mixin(A.prototype, B)");
   }
-  
+
   public void testInheritanceDetection13() {
     assertNotClassDefining("goog.mixin(A, B)");
   }
-  
+
   public void testInheritanceDetectionPostCollapseProperties() {
     assertDefinesClasses("goog$inherits(A, B);", "A", "B");
     assertNotClassDefining("goog$inherits(A);");
diff --git a/test/com/google/javascript/jscomp/CompilerTest.java b/test/com/google/javascript/jscomp/CompilerTest.java
index 582ac71a..754b459f 100644
--- a/test/com/google/javascript/jscomp/CompilerTest.java
+++ b/test/com/google/javascript/jscomp/CompilerTest.java
@@ -57,11 +57,11 @@ public class CompilerTest extends TestCase {
 
     assertEquals(0, cb.getLineIndex());
     assertEquals(12, cb.getColumnIndex());
-    
+
     // newline reset the column index
     cb.append("blah();\ngoo();");
 
     assertEquals(1, cb.getLineIndex());
-    assertEquals(6, cb.getColumnIndex());    
+    assertEquals(6, cb.getColumnIndex());
   }
 }
diff --git a/test/com/google/javascript/jscomp/InlineVariablesTest.java b/test/com/google/javascript/jscomp/InlineVariablesTest.java
index 66c35e4c..380f286f 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java
@@ -283,7 +283,7 @@ public class InlineVariablesTest extends CompilerTestCase {
             "(function() { a++; })(); var z = x;"});
     test(
         new String[] { "var x = a;", "",
-            "function cow() { a++; }; cow(); var z = x;"}, 
+            "function cow() { a++; }; cow(); var z = x;"},
         new String[] { "var x = a;", "",
             ";(function cow(){ a++; })(); var z = x;"});
     testSame(
diff --git a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
index aac3b8ee..69eeb950 100644
--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
@@ -528,8 +528,8 @@ public class JsMessageVisitorTest extends TestCase {
         "var MSG_EXTERNAL_2 = goog.getMsg('a')})" +
         "(function () {/** @desc Hello2 */ " +
         "var MSG_EXTERNAL_2 = goog.getMsg('a')})");
-  }  
-  
+  }
+
   private void extractMessagesSafely(String input) {
     extractMessages(input);
     JSError[] errors = compiler.getErrors();
diff --git a/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java b/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java
index cb7aec2d..2294198d 100644
--- a/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java
@@ -35,7 +35,7 @@ public class MemoizedScopeCreatorTest extends TestCase {
     // Wow, is there really a circular dependency between JSCompiler and
     // SyntacticScopeCreator?
     Compiler compiler = new Compiler();
-    compiler.initOptions(new CompilerOptions());    
+    compiler.initOptions(new CompilerOptions());
     ScopeCreator creator = new MemoizedScopeCreator(
         new SyntacticScopeCreator(compiler));
     Scope scopeA = creator.createScope(trueNode, null);
diff --git a/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java b/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java
index 5ceb2506..a9fb30da 100644
--- a/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java
@@ -18,7 +18,7 @@ package com.google.javascript.jscomp;
 
 /**
  * Tests for {@link ExternExportsPass}.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 public class PeepholeFoldWithTypesTest extends CompilerTestCase {
@@ -27,58 +27,58 @@ public class PeepholeFoldWithTypesTest extends CompilerTestCase {
   protected CompilerPass getProcessor(Compiler compiler) {
     return new PeepholeOptimizationsPass(compiler, new PeepholeFoldWithTypes());
   }
-  
+
   @Override
   public void setUp() {
     enableTypeCheck(CheckLevel.WARNING);
   }
-  
+
   public void testFoldTypeofObject() {
     test("var x = {};typeof x",
          "var x = {};\"object\"");
-    
+
     test("var x = [];typeof x",
          "var x = [];\"object\"");
-    
+
     // typeof null is "object" in JavaScript
     test("var x = null;typeof x",
          "var x = null;\"object\"");
   }
-  
+
   public void testFoldTypeofString() {
     test("var x = \"foo\";typeof x",
          "var x = \"foo\";\"string\"");
-    
+
     test("var x = new String(\"foo\");typeof x",
          "var x = new String(\"foo\");\"object\"");
   }
-  
+
   public void testFoldTypeofNumber() {
     test("var x = 10;typeof x",
          "var x = 10;\"number\"");
-    
+
     test("var x = new Number(6);typeof x",
          "var x = new Number(6);\"object\"");
   }
-  
+
   public void testFoldTypeofBoolean() {
     test("var x = false;typeof x",
          "var x = false;\"boolean\"");
-    
+
     test("var x = new Boolean(true);typeof x",
          "var x = new Boolean(true);\"object\"");
   }
-  
+
   public void testFoldTypeofUndefined() {
     test("var x = undefined;typeof x",
-         "var x = undefined;\"undefined\""); 
+         "var x = undefined;\"undefined\"");
   }
-  
+
   public void testDontFoldTypeofUnionTypes() {
     // For now we don't do anything with union types
     testSame("var x = (unknown ? {} : null);typeof x");
   }
-  
+
   public void testDontFoldTypeofSideEffects() {
     // Shouldn't fold if argument to typeof has side effects
     testSame("var x = 6 ;typeof (x++)");
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java
index 06d22db5..e412f29d 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java
@@ -362,7 +362,7 @@ public class RemoveUnusedPrototypePropertiesTest extends CompilerTestCase {
 
       "function Foo() {}" +
       "Foo.prototype = {};");
-    
+
     anchorUnusedVars = true;
     test(
         "function Foo() {}" +
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
index eaa7dd2e..0d5c19cc 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java
@@ -576,7 +576,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
     // this.modifyCallSites = false;
     testSame("({set s(a) {}})");
   }
-  
+
   public void testRemoveInheritedClass1() {
     test("function goog$inherits(){}" +
         "/**@constructor*/function a(){}" +
@@ -584,7 +584,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
         "goog$inherits(b,a); new a",
         "function a(){} new a");
   }
-  
+
   public void testRemoveInheritedClass2() {
     test("function goog$inherits(){}" +
         "function goog$mixin(){}" +
@@ -638,7 +638,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
         "function c(){}" +
         "goog$mixin(c.prototype,a.prototype); new c");
   }
-  
+
   public void testRemoveInheritedClass7() {
     test("function goog$mixin(){}" +
         "/**@constructor*/function a(){alert(goog$mixin(a, a))}" +
@@ -647,7 +647,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
         "function goog$mixin(){}" +
         "function a(){alert(goog$mixin(a, a))} new a");
   }
-  
+
   public void testRemoveInheritedClass8() {
     test("/**@constructor*/function a(){}" +
         "/**@constructor*/function b(){}" +
@@ -662,7 +662,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
         "/**@constructor*/function c(){}" +
         "b.inherits(a);c.mixin(b.prototype);new c");
   }
-  
+
   public void testRemoveInheritedClass10() {
     test("function goog$inherits(){}" +
         "/**@constructor*/function a(){}" +
@@ -672,7 +672,7 @@ public class RemoveUnusedVarsTest extends CompilerTestCase {
         "function goog$inherits(){}" +
         "function a(){} function b(){} goog$inherits(b,a); new a; new b");
   }
-  
+
   public void testRemoveInheritedClass11() {
     testSame("function goog$inherits(){}" +
         "function goog$mixin(a,b){goog$inherits(a,b)}" +
diff --git a/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java
index 00de3caa..580b3daf 100644
--- a/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java
@@ -24,47 +24,47 @@ import com.google.javascript.rhino.Token;
 
 /**
  * Tests for {@link SideEffectsAnalysis}.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  *
  */
 public class SideEffectsAnalysisTest extends CompilerTestCase {
 
   private static final String SHARED_EXTERNS = "var arguments = [];";
-  
+
   LocationAbstractionMode currentLocationAbstractionIdentifier;
-  
+
   SideEffectsAnalysis currentAnalysis = null;
-  
+
   Compiler currentCompiler = null;
-  
+
   Node currentJsRoot = null;
-  
+
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
-    currentCompiler = compiler;   
-   
+    currentCompiler = compiler;
+
     currentAnalysis = new SideEffectsAnalysis(compiler,
         currentLocationAbstractionIdentifier);
-    
+
     return new CompilerPass() {
-      
+
       @Override
       public void process(Node externs, Node root) {
-        
-        if (currentLocationAbstractionIdentifier == 
+
+        if (currentLocationAbstractionIdentifier ==
           LocationAbstractionMode.VISIBILITY_BASED) {
-          
+
           // Run var when using the visibility abstraction
           // because it is unsound if it fails.
-          
+
           final VarCheck varCheck = new VarCheck(compiler);
-          
+
           varCheck.process(externs, root);
         }
-        
+
         currentAnalysis.process(externs, root);
-        
+
       }
     };
   }
@@ -72,43 +72,43 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    
+
     currentAnalysis = null;
     currentCompiler = null;
   }
-  
-  public void testDegenerateSafeMoves() {      
+
+  public void testDegenerateSafeMoves() {
     // Env is empty
     assertSafeMoveDegenerate("src: 1; env: ; dest: 3;");
-    
+
     // Src and env pure
     assertSafeMoveDegenerate("src: 1; env: 2; dest: 3;");
-    
+
     // Only refs
     assertSafeMoveDegenerate("src: 1; env: x; dest: 3;");
     assertSafeMoveDegenerate("src: x; env: 1; dest: 3;");
-    
+
     // Only mods
     assertSafeMoveDegenerate("src: 1; env: x++; dest: 3;");
-    
+
     assertSafeMoveDegenerate("src: x++; env: 1; dest: 3;");
   }
-  
-  public void testVisibilitySafeMoves() {      
+
+  public void testVisibilitySafeMoves() {
     // Env is empty
     assertSafeMoveVisibility("src: 1; env: ; dest: 3;");
-    
+
     // Src and env pure
     assertSafeMoveVisibility("src: 1; env: 2; dest: 3;");
-    
+
     // Only refs
     assertSafeMoveVisibility("var x; src: 1; env: x; dest: 3;");
     assertSafeMoveVisibility("var x; src: x; env: 1; dest: 3;");
-    
+
     // Only mods
     assertSafeMoveVisibility("var x; src: 1; env: x++; dest: 3;");
     assertSafeMoveVisibility("var x; src: x++; env: 1; dest: 3;");
-    
+
     // Source references global, env changes local
     assertSafeMoveVisibility(
         "var x;" +
@@ -118,7 +118,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y++;" +
           "dest: 3;" +
           "}");
-    
+
     // Source changes global, env refs local
     assertSafeMoveVisibility(
         "var x;" +
@@ -128,7 +128,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y;" +
           "dest: 3;" +
           "}");
-    
+
     // Source references global, env changes local with shadowing
     assertSafeMoveVisibility(
         "var x;" +
@@ -139,7 +139,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y++;" +
           "dest: 3;" +
           "}");
-    
+
     // Source changes global, env refs local with shadowing
     assertSafeMoveVisibility(
         "var x;" +
@@ -150,8 +150,8 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y;" +
           "dest: 3;" +
           "}");
-    
-    
+
+
     // Source references captured local, env changes local
     assertSafeMoveVisibility(
         "function f(){" +
@@ -164,7 +164,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
             "x" +
           "}" +
          "}");
-    
+
     // Source changes captured local, env refs local
     assertSafeMoveVisibility(
         "function f(){" +
@@ -177,7 +177,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
             "x" +
           "}" +
         "}");
-    
+
     // Source references heap, env changes local
     assertSafeMoveVisibility(
         "var x = {};" +
@@ -187,7 +187,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y++;" +
           "dest: 3;" +
           "}");
-    
+
     // Source changes heap, env refs local
     assertSafeMoveVisibility(
         "var x = {};" +
@@ -197,7 +197,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y;" +
           "dest: 3;" +
           "}");
-    
+
     // MOD in function expressions shouldn't count
     assertSafeMoveVisibility(
         "var x = {};" +
@@ -206,7 +206,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "x.a++;" +
         "});" +
         "dest: 3;");
-    
+
     // REF in function expressions shouldn't count
     assertSafeMoveVisibility(
         "var x = {};" +
@@ -215,31 +215,31 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "x.a;" +
         "});" +
         "dest: 3;");
-    
+
   }
-  
+
   public void testDegenerateUnsafeMoves() {
-    
+
     // Unsafe to move increment across read
     assertUnsafeMoveDegenerate("src: x++; env: foo(y); dest: 3;");
-   
+
     // Unsafe to move read across increment
     assertUnsafeMoveDegenerate("src: foo(y); env: x++; dest: 3;");
-    
+
     // Unsafe to move write across write
     assertUnsafeMoveDegenerate("src: x = 7; env: y = 3; dest:3;");
   }
-    
+
   public void testVisibilityUnsafeMoves() {
-    
+
     // Unsafe to move increment across read for global variables
     assertUnsafeMoveVisibility("var x,y; src: x++; env: y; dest: 3;");
-    
+
     // Unsafe to move increment across read for local variables
     assertUnsafeMoveVisibility("function f() {" +
         "var x,y; src: x++; env: y; dest: 3;" +
         "}");
-    
+
     // Unsafe to move increment across read for captured local variables
     assertUnsafeMoveVisibility(
         "function f() {" +
@@ -248,18 +248,18 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
             "x; y;" +
           "}" +
          "}");
-            
+
     // Unsafe to move increment across read for heap locations
     assertUnsafeMoveVisibility("var x,y; src: x.a++; env: y.b; dest: 3;");
-     
+
     // Unsafe to move read across increment of for global variables
     assertUnsafeMoveVisibility("var x,y; src: y; env: x++; dest: 3;");
-    
+
     // Unsafe to move read across increment for local variables
     assertUnsafeMoveVisibility("function f() {" +
         "var x,y; src: x; env: y++; dest: 3;" +
         "}");
-    
+
     // Unsafe to move read across increment for captured local variables
     assertUnsafeMoveVisibility(
         "function f() {" +
@@ -268,18 +268,18 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
             "x; y;" +
           "}" +
          "}");
-    
+
     // Unsafe to move read across increment for heap locations
     assertUnsafeMoveVisibility("var x,y; src: x.a; env: y.b++; dest: 3;");
-    
+
     // Unsafe to move write across write for globals
     assertUnsafeMoveVisibility("var x,y; src: x = 7; env: y = 3; dest: 3;");
-    
+
     // Unsafe to move write across write for local variables
     assertUnsafeMoveVisibility("function f() {" +
         "var x,y; src: x = 7; env: y = 3; dest: 3;" +
         "}");
-    
+
     // Unsafe to move write across write for captured local variables
     assertUnsafeMoveVisibility(
         "function f() {" +
@@ -288,18 +288,18 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
             "x; y;" +
           "}" +
          "}");
-    
+
     // Unsafe to move write across write for heap locations
     assertUnsafeMoveVisibility("var x,y; src: x.a = 7; env: y.b = 3; dest: 3;");
   }
-  
+
   public void testVisibilityMoveCalls() {
     // Interprocedural side effect analysis isn't implemented yet, so any calls
     // should make movement unsafe, since we don't know what those calls are
     // doing.
-    
+
     // TODO(dcc): implement interprocedural side effect analysis.
-    
+
     // Source makes call, env refs global
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -310,7 +310,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: x;" +
           "dest: 3;" +
           "}");
-    
+
     // Source makes refs global, env makes call
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -322,12 +322,12 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "dest: 3;" +
           "}");
   }
-  
+
   public void testVisibilityMergesParametersWithHeap() {
     // For now, we expect the visibility based location abstraction
     // to merge parameter variable locations with heap locations because
     // parameters can be references and modified via the arguments object.
-    
+
     // Source changes heap, env refs parameter
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -336,7 +336,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y;" +
           "dest: 3;" +
           "}");
-    
+
     // Source refs heap, env changes parameters
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -345,7 +345,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y++;" +
           "dest: 3;" +
           "}");
-    
+
     // Source changes arguments explicitly, env refs parameter
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -354,7 +354,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "env: y;" +
           "dest: 3;" +
           "}");
-    
+
     // Source refs arguments explicitly, env changes parameter
     assertUnsafeMoveVisibility(
         "var x = {};" +
@@ -362,11 +362,11 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "src: arguments[0];" +
           "env: y++;" +
           "dest: 3;" +
-          "}");   
+          "}");
   }
-  
+
   public void testMovedSideEffectsMustHaveSameControlFlow() {
-    
+
     // Safe to move within IF block
     assertSafeMoveVisibility(
         "var a;" +
@@ -379,7 +379,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move between two IF blocks
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -394,7 +394,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move between then/else of same IF block
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -408,7 +408,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Safe to move within WHILE block
     assertSafeMoveVisibility(
         "var a;" +
@@ -421,7 +421,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move within WHILE block with BREAK
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -435,7 +435,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move within WHILE block with continue
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -449,7 +449,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move within WHILE block with continue
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -463,7 +463,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Safe to move within DO
     assertSafeMoveVisibility(
         "var a;" +
@@ -476,7 +476,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "} while(l)" +
         "}"
     );
-    
+
     // Unsafe to move outside DO
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -489,7 +489,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "dest: 3;" +
         "}"
     );
-    
+
     // It should be safe to move within CASE
     // but we disallow for now because analyzing
     // CASE fall-through and BREAKs is complicated.
@@ -506,7 +506,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
           "}" +
         "}"
     );
-    
+
     // Unsafe to move between CASEs
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -517,13 +517,13 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
               "src: a++;" +
               "env: 3;" +
             "break;" +
-            "case 18:" + 
+            "case 18:" +
               "dest: 3;" +
             "break;" +
           "}" +
         "}"
     );
-    
+
     // Unsafe to move between FUNCTIONs
     assertUnsafeMoveVisibility(
         "var a;" +
@@ -536,74 +536,74 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
         "}"
     );
   }
-    
+
   private SideEffectsAnalysis.AbstractMotionEnvironment environment(
       Node ...nodes) {
-    
+
     return new SideEffectsAnalysis.RawMotionEnvironment(
         ImmutableSet.copyOf(nodes));
   }
-  
+
   private void assertMove(LocationAbstractionMode abstraction,
       String src,
       boolean expected) {
     SideEffectsAnalysis analysis = compileAndRun(src, abstraction);
-    
+
     Node sourceNode = findLabeledStatement("src");
     Node environmentNode = findLabeledStatement("env");
     Node destinationNode = findLabeledStatement("dest");
-     
+
     boolean result = analysis.safeToMoveBefore(sourceNode,
         environment(environmentNode), destinationNode);
-    
+
     if (expected) {
       assertTrue(result);
     } else {
       assertFalse(result);
-    }   
+    }
   }
-  
+
   private void assertSafeMoveDegenerate(String src) {
     assertMove(LocationAbstractionMode.DEGENERATE, src, true);
   }
-  
+
   private void assertUnsafeMoveDegenerate(String src) {
     assertMove(LocationAbstractionMode.DEGENERATE, src, false);
   }
-  
+
   private void assertSafeMoveVisibility(String src) {
     assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, true);
   }
-  
+
   private void assertUnsafeMoveVisibility(String src) {
     assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, false);
   }
-  
+
   private SideEffectsAnalysis compileAndRun(String js,
       LocationAbstractionMode locationAbstractionIdentifier) {
-    
+
     currentLocationAbstractionIdentifier = locationAbstractionIdentifier;
-    
+
     testSame(SHARED_EXTERNS, js, null);
-    
+
     currentJsRoot = currentCompiler.jsRoot;
-    
+
     return currentAnalysis;
-  } 
-  
+  }
+
   // Shamelessly stolen from NameReferenceGraphConstructionTest
   private Node findLabeledStatement(String label) {
     LabeledStatementSearcher s = new LabeledStatementSearcher(label);
-      
+
     new NodeTraversal(currentCompiler, s).traverse(currentCompiler.jsRoot);
     assertNotNull("Label " + label + " should be in the source code", s.found);
-    
+
     return s.found;
   }
-  
+
   /**
    * Quick traversal to find a given labeled statement in the AST.
-   * 
+   *
    * Given "foo", finds the statement a = x in
    * foo: a = x;
    */
@@ -618,7 +618,7 @@ public class SideEffectsAnalysisTest extends CompilerTestCase {
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (n.getType() == Token.LABEL &&
           target.equals(n.getFirstChild().getString())) {
-        
+
         found = n.getLastChild();
       }
     }
diff --git a/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java b/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java
index 8d285549..591be1a9 100644
--- a/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java
@@ -20,35 +20,35 @@ import com.google.javascript.rhino.Node;
 
 /**
  * Tests for {@link SimpleFunctionAliasAnalysis}.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
-  
+
   private SimpleFunctionAliasAnalysis analysis;
-  
+
   private Compiler lastCompiler;
-  
+
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
       return new CompilerPass() {
-        
+
         @Override
         public void process(Node externs, Node root) {
           SimpleDefinitionFinder finder = new SimpleDefinitionFinder(compiler);
           finder.process(externs, root);
-          
+
           analysis = new SimpleFunctionAliasAnalysis();
-          
-          analysis.analyze(finder);  
-          
+
+          analysis.analyze(finder);
+
           lastCompiler = compiler;
         }
       };
   }
 
-  public void testFunctionGetIsAliased() { 
-    // Aliased by VAR assignment   
+  public void testFunctionGetIsAliased() {
+    // Aliased by VAR assignment
     String source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -59,15 +59,15 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "var aliasB = ns.B;\n" +
         "var aliasC = C;\n" +
         "D();";
-      
+
     compileAndRun(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "D");
-    
-    // Aliased by normal assignment   
+
+    // Aliased by normal assignment
     source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -81,15 +81,15 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "var aliasC;\n" +
         "aliasC = C;\n" +
         "ns.D();";
-      
+
     compileAndRun(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "ns.D");
-    
-    // Aliased by passing as parameter  
+
+    // Aliased by passing as parameter
     source =
         "function A(){};\n" +
         "var ns = {};\n" +
@@ -101,14 +101,14 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "foo(ns.B)\n" +
         "foo(C);\n" +
         "D();";
-      
+
     compileAndRun(source);
-  
+
     assertFunctionAliased(true, "A");
     assertFunctionAliased(true, "ns.B");
     assertFunctionAliased(true, "C");
     assertFunctionAliased(false, "D");
-    
+
     // Not aliased by being target of call
     source =
         "function A(){};\n" +
@@ -118,13 +118,13 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "A();\n" +
         "ns.B();\n" +
         "C();\n";
-        
+
     compileAndRun(source);
-    
+
     assertFunctionAliased(false, "A");
     assertFunctionAliased(false, "ns.B");
     assertFunctionAliased(false, "C");
-    
+
     // Not aliased by GET{PROP,ELEM}
     source =
         "function A(){};\n" +
@@ -134,15 +134,15 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "A.foo;\n" +
         "ns.B.prototype;\n" +
         "C[0];\n";
-        
+
     compileAndRun(source);
-    
+
     assertFunctionAliased(false, "A");
     assertFunctionAliased(false, "ns.B");
     assertFunctionAliased(false, "C");
   }
-  
-  public void testFunctionGetIsExposedToCallOrApply() { 
+
+  public void testFunctionGetIsExposedToCallOrApply() {
     // Exposed to call
     String source =
         "function A(){};\n" +
@@ -152,13 +152,13 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         "A.call(x);\n" +
         "B.apply(x);\n" +
         "C();\n";
-    
+
     compileAndRun(source);
-  
+
     assertFunctionExposedToCallOrApply(true, "A");
     assertFunctionExposedToCallOrApply(true, "B");
     assertFunctionExposedToCallOrApply(false, "C");
-    
+
     source =
       "var ns = {};" +
       "ns.A = function(){};\n" +
@@ -168,39 +168,39 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
       "ns.A.call(x);\n" +
       "ns.B.apply(x);\n" +
       "ns.C();\n";
-  
+
     compileAndRun(source);
 
     assertFunctionExposedToCallOrApply(true, "ns.A");
     assertFunctionExposedToCallOrApply(true, "ns.B");
     assertFunctionExposedToCallOrApply(false, "ns.C");
   }
-  
+
   private void assertFunctionAliased(boolean aliasStatus,
       String functionName) {
     Node function = findFunction(functionName);
-    
+
     assertEquals(aliasStatus, analysis.isAliased(function));
   }
-  
+
   private void assertFunctionExposedToCallOrApply(boolean exposure,
       String functionName) {
     Node function = findFunction(functionName);
-    
+
     assertEquals(exposure, analysis.isExposedToCallOrApply(function));
   }
-  
+
   private void compileAndRun(String source) {
     testSame(source, source, null);
   }
-  
+
   private Node findFunction(String name) {
     FunctionFinder f = new FunctionFinder(name);
     new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);
     assertNotNull("Couldn't find " + name, f.found);
     return f.found;
   }
-  
+
   /**
    * Quick Traversal to find a given function in the AST.
    */
@@ -211,7 +211,7 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
     FunctionFinder(String target) {
       this.target = target;
     }
-    
+
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (NodeUtil.isFunction(n)
@@ -219,5 +219,5 @@ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {
         found = n;
       }
     }
-  }  
+  }
 }
diff --git a/test/com/google/javascript/jscomp/SpecializeModuleTest.java b/test/com/google/javascript/jscomp/SpecializeModuleTest.java
index 3b7dbe7a..482eaa09 100644
--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java
+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java
@@ -23,7 +23,7 @@ import com.google.javascript.rhino.Node;
 
 /**
  * Tests for {@link SpecializeModule}.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 public class SpecializeModuleTest extends CompilerTestCase {
@@ -42,7 +42,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
           compiler.getUniqueNameIdSupplier(), true, false, true);
     }
   };
-  
+
   private PassFactory removeUnusedPrototypeProperties =
     new PassFactory("removeUnusedPrototypeProperties", true) {
     @Override
@@ -50,7 +50,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
       return new RemoveUnusedPrototypeProperties(compiler, false, false);
     }
   };
-  
+
   private PassFactory devirtualizePrototypeMethods =
     new PassFactory("devirtualizePrototypeMethods", true) {
     @Override
@@ -58,20 +58,20 @@ public class SpecializeModuleTest extends CompilerTestCase {
       return new DevirtualizePrototypeMethods(compiler);
     }
   };
-  
+
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
     final SpecializeModule specializeModule = new SpecializeModule(compiler,
-        devirtualizePrototypeMethods, inlineFunctions, 
+        devirtualizePrototypeMethods, inlineFunctions,
         removeUnusedPrototypeProperties);
 
-    return new CompilerPass() {     
+    return new CompilerPass() {
       @Override
       public void process(Node externs, Node root) {
         specializeModule.process(externs, root);
 
         /* Make sure variables are declared before used */
-        new VarCheck(compiler).process(externs, root);       
+        new VarCheck(compiler).process(externs, root);
       }
     };
   }
@@ -87,9 +87,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "var A = function() {alert(B());A()};" + 
+        "var A = function() {alert(B());A()};" +
         "var B = function() {return 6};" +
-        "A();",       
+        "A();",
         // m2
         "A();" +
         "B();" +
@@ -100,9 +100,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
 
     test(modules, new String[] {
         // m1
-        "var A = function() {alert(6);A()};" + /* Specialized A */    
+        "var A = function() {alert(6);A()};" + /* Specialized A */
         "A();" +
-        "var B;",    
+        "var B;",
         // m2
         "A = function() {alert(B());A()};" + /* Unspecialized A */
         "B = function() {return 6};" + /* Removed from m1, so add to m2 */
@@ -113,24 +113,24 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "B();"
     });
   }
-  
+
   public void testSpecializeCascadedInline() {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "var A = function() {alert(B());A()};" + 
+        "var A = function() {alert(B());A()};" +
         "var B = function() {return C()};" +
         "var C = function() {return 6};" +
-        "A();",       
+        "A();",
         // m2
         "B = function() {return 7};" +
     "A();");
 
     test(modules, new String[] {
         // m1
-        "var A = function() {alert(6);A()};" + /* Specialized A */    
+        "var A = function() {alert(6);A()};" + /* Specialized A */
         "A();" +
-        "var B, C;",    
+        "var B, C;",
         // m2
         "A = function() {alert(B());A()};" + /* Unspecialized A */
         "B = function() {return C()};" + /* Removed from m1, so add to m2 */
@@ -144,9 +144,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "var A = function() {alert(B());A()};" + 
+        "var A = function() {alert(B());A()};" +
         "var B = function() {return 6};" +
-        "A();",       
+        "A();",
         // m2
         "B = function() {return 7};" +
         "A();",
@@ -156,9 +156,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
 
     test(modules, new String[] {
         // m1
-        "var A = function() {alert(6);A()};" + /* Specialized A */    
+        "var A = function() {alert(6);A()};" + /* Specialized A */
         "A();" +
-        "var B;",    
+        "var B;",
         // m2
         "A = function() {alert(B());A()};" + /* Unspecialized A */
         "B = function() {return 6};" + /* Removed from m1, so add to m2 */
@@ -176,9 +176,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
         // m1
         "var ns = {};" +
         /* Recursion in A() prevents inline of A*/
-        "ns.A = function() {alert(B());ns.A()};" + 
+        "ns.A = function() {alert(B());ns.A()};" +
         "var B = function() {return 6};" +
-        "ns.A();",       
+        "ns.A();",
         // m2
         "B = function() {return 7};" +
     "ns.A();");
@@ -186,9 +186,9 @@ public class SpecializeModuleTest extends CompilerTestCase {
     test(modules, new String[] {
         // m1
         "var ns = {};" +
-        "ns.A = function() {alert(6);ns.A()};" + /* Specialized A */    
+        "ns.A = function() {alert(6);ns.A()};" + /* Specialized A */
         "ns.A();" +
-        "var B;",    
+        "var B;",
         // m2
         "ns.A = function() {alert(B());ns.A()};" + /* Unspecialized A */
         "B = function() {return 6};" + /* Removed from m1, so add to m2 */
@@ -201,18 +201,18 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "function A() {alert(B());A()}" + 
+        "function A() {alert(B());A()}" +
         "function B() {return 6}" +
-        "A();",       
+        "A();",
         // m2
         "B = function() {return 7};" +
     "A();");
 
     test(modules, new String[] {
         // m1
-        "function A() {alert(6);A()}" + /* Specialized A */    
+        "function A() {alert(6);A()}" + /* Specialized A */
         "A();" +
-        "var B;",    
+        "var B;",
         // m2
         "A = function() {alert(B());A()};" + /* Unspecialized A */
         "B = function() {return 6};" + /* Removed from m1, so add to m2 */
@@ -229,14 +229,14 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         "(function(){var noSpecialize = " +
-            "function() {alert(6)};noSpecialize()})()",       
+            "function() {alert(6)};noSpecialize()})()",
         // m2
         "");
 
     test(modules, new String[] {
         // m1
         "(function(){var noSpecialize = " +
-            "function() {alert(6)};noSpecialize()})()", 
+            "function() {alert(6)};noSpecialize()})()",
         // m2
         ""
     });
@@ -246,19 +246,19 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "var A = function() {alert(B() + C());A()};" + 
+        "var A = function() {alert(B() + C());A()};" +
         "var B = function() {return 6};" +
         "var C = function() {return 8};" +
-        "A();",       
+        "A();",
         // m2
         "" +
     "A();");
 
     test(modules, new String[] {
         // m1
-        "var A = function() {alert(6 + 8);A()};" + /* Specialized A */    
+        "var A = function() {alert(6 + 8);A()};" + /* Specialized A */
         "A();" +
-        "var B, C;",    
+        "var B, C;",
         // m2
         "A = function() {alert(B() + C());A()};" + /* Unspecialized A */
         "B = function() {return 6};" + /* Removed from m1, so add to m2 */
@@ -272,12 +272,12 @@ public class SpecializeModuleTest extends CompilerTestCase {
         // m1
         /* Recursion in A() prevents inline of A*/
         "var Foo = function(){};" + /* constructor */
-        "Foo.prototype.a = function() {this.a()};" + 
+        "Foo.prototype.a = function() {this.a()};" +
         "Foo.prototype.b = function() {return 6};" +
         "Foo.prototype.c = function() {return 7};" +
         "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a
         "var x = new Foo();" +
-        "x.a();",       
+        "x.a();",
         // m2
         "");
 
@@ -287,21 +287,21 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "Foo.prototype.a = function() {this.a()};" +
         "var aliasA = Foo.prototype.a;" +
         "var x = new Foo();" +
-        "x.a();", 
+        "x.a();",
         // m2
         "Foo.prototype.b = function() {return 6};" +
-        "Foo.prototype.c = function() {return 7};"        
+        "Foo.prototype.c = function() {return 7};"
     });
   }
-  
+
   public void testDontSpecializeAliasedFunctions_inline() {
     JSModule[] modules = createModuleStar(
         // m1
         /* Recursion in A() prevents inline of A*/
-        "function A() {alert(B());A()}" + 
+        "function A() {alert(B());A()}" +
         "function B() {return 6}" +
         "var aliasA = A;" +
-        "A();",       
+        "A();",
         // m2
         "B = function() {return 7};" +
         "B();");
@@ -309,10 +309,10 @@ public class SpecializeModuleTest extends CompilerTestCase {
     test(modules, new String[] {
         // m1
         /* Recursion in A() prevents inline of A*/
-        "function A() {alert(B());A()}" + 
+        "function A() {alert(B());A()}" +
         "function B() {return 6}" +
         "var aliasA = A;" +
-        "A();",       
+        "A();",
         // m2
         "B = function() {return 7};" +
         "B();"
@@ -323,7 +323,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
     JSModule[] modules = createModuleStar(
         // m1
         "var Foo = function(){};" + /* constructor */
-        "Foo.prototype.a = function() {this.a()};" + 
+        "Foo.prototype.a = function() {this.a()};" +
         "Foo.prototype.b = function() {return 6};" +
         "var aliasB = Foo.prototype.b;" +
         "Foo.prototype.c = function() {return 7};" +
@@ -331,7 +331,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a
         "var x = new Foo();" +
         "x.a();" +
-        "var aliasC = (new Foo).c",       
+        "var aliasC = (new Foo).c",
         // m2
         "");
 
@@ -345,12 +345,12 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a
         "var x = new Foo();" +
         "x.a();" +
-        "var aliasC = (new Foo).c", 
+        "var aliasC = (new Foo).c",
         // m2
-        "Foo.prototype.d = function() {return 7};"        
+        "Foo.prototype.d = function() {return 7};"
     });
   }
-  
+
   public void testSpecializeDevirtualizePrototypeMethods() {
     JSModule[] modules = createModuleStar(
         // m1
@@ -367,7 +367,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
         // m1
         "var Foo = function(){};" + /* constructor */
         "var JSCompiler_StaticMethods_a =" +
-              "function(JSCompiler_StaticMethods_a$self) {" + 
+              "function(JSCompiler_StaticMethods_a$self) {" +
            "JSCompiler_StaticMethods_a(JSCompiler_StaticMethods_a$self);" +
            "return 7" +
         "};" +
@@ -378,7 +378,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "Foo.prototype.b = function() {this.a()};"
     });
   }
-  
+
   public void testSpecializeDevirtualizePrototypeMethodsWithInline() {
     JSModule[] modules = createModuleStar(
         // m1
@@ -399,107 +399,107 @@ public class SpecializeModuleTest extends CompilerTestCase {
         "Foo.prototype.a = function() {return 7};"
     });
   }
-  
+
   /**
    * Tests for {@link SpecializeModule.SpecializationState}.
    */
-  public static class SpecializeModuleSpecializationStateTest 
+  public static class SpecializeModuleSpecializationStateTest
       extends CompilerTestCase {
-    
+
     Compiler lastCompiler;
-    
+
     SpecializationState lastState;
-    
+
     @Override
     public CompilerPass getProcessor(final Compiler compiler) {
       lastCompiler = compiler;
-      
+
       return new CompilerPass() {
-        
+
         @Override
-        public void process(Node externs, Node root) {         
-          SimpleDefinitionFinder defFinder = 
+        public void process(Node externs, Node root) {
+          SimpleDefinitionFinder defFinder =
               new SimpleDefinitionFinder(compiler);
-          
+
           defFinder.process(externs, root);
-          
-          SimpleFunctionAliasAnalysis functionAliasAnalysis = 
+
+          SimpleFunctionAliasAnalysis functionAliasAnalysis =
               new SimpleFunctionAliasAnalysis();
-          
-          functionAliasAnalysis.analyze(defFinder); 
-          
-          lastState = new SpecializationState(functionAliasAnalysis);       
+
+          functionAliasAnalysis.analyze(defFinder);
+
+          lastState = new SpecializationState(functionAliasAnalysis);
         }
       };
     }
-      
+
     public void testRemovedFunctions() {
       testSame("function F(){}\nvar G = function(a){};");
-      
+
       assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());
-      
+
       Node functionF = findFunction("F");
-      
+
       lastState.reportRemovedFunction(functionF, functionF.getParent());
       assertEquals(ImmutableSet.of(functionF), lastState.getRemovedFunctions());
 
       Node functionG = findFunction("F");
-      
+
       lastState.reportRemovedFunction(functionG, functionF.getParent());
       assertEquals(ImmutableSet.of(functionF, functionG),
           lastState.getRemovedFunctions());
-      
+
       assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());
     }
-    
+
     public void testSpecializedFunctions() {
       testSame("function F(){}\nvar G = function(a){};");
-      
+
       assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());
-      
+
       Node functionF = findFunction("F");
-      
+
       lastState.reportSpecializedFunction(functionF);
       assertEquals(ImmutableSet.of(functionF),
           lastState.getSpecializedFunctions());
 
       Node functionG = findFunction("F");
-      
+
       lastState.reportSpecializedFunction(functionG);
       assertEquals(ImmutableSet.of(functionF, functionG),
           lastState.getSpecializedFunctions());
-      
+
       assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());
     }
-    
+
     public void testCanFixupFunction() {
       testSame("function F(){}\n" +
                "var G = function(a){};\n" +
                "var ns = {};" +
-               "ns.H = function(){};" + 
+               "ns.H = function(){};" +
                "var ns2 = {I : function anon1(){}};" +
                "(function anon2(){})();");
-      
+
       assertTrue(lastState.canFixupFunction(findFunction("F")));
       assertTrue(lastState.canFixupFunction(findFunction("G")));
       assertTrue(lastState.canFixupFunction(findFunction("ns.H")));
       assertFalse(lastState.canFixupFunction(findFunction("anon1")));
       assertFalse(lastState.canFixupFunction(findFunction("anon2")));
-      
+
       // Can't guarantee safe fixup for aliased functions
       testSame("function A(){}\n" +
           "var aliasA = A;\n");
 
       assertFalse(lastState.canFixupFunction(findFunction("A")));
     }
-    
+
     private Node findFunction(String name) {
       FunctionFinder f = new FunctionFinder(name);
       new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);
       assertNotNull("Couldn't find " + name, f.found);
       return f.found;
     }
-    
+
     /**
      * Quick Traversal to find a given function in the AST.
      */
@@ -510,7 +510,7 @@ public class SpecializeModuleTest extends CompilerTestCase {
       FunctionFinder(String target) {
         this.target = target;
       }
-      
+
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
         if (NodeUtil.isFunction(n)
@@ -518,6 +518,6 @@ public class SpecializeModuleTest extends CompilerTestCase {
           found = n;
         }
       }
-    }   
+    }
   }
 }
diff --git a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
index 8fab872e..1acf8b6f 100644
--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
@@ -161,7 +161,7 @@ public class TypeCheckFunctionCheckTest extends CompilerTestCase {
       "function twoArg(arg1, arg2) {};" +
       "Foo.prototype.prototypeMethod = twoArg;" +
       "Foo.staticMethod = twoArg;";
-    
+
     // Prototype method with too many arguments.
     testSame(METHOD_DEFS +
         "var f = new Foo();f.prototypeMethod(1, 2, 3);",
diff --git a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java
index 76a2afe9..4b30e8de 100644
--- a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java
@@ -24,24 +24,24 @@ import com.google.javascript.rhino.Token;
 
 /**
  * Tests of {@link VariableVisibilityAnalysis}.
- * 
+ *
  * @author dcc@google.com (Devin Coughlin)
  */
 public class VariableVisibilityAnalysisTest extends CompilerTestCase {
 
   private Compiler lastCompiler;
   private VariableVisibilityAnalysis lastAnalysis;
-  
+
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     lastAnalysis = new VariableVisibilityAnalysis(compiler);
     lastCompiler = compiler;
-    
+
     return lastAnalysis;
   }
-  
+
   public void testCapturedVariables() {
-    String source = 
+    String source =
         "global:var global;\n" +
         "function Outer() {\n" +
         "  captured:var captured;\n" +
@@ -50,34 +50,34 @@ public class VariableVisibilityAnalysisTest extends CompilerTestCase {
         "    alert(captured);" +
         "   }\n" +
         "}\n";
-    
+
     analyze(source);
-    
+
     assertIsCapturedLocal("captured");
     assertIsUncapturedLocal("notcaptured");
   }
-  
+
   public void testGlobals() {
-    String source = 
+    String source =
       "global:var global;";
-    
+
     analyze(source);
-    
-    assertIsGlobal("global"); 
+
+    assertIsGlobal("global");
   }
-  
+
   public void testParameters() {
-    String source = 
+    String source =
       "function A(a,b,c) {\n" +
       "}\n";
 
     analyze(source);
-    
+
     assertIsParameter("a");
     assertIsParameter("b");
     assertIsParameter("c");
   }
-  
+
   public void testFunctions() {
     String source =
         "function global() {\n" +
@@ -87,142 +87,142 @@ public class VariableVisibilityAnalysisTest extends CompilerTestCase {
         "    (function(){innerCaptured()})()\n" +
         "  }\n" +
         "}\n";
-    
+
     analyze(source);
-    
+
     assertFunctionHasVisibility("global",
         VariableVisibility.GLOBAL);
-    
+
     assertFunctionHasVisibility("inner",
         VariableVisibility.LOCAL);
-    
+
     assertFunctionHasVisibility("innerCaptured",
         VariableVisibility.CAPTURED_LOCAL);
   }
-  
+
   private void assertFunctionHasVisibility(String functionName,
       VariableVisibility visibility) {
-    
+
     Node functionNode = searchForFunction(functionName);
     assertNotNull(functionNode);
-    
+
     Node nameNode = functionNode.getFirstChild();
-    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  
+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));
   }
-  
+
   private void assertLabeledVariableHasVisibility(String label,
       VariableVisibility visibility) {
     Node labeledVariable = searchLabel(label);
-    
+
     Preconditions.checkState(NodeUtil.isVar(labeledVariable));
-    
+
     // VAR
-    //   NAME 
+    //   NAME
     Node nameNode = labeledVariable.getFirstChild();
-    
-    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  
+
+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));
   }
-  
+
   private void assertIsCapturedLocal(String label) {
-    assertLabeledVariableHasVisibility(label, 
-        VariableVisibility.CAPTURED_LOCAL); 
+    assertLabeledVariableHasVisibility(label,
+        VariableVisibility.CAPTURED_LOCAL);
   }
-  
+
   private void assertIsUncapturedLocal(String label) {
-    assertLabeledVariableHasVisibility(label, 
-        VariableVisibility.LOCAL); 
+    assertLabeledVariableHasVisibility(label,
+        VariableVisibility.LOCAL);
   }
-  
+
   private void assertIsGlobal(String label) {
-    assertLabeledVariableHasVisibility(label, 
-        VariableVisibility.GLOBAL); 
+    assertLabeledVariableHasVisibility(label,
+        VariableVisibility.GLOBAL);
   }
-  
+
   private void assertIsParameter(String parameterName) {
     Node parameterNode = searchForParameter(parameterName);
-    
+
     assertNotNull(parameterNode);
-    
+
     assertEquals(VariableVisibility.PARAMETER,
         lastAnalysis.getVariableVisibility(parameterNode));
   }
-  
+
   private VariableVisibilityAnalysis analyze(String src) {
     testSame(src);
-    
+
     return lastAnalysis;
   }
-  
+
   /*
    * Finds a parameter NAME node with the given name in the source AST.
-   * 
+   *
    * Behavior is undefined if there are multiple parameters with
    * parameterName.
    */
   private Node searchForParameter(final String parameterName) {
     Preconditions.checkArgument(parameterName != null);
-    
+
     final Node[] foundNode = new Node[1];
-    
+
     AbstractPostOrderCallback findParameter = new AbstractPostOrderCallback() {
-      
+
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
         if (n.getParent().getType() == Token.LP
             && parameterName.equals(n.getString())) {
-          
+
           foundNode[0] = n;
         }
       }
-    }; 
-      
+    };
+
     new NodeTraversal(lastCompiler, findParameter)
         .traverse(lastCompiler.jsRoot);
-    
+
     return foundNode[0];
   }
 
   /*
    * Finds a function node with the given name in the source AST.
-   * 
+   *
    * Behavior is undefined if there are multiple functions with
    * parameterName.
    */
   private Node searchForFunction(final String functionName) {
     Preconditions.checkArgument(functionName != null);
-    
+
     final Node[] foundNode = new Node[1];
-    
+
     AbstractPostOrderCallback findFunction = new AbstractPostOrderCallback() {
-      
+
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
         if (NodeUtil.isFunction(n)
-            && functionName.equals(NodeUtil.getFunctionName(n))) { 
+            && functionName.equals(NodeUtil.getFunctionName(n))) {
           foundNode[0] = n;
         }
       }
-    }; 
-      
+    };
+
     new NodeTraversal(lastCompiler, findFunction)
         .traverse(lastCompiler.jsRoot);
-    
+
     return foundNode[0];
   }
-  
+
   // Shamelessly stolen from NameReferenceGraphConstructionTest
   private Node searchLabel(String label) {
     LabeledVariableSearcher s = new LabeledVariableSearcher(label);
-      
+
     new NodeTraversal(lastCompiler, s).traverse(lastCompiler.jsRoot);
     assertNotNull("Label " + label + " should be in the source code", s.found);
-    
+
     return s.found;
   }
-  
+
   /**
    * Quick traversal to find a given labeled variable in the AST.
-   * 
+   *
    * Finds the variable for foo in:
    * foo: var a = ...
    */
@@ -237,11 +237,11 @@ public class VariableVisibilityAnalysisTest extends CompilerTestCase {
     public void visit(NodeTraversal t, Node n, Node parent) {
       if (n.getType() == Token.LABEL &&
           target.equals(n.getFirstChild().getString())) {
-        
+
         // LABEL
         //     VAR
         //       NAME
-        
+
         found = n.getLastChild();
       }
     }
diff --git a/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java b/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java
index 97ba83f8..4a28114c 100644
--- a/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java
+++ b/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java
@@ -28,7 +28,7 @@ import java.util.Iterator;
 
 /**
  * Tests for {@link JsFunctionParser}
- * 
+ *
  * @author agrieve@google.com (Andrew Grieve)
  * @author ielashi@google.com (Islam El-Ashi)
  */
@@ -60,7 +60,8 @@ public class JsFunctionParserTest extends TestCase {
       + "/* blah */goog.provide(\"yes2\")/* blah*/\n"
       + "goog.require('yes3'); // goog.provide('no3');\n"
       + "// goog.provide('no4');\n"
-      + "goog.require(\"bar.data.SuperstarAddStarThreadActionRequestDelegate\"); "
+      + "goog.require(\""
+      + "bar.data.SuperstarAddStarThreadActionRequestDelegate\"); "
       + "//no new line at eof";
 
     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);
@@ -69,19 +70,20 @@ public class JsFunctionParserTest extends TestCase {
     SymbolInfo symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes1");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes2");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes3");
     assertEquals(symbolInfo.functionName, "goog.require");
-    
+
     symbolInfo = i.next();
-    assertEquals(symbolInfo.symbol, "bar.data.SuperstarAddStarThreadActionRequestDelegate");
+    assertEquals(symbolInfo.symbol,
+        "bar.data.SuperstarAddStarThreadActionRequestDelegate");
     assertEquals(symbolInfo.functionName, "goog.require");
-    
+
     assertEquals(symbols.size(), 4);
     assertEquals(0, errorManager.getErrorCount());
     assertEquals(0, errorManager.getWarningCount());
@@ -92,20 +94,20 @@ public class JsFunctionParserTest extends TestCase {
         + "goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');";
 
     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);
-    
+
     Iterator<SymbolInfo> i = symbols.iterator();
     SymbolInfo symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes1");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes2");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes3");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     assertEquals(symbols.size(), 3);
     assertEquals(0, errorManager.getErrorCount());
     assertEquals(0, errorManager.getWarningCount());
@@ -120,16 +122,16 @@ public class JsFunctionParserTest extends TestCase {
         + "goog.provide('no1');";
 
     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);
-    
+
     Iterator<SymbolInfo> i = symbols.iterator();
     SymbolInfo symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes1");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes2");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     assertEquals(symbols.size(), 2);
     assertEquals(0, errorManager.getErrorCount());
     assertEquals(0, errorManager.getWarningCount());
@@ -139,14 +141,14 @@ public class JsFunctionParserTest extends TestCase {
     final String CONTENTS = "/** goog.provide('no1'); \n" +
         " * goog.provide('no2');\n */\n"
         + "goog.provide('yes1');\n";
-    
+
     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);
-    
+
     Iterator<SymbolInfo> i = symbols.iterator();
     SymbolInfo symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes1");
     assertEquals(symbolInfo.functionName, "goog.provide");
-    
+
     assertEquals(symbols.size(), 1);
     assertEquals(0, errorManager.getErrorCount());
     assertEquals(0, errorManager.getWarningCount());
@@ -156,9 +158,9 @@ public class JsFunctionParserTest extends TestCase {
     final String CONTENTS = "/**\n" +
         " * goog.provide('no1');\n */\n"
         + "goog.provide('yes1');\n";
-    
+
     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);
-    
+
     Iterator<SymbolInfo> i = symbols.iterator();
     SymbolInfo symbolInfo = i.next();
     assertEquals(symbolInfo.symbol, "yes1");
diff --git a/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java b/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java
index 9f18d8ea..c8bc6633 100644
--- a/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java
+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java
@@ -565,7 +565,7 @@ public class JsonMLValidationTest extends TestCase {
             "['DataProp',{'name':'y'}," +
                 "['LiteralExpr',{'type':'number','value':2}]]]");
     // wrong types of children
-    TagType[] tags = 
+    TagType[] tags =
         {TagType.DataProp, TagType.GetterProp, TagType.SetterProp };
     testWrongChildTypeValidation("" +
         "['ObjectExpr',{}," +
diff --git a/test/com/google/javascript/rhino/JSDocInfoTest.java b/test/com/google/javascript/rhino/JSDocInfoTest.java
index f70ac682..badd7b39 100644
--- a/test/com/google/javascript/rhino/JSDocInfoTest.java
+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java
@@ -428,7 +428,7 @@ public class JSDocInfoTest extends TestCase {
     info = new JSDocInfo(true);
     info.setModifies(Sets.newHashSet("arguments"));
     assertEquals(Sets.newHashSet("arguments"), info.getModifies());
-  }  
+  }
 
   /** Gets the type expression for a simple type name. */
   private JSTypeExpression fromString(String s) {
diff --git a/test/com/google/javascript/rhino/TokenStreamTest.java b/test/com/google/javascript/rhino/TokenStreamTest.java
index 11b3f3de..dc69e4f9 100644
--- a/test/com/google/javascript/rhino/TokenStreamTest.java
+++ b/test/com/google/javascript/rhino/TokenStreamTest.java
@@ -409,7 +409,7 @@ public class TokenStreamTest extends TestCase {
     testJSDocTokenStream("@param { Object = }*/", tokens, strings);
     testJSDocTokenStream("@param {Object=  }*/", tokens, strings);
   }
-  
+
   public void testJSDocLinenoCharno1() throws Exception {
     TokenStream stream = stream(" * @type {string}\n  *   @private");
     testNextJSDocTokenPosition(stream, STAR, 0, 1);
