is_addition,old_file_path,new_file_path,line_num,content
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,27,mport com.google.common.collect.HashMultiset;
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,29,mport com.google.common.collect.ImmutableMultiset;
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,32,mport com.google.common.collect.Multiset;
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,786,** Gets the number of times each variable has been assigned. */
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,787,ultiset<String> getAssignedNameCounts();
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,828,Override
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,829,ublic Multiset<String> getAssignedNameCounts() {
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,830,eturn ImmutableMultiset.of();
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,839,rivate final Multiset<String> assignedVarNames = HashMultiset.create();
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,896,Override
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,897,ublic Multiset<String> getAssignedNameCounts() {
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,898,eturn assignedVarNames;
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,901,oid recordAssignedName(String name) {
False,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,902,ssignedVarNames.add(name);
False,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1915, Returns whether this is a bleeding function (an anonymous named function
False,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1916, that bleeds into the inner scope).
False,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1918,tatic boolean isBleedingFunctionName(Node n) {
False,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1919,eturn n.isName() && !n.getString().isEmpty() &&
False,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1920,sFunctionExpression(n.getParent());
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,123,** @see isMarkedEscaped */
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,126,** @see isMarkedAssignedExactlyOnce */
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,127,rivate boolean markedAssignedExactlyOnce = false;
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,192, that bleeds into the inner scope).
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,188,* that bleeds into the inner scope.
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,341, Record that this is escaped by an inner scope.
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,343," In other words, it's assigned in an inner scope so that it's much harder"
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,344, to make assertions about its value at a given point.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,336,/** Record that this is escaped by an inner scope. */
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,359, Record that this is assigned exactly once..
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,361," In other words, it's assigned in an inner scope so that it's much harder"
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,362, to make assertions about its value at a given point.
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,364,oid markAssignedExactlyOnce() {
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,365,arkedAssignedExactlyOnce = true;
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,369, Whether this is assigned exactly once.
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,370, Notice that not all scope creators record this information.
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,372,oolean isMarkedAssignedExactlyOnce() {
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,373,eturn markedAssignedExactlyOnce;
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,554,ublic Var getSlot(String name) {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,527,public StaticSlot<JSType> getSlot(String name) {
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,559,ublic Var getOwnSlot(String name) {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,532,public StaticSlot<JSType> getOwnSlot(String name) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,612,"/ 1) The var is escaped and assigned in an inner scope, e.g.,"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,612,"// 1) The var is escaped in a weird way, e.g.,"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,619,"/ inferred variable. That variable is assigned more than once,"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,620,/ and we can't know which type we're getting.
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,622,/ var t = null; function f() { (t); } doStuff(); t = {};
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,624,"/ Notice that this heuristic isn't perfect. For example, you might"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,625,/ have:
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,627,/ function f() { (t); } f(); var t = 3;
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,629,"/ In this case, we would infer the first reference to t as"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,630,"/ type {number}, even though it's undefined."
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,631,oolean nonLocalInferredSlot = false;
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,632,f (isInferred && syntacticScope.isLocal()) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,633,ar maybeOuterVar = syntacticScope.getParent().getVar(varName);
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,634,f (var == maybeOuterVar &&
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,635,maybeOuterVar.isMarkedAssignedExactlyOnce()) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,636,onLocalInferredSlot = true;
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,619,// inferred variable.
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,620,// var t = null; function f() { (t); }
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,621,boolean nonLocalInferredSlot =
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,622,isInferred &&
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,623,syntacticScope.getParent() != null &&
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,624,var == syntacticScope.getParent().getSlot(varName);
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,54,mport com.google.common.collect.Multiset;
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1876,or (Multiset.Entry<String> entry :
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1877,ontents.getAssignedNameCounts().entrySet()) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1878,ar v = scope.getVar(entry.getElement());
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1879,reconditions.checkState(v.getScope() == scope);
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1880,f (entry.getCount() == 1) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1881,.markAssignedExactlyOnce();
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1994,f (t.getScopeDepth() <= 1) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1995,/ The first-order function analyzer looks at two types of variables:
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1997,"/ 1) Local variables that are assigned in inner scopes (""escaped vars"")"
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1999,/ 2) Local variables that are assigned more than once.
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1984,if (t.getScopeDepth() <= 2) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1985,// We only need to worry about escaped variables at depth 3.
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1986,"// An variable escaped at depth 2 is, by definition, a global variable."
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2006,f (n.isName() && NodeUtil.isLValue(n) &&
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2007,"/ Be careful of bleeding functions, which create variables"
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2008,"/ in the inner scope, not the scope where the name appears."
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2009,NodeUtil.isBleedingFunctionName(n)) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1992,if (n.isName() && NodeUtil.isLValue(n)) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2015,f (ownerScope.isLocal()) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2016,ata.get(ownerScope.getRootNode()).recordAssignedName(name);
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5976,ublic void testIssue726() throws Exception {
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5977,estTypes(
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5978,"/** @constructor */ function Foo() {}"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5979,"/** @param {number} x */ Foo.prototype.bar = function(x) {};"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5980,"/** @return {!Function} */ "" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5981,"Foo.prototype.getDeferredBar = function() { "" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5982,"  var self = this;"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5983,"  return function() {"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5984,"    self.bar(true);"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5987,"actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5988,"found   : boolean\n"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5989,"required: number"");"
