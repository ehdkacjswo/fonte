is_addition,old_file_path,new_file_path,line_num,content
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,98,nt pt = parent.getType();
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,99,f (pt == Token.COMMA) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,100,ode gramps = parent.getParent();
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,101,f (gramps.isCall() &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,102,arent == gramps.getFirstChild()) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,103,"/ Semantically, a direct call to eval is different from an indirect"
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,104,/ call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,105,/ expression to a comma to be a no-op if it's used to indirect
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,106,/ an eval.
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,107,f (n == parent.getFirstChild() &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,108,arent.getChildCount() == 2 &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,109,.getNext().isName() &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,110,"eval"".equals(n.getNext().getString())) {"
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,111,eturn;
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,98,// Do not try to remove a block or an expr result. We already handle
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,99,"// these cases when we visit the child, and the peephole passes will"
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,100,// fix up the tree in more clever ways when these are removed.
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,101,if (n.isExprResult() || n.isBlock()) {
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,102,return;
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,115,f (n == parent.getLastChild()) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,116,or (Node an : parent.getAncestors()) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,117,nt ancestorType = an.getType();
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,118,f (ancestorType == Token.COMMA)
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,119,ontinue;
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,120,f (ancestorType != Token.EXPR_RESULT &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,121,ncestorType != Token.BLOCK)
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,122,eturn;
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,123,lse
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,124,reak;
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,127, else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,128,f (pt == Token.FOR && parent.getChildCount() == 4 &&
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,129,n == parent.getFirstChild() ||
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,130, == parent.getFirstChild().getNext().getNext())) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,131,/ Fall through and look for warnings for the 1st and 3rd child
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,132,/ of a for.
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,133, else {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,134,eturn;  // it might be OK to not have a side-effect
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,105,// This no-op statement was there so that JSDoc information could
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,106,// be attached to the name. This check should not complain about it.
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,107,if (n.isQualifiedName() && n.getJSDocInfo() != null) {
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,108,return;
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,111,boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,139,f (isSimpleOp ||
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,140,"NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {"
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,141,f (n.isQualifiedName() && n.getJSDocInfo() != null) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,142,/ This no-op statement was there so that JSDoc information could
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,143,/ be attached to the name. This check should not complain about it.
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,144,eturn;
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,145, else if (n.isExprResult()) {
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,146,/ we already reported the problem when we visited the child.
False,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,147,eturn;
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,113,if (!isResultUsed &&
True,src/com/google/javascript/jscomp/CheckSideEffects.java,src/com/google/javascript/jscomp/CheckSideEffects.java,114,"(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {"
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3114,case Token.BLOCK:
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3123,Node gramps = parent.getParent();
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3124,if (gramps.isCall() &&
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3125,parent == gramps.getFirstChild()) {
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3126,"// Semantically, a direct call to eval is different from an indirect"
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3127,// call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3128,// expression to a comma to be a no-op if it's used to indirect
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3129,"// an eval. This we pretend that this is ""used""."
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3130,if (expr == parent.getFirstChild() &&
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3131,parent.getChildCount() == 2 &&
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3132,expr.getNext().isName() &&
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3133,"""eval"".equals(expr.getNext().getString())) {"
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,3134,return true;
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,71,"test(""var a, b; a = (bar(), 6, 7)"","
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,72,"""var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)"", e);"
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,73,"test(""var a, b; a = (bar(), bar(), 7, 8)"","
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,74,"""var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)"", e);"
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,90,"test(""for(foo(); true; (1, bar())) { bar() }"","
True,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,test/com/google/javascript/jscomp/CheckSideEffectsTest.java,91,"""for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }"", e);"
