is_addition,old_file_path,new_file_path,line_num,content
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,147,f (savedFieldsCount == savedFields.length) {
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,148,avedField[] newArray = new SavedField[savedFieldsCount * 2];
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,147,if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,148,// Expand capacity or merely copy if saved fields are shared.
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,149,SavedField[] newArray = new SavedField
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,150,[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,152, else if (iSavedFieldsShared) {
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,153,SavedFields = savedFields = (SavedField[])savedFields.clone();
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,154,SavedFieldsShared = false;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,207,"rrays.sort(savedFields, 0, count);"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,206,"sort(savedFields, count);"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,228,"* Sorts elements [0,high). Calling java.util.Arrays isn't always the right"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,229,"* choice since it always creates an internal copy of the array, even if it"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,230,"* doesn't need to. If the array slice is small enough, an insertion sort"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,231,"* is chosen instead, but it doesn't need a copy!"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,232,* <p>
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,233,"* This method has a modified version of that insertion sort, except it"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,234,"* doesn't create an unnecessary array copy. If high is over 10, then"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,235,"* java.util.Arrays is called, which will perform a merge sort, which is"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,236,* faster than insertion sort on large lists.
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,237,* <p>
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,238,* The end result is much greater performace when computeMillis is called.
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,239,"* Since the amount of saved fields is small, the insertion sort is a"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,240,* better choice. Additional performance is gained since there is no extra
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,241,"* array allocation and copying. Also, the insertion sort here does not"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,242,* perform any casting operations. The version in java.util.Arrays performs
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,243,* casts within the insertion sort loop.
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,245,"private static void sort(Comparable[] array, int high) {"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,246,if (high > 10) {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,247,"Arrays.sort(array, 0, high);"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,248,} else {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,249,for (int i=0; i<high; i++) {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,250,for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,251,Comparable t = array[j];
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,252,array[j] = array[j-1];
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,253,array[j-1] = t;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,300,ateTimeParserBucket.this.iSavedFieldsShared = true;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,307,ateTimeParserBucket.this.iZone = this.iZone;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,308,ateTimeParserBucket.this.iOffset = this.iOffset;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,309,ateTimeParserBucket.this.iSavedFields = this.iSavedFields;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,310,ateTimeParserBucket.this.iSavedFieldsCount = this.iSavedFieldsCount;
False,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,311,ateTimeParserBucket.this.iSavedFieldsShared = true;
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,337,enclosing.iZone = this.iZone;
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,338,enclosing.iOffset = this.iOffset;
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,339,enclosing.iSavedFields = this.iSavedFields;
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,340,if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,341,"// Since count is being restored to a lower count, the"
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,342,// potential exists for new saved fields to destroy data being
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,343,// shared by another state. Set this flag such that the array
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,344,// of saved fields is cloned prior to modification.
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,345,enclosing.iSavedFieldsShared = true;
True,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java,347,enclosing.iSavedFieldsCount = this.iSavedFieldsCount;
