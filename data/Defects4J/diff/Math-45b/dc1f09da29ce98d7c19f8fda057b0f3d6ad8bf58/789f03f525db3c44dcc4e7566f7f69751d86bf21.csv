is_addition,old_file_path,new_file_path,line_num,content
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,22,import java.util.Collections;
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,196,inal List<T> pointSet = new ArrayList<T>(points);
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,197,"// Convert to list for indexed access. Make it unmodifiable, since removal of items"
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,198,// would screw up the logic of this method.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,199,final List<T> pointList = Collections.unmodifiableList(new ArrayList<T> (points));
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,201,// The number of points in the list.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,202,final int numPoints = pointList.size();
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,204,// Set the corresponding element in this array to indicate when
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,205,// elements of pointList are no longer available.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,206,final boolean[] taken = new boolean[numPoints];
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,208,// The resulting list of initial centers.
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,200,inal T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,212,final int firstPointIndex = random.nextInt(numPoints);
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,214,final T firstPoint = pointList.get(firstPointIndex);
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,203,inal double[] dx2 = new double[pointSet.size()];
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,218,// Must mark it as taken
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,219,taken[firstPointIndex] = true;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,221,// To keep track of the minimum distance squared of elements of
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,222,// pointList to elements of resultSet.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,223,final double[] minDistSquared = new double[numPoints];
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,225,"// Initialize the elements.  Since the only point in resultSet is firstPoint,"
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,226,// this is very easy.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,227,for (int i = 0; i < numPoints; i++) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,228,if (i != firstPointIndex) { // That point isn't considered
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,229,double d = firstPoint.distanceFrom(pointList.get(i));
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,230,minDistSquared[i] = d*d;
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,205,"/ For each data point x, compute D(x), the distance between x and"
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,206,/ the nearest center that has already been chosen.
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,207,ouble sum = 0;
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,208,or (int i = 0; i < pointSet.size(); i++) {
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,209,inal T p = pointSet.get(i);
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,210,"nt nearestClusterIndex = getNearestCluster(resultSet, p);"
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,211,inal Cluster<T> nearest = resultSet.get(nearestClusterIndex);
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,212,inal double d = p.distanceFrom(nearest.getCenter());
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,213,um += d * d;
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,214,x2[i] = sum;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,236,// Sum up the squared distances for the points in pointList not
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,237,// already taken.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,238,double distSqSum = 0.0;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,240,for (int i = 0; i < numPoints; i++) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,241,if (!taken[i]) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,242,distSqSum += minDistSquared[i];
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,219,inal double r = random.nextDouble() * sum;
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,220,or (int i = 0 ; i < dx2.length; i++) {
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,221,f (dx2[i] >= r) {
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,222,inal T p = pointSet.remove(i);
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,223,esultSet.add(new Cluster<T>(p));
False,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,224,reak;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,248,final double r = random.nextDouble() * distSqSum;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,250,// The index of the next point to be added to the resultSet.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,251,int nextPointIndex = -1;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,253,"// Sum through the squared min distances again, stopping when"
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,254,// sum >= r.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,255,double sum = 0.0;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,256,for (int i = 0; i < numPoints; i++) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,257,if (!taken[i]) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,258,sum += minDistSquared[i];
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,259,if (sum >= r) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,260,nextPointIndex = i;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,261,break;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,266,"// If it's not set to >= 0, the point wasn't found in the previous"
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,267,"// for loop, probably because distances are extremely small.  Just pick"
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,268,// the last available point.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,269,if (nextPointIndex == -1) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,270,for (int i = numPoints - 1; i >= 0; i--) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,271,if (!taken[i]) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,272,nextPointIndex = i;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,273,break;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,278,// We found one.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,279,if (nextPointIndex >= 0) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,281,final T p = pointList.get(nextPointIndex);
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,283,resultSet.add(new Cluster<T> (p));
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,285,// Mark it as taken.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,286,taken[nextPointIndex] = true;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,288,if (resultSet.size() < k) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,289,// Now update elements of minDistSquared.  We only have to compute
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,290,// the distance to the new center to do this.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,291,for (int j = 0; j < numPoints; j++) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,292,// Only have to worry about the points still not taken.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,293,if (!taken[j]) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,294,double d = p.distanceFrom(pointList.get(j));
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,295,double d2 = d * d;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,296,if (d2 < minDistSquared[j]) {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,297,minDistSquared[j] = d2;
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,303,} else {
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,304,// None found --
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,305,// Break from the while loop to prevent
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,306,// an infinite loop.
True,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,307,break;
