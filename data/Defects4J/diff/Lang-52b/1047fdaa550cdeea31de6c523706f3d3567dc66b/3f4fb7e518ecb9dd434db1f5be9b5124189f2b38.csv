is_addition,old_file_path,new_file_path,line_num,content
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,85," @version $Id: MethodUtils.java,v 1.8 2002/11/21 19:38:51 rdonkin Exp $"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,86,"* @version $Id: MethodUtils.java,v 1.9 2002/12/10 19:06:49 rdonkin Exp $"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,121,* Gets a Method by name. The method must be public.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,122,* Superclasses will be considered.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,124,"* @param cls  the class to reflect, must not be null"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,125,* @param methodName  the field name to obtain
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,126,* @return the Method object
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,127,* @throws IllegalArgumentException if the class or method name is null
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,128,* @throws ReflectionException if an error occurs during reflection
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,130,"public static Method getMethod(Class cls, String methodName, Class paramType) {"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,131,Class[] paramTypes = {paramType};
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,132,"return getMethod(cls, methodName, paramTypes);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,176,"eturn cls.getMethod(methodName, paramTypes);"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,192,// apply workarounds
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,193,Method method = null;
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,194,try {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,196,"method = cls.getMethod(methodName, paramTypes);"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,198,} catch(NoSuchMethodException e) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,199,// swallow
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,202,if (method == null) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,203,// use the same as beanutils for the moment
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,204,"Method[] compatibles = getCompatibleMethods(cls, methodName, paramTypes);"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,205,if (compatibles.length > 0) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,206,method = compatibles[0];
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,209,return getMethod(method);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,224,"* <p>Return an accessible method (that is, one that can be invoked via"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,225,* reflection) that implements the specified Method.  If no such method
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,226,"* can be found, return <code>null</code>.</p>"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,228,* @param method The method that we wish to call
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,230,public static Method getMethod(Method method) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,232,Method accessibleMethod = getAccessibleMethod(method);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,233,if (accessibleMethod == null) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,234,try {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,236,// XXX Default access superclass workaround
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,238,// When a public class has a default access superclass
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,239,"// with public methods, these methods are accessible."
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,240,// Calling them from compiled code works fine.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,242,"// Unfortunately, using reflection to invoke these methods"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,243,// seems to (wrongly) to prevent access even when the method
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,244,// modifer is public.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,246,// The following workaround solves the problem but will only
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,247,// work from sufficiently privilages code.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,249,// Better workarounds would be greatfully accepted.
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,251,if (ReflectionUtils.isPublicScope(method)) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,252,method.setAccessible(true);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,253,accessibleMethod = method;
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,256,} catch (SecurityException se) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,257,// log but continue just in case the method.invoke works anyway
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,258,log(
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,259,"""Cannot setAccessible on method. Therefore cannot use jvm access bug workaround."","
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,260,se);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,263,return (accessibleMethod);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,306,ethod method = getMatchingAccessibleMethod(
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,383,Method method = getMethod(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,334," <p>Return an accessible method (that is, one that can be invoked via"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,335, reflection) with given name and a single parameter.  If no such method
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,336," can be found, return <code>null</code>."
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,337," Basically, a convenience wrapper that constructs a <code>Class</code>"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,338, array for you.</p>
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,340, @param clazz get method from this class
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,341, @param methodName get method with this name
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,342, @param parameterType taking this type of parameter
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,344,ublic static Method getAccessibleMethod(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,345,"lass clazz,"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,346,"tring methodName,"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,347,lass parameterType) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,349,lass[] parameterTypes = {parameterType};
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,350,"eturn getAccessibleMethod(clazz, methodName, parameterTypes);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,356," <p>Return an accessible method (that is, one that can be invoked via"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,357, reflection) with given name and parameters.  If no such method
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,358," can be found, return <code>null</code>."
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,359, This is just a convenient wrapper for
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,360, {@link #getAccessibleMethod(Method method)}.</p>
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,362, @param clazz get method from this class
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,363, @param methodName get method with this name
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,364, @param parameterTypes with these parameters types
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,366,ublic static Method getAccessibleMethod(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,367,"lass clazz,"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,368,"tring methodName,"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,369,lass[] parameterTypes) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,371,ry {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,372,eturn getAccessibleMethod
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,373,"clazz.getMethod(methodName, parameterTypes));"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,374, catch (NoSuchMethodException e) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,375,eturn (null);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,412,// -------------------------------------------------------- Private Methods
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,382," <p>Return an accessible method (that is, one that can be invoked via"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,383, reflection) that implements the specified Method.  If no such method
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,384," can be found, return <code>null</code>.</p>"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,386, @param method The method that we wish to call
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,388,ublic static Method getAccessibleMethod(Method method) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,414,private static Method getAccessibleMethod(Method method) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,423,"log(""Method is not public"");"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,430,"log(""Class is public"");"
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,434,if (debug) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,435,"log(""Method is in non-public class "" + clazz);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,418,/ -------------------------------------------------------- Private Methods
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,467,if (debug) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,468,"log(""Finding accessible method "" + methodName + "" from interface nest"");"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,473,f (method != null)
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,506,if (method != null) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,507,if (debug) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,508,"log(""Found method in class "" + method.getDeclaringClass());"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,483, <p>Find an accessible method that matches the given name and has compatible parameters.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,484, Compatible parameters mean that every method parameter is assignable from
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,485, the given parameters.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,486," In other words, it finds a method with the given name"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,487, that will take the parameters given.<p>
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,489, <p>This method is slightly undeterminstic since it loops
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,490, through methods names and return the first matching method.</p>
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,492, <p>This method is used by
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,493, {@link
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,494," #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}."
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,496, <p>This method can match primitive parameter by passing in wrapper classes.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,497," For example, a <code>Boolean</code> will match a primitive <code>boolean</code>"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,498, parameter.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,500, @param clazz find method in this class
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,501, @param methodName find method with this name
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,502, @param parameterTypes find method with compatible parameters
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,504,rivate static Method getMatchingAccessibleMethod(
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,517,private static Method[] getCompatibleMethods(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,513,/ see if we can find the method directly
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,514,/ most of the time this works and it's much faster
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,515,ry {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,516,"ethod method = clazz.getMethod(methodName, parameterTypes);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,517,f (debug) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,518,"og(""Found straight match: "" + method);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,519,"og(""isPublic:"" + Modifier.isPublic(method.getModifiers()));"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,522,ry {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,524,/ XXX Default access superclass workaround
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,526,/ When a public class has a default access superclass
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,527,"/ with public methods, these methods are accessible."
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,528,/ Calling them from compiled code works fine.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,530,"/ Unfortunately, using reflection to invoke these methods"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,531,/ seems to (wrongly) to prevent access even when the method
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,532,/ modifer is public.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,534,/ The following workaround solves the problem but will only
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,535,/ work from sufficiently privilages code.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,537,/ Better workarounds would be greatfully accepted.
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,539,ethod.setAccessible(true);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,541, catch (SecurityException se) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,542,/ log but continue just in case the method.invoke works anyway
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,543,og(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,544,"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround."","
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,545,e);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,547,eturn method;
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,549, catch (NoSuchMethodException e) { /* SWALLOW */ }
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,529,ArrayList compatibles = new ArrayList(methods.length);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,531,if (debug) {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,532,"log(""Checking: "" + methods[i]);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,558,"og(""Found matching name:"");"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,559,og(methods[i]);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,537,"log(""Found matching name:"" + methods[i]);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,566,ethod method = getAccessibleMethod(methods[i]);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,544,Method method = getMethod(methods[i]);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,568,f (debug) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,569,"og(method + "" accessible version of """
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,570, methods[i]);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,572,ry {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,574,/ XXX Default access superclass workaround
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,575,/ (See above for more details.)
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,577,ethod.setAccessible(true);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,579, catch (SecurityException se) {
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,580,/ log but continue just in case the method.invoke works anyway
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,581,og(
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,582,"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround."","
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,583,e);
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,585,eturn method;
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,546,compatibles.add(method);
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,547,} else {
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,548,"log(""Couldn't find accessible method for: "" + methods[i]);"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,588,"og(""Couldn't find accessible method."");"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,593,/ didn't find a match
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,594,"og(""No match found."");"
False,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,595,eturn null;
True,src/java/org/apache/commons/lang/reflect/MethodUtils.java,src/java/org/apache/commons/lang/reflect/MethodUtils.java,554,return (Method[]) compatibles.toArray(new Method[compatibles.size()]);
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,132,ethod method = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,132,Method method = MethodUtils.getMethod
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,144,ethod = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,144,method = MethodUtils.getMethod
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,158,ethod = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,158,method = MethodUtils.getMethod
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,481,ethod currentCounterMethod = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,481,Method currentCounterMethod = MethodUtils.getMethod
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,496,ethod incrementCounterMethod1 = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,496,Method incrementCounterMethod1 = MethodUtils.getMethod
False,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,511,ethod incrementCounterMethod2 = MethodUtils.getAccessibleMethod
True,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java,511,Method incrementCounterMethod2 = MethodUtils.getMethod
