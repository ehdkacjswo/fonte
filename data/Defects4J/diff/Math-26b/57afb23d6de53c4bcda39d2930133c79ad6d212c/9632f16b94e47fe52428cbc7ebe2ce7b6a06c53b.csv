is_addition,old_file_path,new_file_path,line_num,content
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,25,import org.apache.commons.math3.util.MathArrays;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,244,/ There are different ways to compute the quaternions elements
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,245,/ from the matrix. They all involve computing one element from
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,246,"/ the diagonal of the matrix, and computing the three other ones"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,247,"/ using a formula involving a division by the first element,"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,248,/ which unfortunately can be zero. Since the norm of the
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,249,"/ quaternion is 1, we know at least one element has an absolute"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,250,"/ value greater or equal to 0.5, so it is always possible to"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,251,/ select the right formula and avoid division by zero and even
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,252,/ numerical inaccuracy. Checking the elements in turn and using
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,253,/ the first one greater than 0.45 is safe (this leads to a simple
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,254,/ test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,255,ouble s = ort[0][0] + ort[1][1] + ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,256,f (s > -0.19) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,257,"/ compute q0 and deduce q1, q2 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,258,0 = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,259,ouble inv = 0.25 / q0;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,260,1 = inv * (ort[1][2] - ort[2][1]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,261,2 = inv * (ort[2][0] - ort[0][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,262,3 = inv * (ort[0][1] - ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,263, else {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,264, = ort[0][0] - ort[1][1] - ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,245,double[] quat = mat2quat(ort);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,246,q0 = quat[0];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,247,q1 = quat[1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,248,q2 = quat[2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,249,q3 = quat[3];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,253,/** Convert an orthogonal rotation matrix to a quaternion.
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,254,* @param ort orthogonal rotation matrix
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,255,* @return quaternion corresponding to the matrix
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,257,private static double[] mat2quat(final double[][] ort) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,259,final double[] quat = new double[4];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,261,// There are different ways to compute the quaternions elements
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,262,// from the matrix. They all involve computing one element from
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,263,"// the diagonal of the matrix, and computing the three other ones"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,264,"// using a formula involving a division by the first element,"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,265,// which unfortunately can be zero. Since the norm of the
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,266,"// quaternion is 1, we know at least one element has an absolute"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,267,"// value greater or equal to 0.5, so it is always possible to"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,268,// select the right formula and avoid division by zero and even
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,269,// numerical inaccuracy. Checking the elements in turn and using
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,270,// the first one greater than 0.45 is safe (this leads to a simple
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,271,// test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,272,double s = ort[0][0] + ort[1][1] + ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,266,"/ compute q1 and deduce q0, q2 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,267,1 = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,268,ouble inv = 0.25 / q1;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,269,0 = inv * (ort[1][2] - ort[2][1]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,270,2 = inv * (ort[0][1] + ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,271,3 = inv * (ort[0][2] + ort[2][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,274,"// compute q0 and deduce q1, q2 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,275,quat[0] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,276,double inv = 0.25 / quat[0];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,277,quat[1] = inv * (ort[1][2] - ort[2][1]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,278,quat[2] = inv * (ort[2][0] - ort[0][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,279,quat[3] = inv * (ort[0][1] - ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,273, = ort[1][1] - ort[0][0] - ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,274,f (s > -0.19) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,275,"/ compute q2 and deduce q0, q1 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,276,2 = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,277,ouble inv = 0.25 / q2;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,278,0 = inv * (ort[2][0] - ort[0][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,279,1 = inv * (ort[0][1] + ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,280,3 = inv * (ort[2][1] + ort[1][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,281, else {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,282,"/ compute q3 and deduce q0, q1 and q2"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,283, = ort[2][2] - ort[0][0] - ort[1][1];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,284,3 = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,285,ouble inv = 0.25 / q3;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,286,0 = inv * (ort[0][1] - ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,287,1 = inv * (ort[0][2] + ort[2][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,288,2 = inv * (ort[2][1] + ort[1][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,281,s = ort[0][0] - ort[1][1] - ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,282,if (s > -0.19) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,283,"// compute q1 and deduce q0, q2 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,284,quat[1] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,285,double inv = 0.25 / quat[1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,286,quat[0] = inv * (ort[1][2] - ort[2][1]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,287,quat[2] = inv * (ort[0][1] + ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,288,quat[3] = inv * (ort[0][2] + ort[2][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,289,} else {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,290,s = ort[1][1] - ort[0][0] - ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,291,if (s > -0.19) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,292,"// compute q2 and deduce q0, q1 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,293,quat[2] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,294,double inv = 0.25 / quat[2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,295,quat[0] = inv * (ort[2][0] - ort[0][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,296,quat[1] = inv * (ort[0][1] + ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,297,quat[3] = inv * (ort[2][1] + ort[1][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,298,} else {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,299,"// compute q3 and deduce q0, q1 and q2"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,300,s = ort[2][2] - ort[0][0] - ort[1][1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,301,quat[3] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,302,double inv = 0.25 / quat[3];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,303,quat[0] = inv * (ort[0][1] - ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,304,quat[1] = inv * (ort[0][2] + ort[2][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,305,quat[2] = inv * (ort[2][1] + ort[1][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,310,return quat;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,311, @exception MathIllegalArgumentException if the norm of one of the vectors is zero
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,330,"* @exception MathIllegalArgumentException if the norm of one of the vectors is zero,"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,331,* or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,313,"ublic Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,315,/ norms computation
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,316,ouble u1u1 = u1.getNormSq();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,317,ouble u2u2 = u2.getNormSq();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,318,ouble v1v1 = v1.getNormSq();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,319,ouble v2v2 = v2.getNormSq();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,320,f ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,321,hrow new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,324,/ normalize v1 in order to have (v1'|v1') = (u1|u1)
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,325,"1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,327,/ adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,328,ouble u1u2   = u1.dotProduct(u2);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,329,ouble v1v2   = v1.dotProduct(v2);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,330,ouble coeffU = u1u2 / u1u1;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,331,ouble coeffV = v1v2 / u1u1;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,332,ouble beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,333,ouble alpha  = coeffU - beta * coeffV;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,334,"2 = new Vector3D(alpha, v1, beta, v2);"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,336,/ preliminary computation
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,337,ector3D uRef  = u1;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,338,ector3D vRef  = v1;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,339,ector3D v1Su1 = v1.subtract(u1);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,340,ector3D v2Su2 = v2.subtract(u2);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,341,ector3D k     = v1Su1.crossProduct(v2Su2);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,342,ector3D u3    = u1.crossProduct(u2);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,343,ouble c       = k.dotProduct(u3);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,344,inal double inPlaneThreshold = 0.001;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,345,f (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,346,"/ the (q1, q2, q3) vector is close to the (u1, u2) plane"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,347,/ we try other vectors
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,348,"ector3D v3 = Vector3D.crossProduct(v1, v2);"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,349,ector3D v3Su3 = v3.subtract(u3);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,350, = v1Su1.crossProduct(v3Su3);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,351,ector3D u2Prime = u1.crossProduct(u3);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,352, = k.dotProduct(u2Prime);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,354,f (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,355,"/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,356,"/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,357, = v2Su2.crossProduct(v3Su3);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,358, = k.dotProduct(u2.crossProduct(u3));
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,360,f (c <= 0) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,361,"/ the (q1, q2, q3) vector is aligned with everything"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,362,/ this is really the identity rotation
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,363,0 = 1.0;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,364,1 = 0.0;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,365,2 = 0.0;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,366,3 = 0.0;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,367,eturn;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,370,/ we will have to use u2 and v2 to compute the scalar part
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,371,Ref = u2;
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,372,Ref = v2;
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,333,"public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,334,throws MathIllegalArgumentException {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,336,"// build orthonormalized base from u1, u2"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,337,"// this fails when vectors are null or colinear, which is forbidden to define a rotation"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,338,final Vector3D u3 = u1.crossProduct(u2).normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,339,u2 = u3.crossProduct(u1).normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,340,u1 = u1.normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,342,"// build an orthonormalized base from v1, v2"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,343,"// this fails when vectors are null or colinear, which is forbidden to define a rotation"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,344,final Vector3D v3 = v1.crossProduct(v2).normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,345,v2 = v3.crossProduct(v1).normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,346,v1 = v1.normalize();
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,348,// buid a matrix transforming the first base into the second one
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,349,final double[][] m = new double[][] {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,351,"MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,352,"MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,353,"MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,356,"MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,357,"MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,358,"MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,361,"MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,362,"MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,363,"MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,378,/ compute the vectorial part
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,379, = FastMath.sqrt(c);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,380,ouble inv = 1.0 / (c + c);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,381,1 = inv * k.getX();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,382,2 = inv * k.getY();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,383,3 = inv * k.getZ();
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,385,/ compute the scalar part
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,386," = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,387,"Ref.getZ() * q1 - uRef.getX() * q3,"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,388,Ref.getX() * q2 - uRef.getY() * q1);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,389,0 = vRef.dotProduct(k) / (2 * k.getNormSq());
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,367,double[] quat = mat2quat(m);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,368,q0 = quat[0];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,369,q1 = quat[1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,370,q2 = quat[2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,371,q3 = quat[3];
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,20,import org.apache.commons.math3.exception.MathArithmeticException;
False,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,144, catch (IllegalArgumentException e) {
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,145,} catch (MathArithmeticException e) {
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,521,@Test
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,522,public void testIssue801() {
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,523,"Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,524,"Vector3D u2 = new Vector3D(0.0, 0.0, 1.0);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,526,"Vector3D v1 = new Vector3D(0.9999999999999999, 0.0, 0.0);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,527,"Vector3D v2 = new Vector3D(0.0, 0.0, -1.0);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,529,"Rotation quat = new Rotation(u1, u2, v1, v2);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,530,double q2 = quat.getQ0() * quat.getQ0() +
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,531,quat.getQ1() * quat.getQ1() +
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,532,quat.getQ2() * quat.getQ2() +
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,533,quat.getQ3() * quat.getQ3();
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,534,"Assert.assertEquals(1.0, q2, 1.0e-14);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,535,"Assert.assertEquals(0.0, Vector3D.angle(v1, quat.applyTo(u1)), 1.0e-14);"
True,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java,536,"Assert.assertEquals(0.0, Vector3D.angle(v2, quat.applyTo(u2)), 1.0e-14);"
