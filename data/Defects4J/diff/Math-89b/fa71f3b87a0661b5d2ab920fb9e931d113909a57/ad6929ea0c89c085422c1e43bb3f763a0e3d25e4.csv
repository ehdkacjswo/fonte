is_addition,old_file_path,new_file_path,line_num,content
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,2,* Copyright 2003-2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,18,import java.io.Serializable;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,19,import org.apache.commons.math.MathException;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,22,"* Implements the <a href="""
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,23,"* ""http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html"">"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,24,* Divided Difference Algorithm</a> for interpolation of real univariate
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,25,"* functions. For reference, see <b>Introduction to Numerical Analysis</b>,"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,26,"* ISBN 038795452X, chapter 2."
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,27,* <p>
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,28,"* The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,29,* this class provides an easy-to-use interface to it.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,31,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,33,"public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,34,Serializable {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,36,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,37,static final long serialVersionUID = 107049519551235069L;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,40,* Computes an interpolating function for the data set.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,42,* @param x the interpolating points array
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,43,* @param y the interpolating values array
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,44,* @return a function which interpolates the data set
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,45,* @throws MathException if arguments are invalid
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,47,"public UnivariateRealFunction interpolate(double x[], double y[]) throws"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,48,MathException {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,51,* a[] and c[] are defined in the general formula of Newton form:
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,52,* p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,53,*        a[n](x-c[0])(x-c[1])...(x-c[n-1])
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,55,"double a[], c[];"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,57,"PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,60,"* When used for interpolation, the Newton form formula becomes"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,61,"* p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,62,"*        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,63,"* Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k]."
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,64,* <p>
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,65,"* Note x[], y[], a[] have the same length but c[]'s size is one less."
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,67,c = new double[x.length-1];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,68,for (int i = 0; i < c.length; i++) {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,69,c[i] = x[i];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,71,"a = computeDividedDifference(x, y);"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,73,PolynomialFunctionNewtonForm p;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,74,"p = new PolynomialFunctionNewtonForm(a, c);"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,75,return p;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,79,* Returns a copy of the divided difference array defined recursively by
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,80,* f[x0] = f(x0)
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,81,"* f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,82,* <p>
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,83,* The computational complexity is O(N^2).
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,85,* @return a fresh copy of the divided difference array
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,86,* @throws MathException if any abscissas coincide
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,88,"protected static double[] computeDividedDifference(double x[], double y[])"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,89,throws MathException {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,91,"int i, j, n;"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,92,"double divdiff[], a[], denominator;"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,94,"PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,96,n = x.length;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,97,divdiff = new double[n];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,98,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,99,divdiff[i] = y[i];      // initialization
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,102,a = new double [n];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,103,a[0] = divdiff[0];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,104,for (i = 1; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,105,for (j = 0; j < n-i; j++) {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,106,denominator = x[j+i] - x[j];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,107,if (denominator == 0.0) {
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,108,// This happens only when two abscissas are identical.
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,109,throw new MathException
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,110,"(""Identical abscissas cause division by zero."");"
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,112,divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,114,a[i] = divdiff[0];
True,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java,117,return a;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,2,* Copyright 2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,18,import org.apache.commons.math.ConvergenceException;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,19,import org.apache.commons.math.FunctionEvaluationException;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,20,import org.apache.commons.math.complex.*;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,23,"* Implements the <a href=""http://mathworld.wolfram.com/LaguerresMethod.html"">"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,24,* Laguerre's Method</a> for root finding of real coefficient polynomials.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,25,"* For reference, see <b>A First Course in Numerical Analysis</b>,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,26,"* ISBN 048641454X, chapter 8."
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,27,* <p>
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,28,* Laguerre's method is global in the sense that it can start with any initial
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,29,* approximation and be able to solve all roots from that point.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,31,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,33,public class LaguerreSolver extends UnivariateRealSolverImpl {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,35,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,36,static final long serialVersionUID = 5287689975005870178L;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,38,/** polynomial function to solve */
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,39,private PolynomialFunction p;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,42,* Construct a solver for the given function.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,44,* @param f function to solve
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,45,* @throws IllegalArgumentException if function is not polynomial
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,47,public LaguerreSolver(UnivariateRealFunction f) throws
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,48,IllegalArgumentException {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,50,"super(f, 100, 1E-6);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,51,if (f instanceof PolynomialFunction) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,52,p = (PolynomialFunction)f;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,53,} else {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,54,"throw new IllegalArgumentException(""Function is not polynomial."");"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,59,* Returns a copy of the polynomial function.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,61,* @return a fresh copy of the polynomial function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,63,public PolynomialFunction getPolynomialFunction() {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,64,return new PolynomialFunction(p.getCoefficients());
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,68,* Find a real root in the given interval with initial value.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,69,* <p>
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,70,* Requires bracketing condition.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,72,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,73,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,74,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,75,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,76,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,77,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,78,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,79,* function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,80,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,82,"public double solve(double min, double max, double initial) throws"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,83,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,85,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,86,if (p.value(min) == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,87,if (p.value(max) == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,88,if (p.value(initial) == 0.0) { return initial; }
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,90,"verifyBracketing(min, max, p);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,91,"verifySequence(min, initial, max);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,92,"if (isBracketing(min, initial, p)) {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,93,"return solve(min, initial);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,94,} else {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,95,"return solve(initial, max);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,100,* Find a real root in the given interval.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,101,* <p>
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,102,"* Despite the bracketing condition, the root returned by solve(Complex[],"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,103,"* Complex) may not be a real zero inside [min, max]. For example,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,104,"* p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,105,"* another initial value, or, as we did here, call solveAll() to obtain"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,106,* all roots and pick up the one that we're looking for.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,108,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,109,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,110,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,111,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,112,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,113,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,114,* function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,115,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,117,"public double solve(double min, double max) throws ConvergenceException,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,118,FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,120,"Complex c[], root[], initial, z;"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,122,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,123,if (p.value(min) == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,124,if (p.value(max) == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,125,"verifyBracketing(min, max, p);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,127,double coefficients[] = p.getCoefficients();
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,128,c = new Complex[coefficients.length];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,129,for (int i = 0; i < coefficients.length; i++) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,130,"c[i] = new Complex(coefficients[i], 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,132,"initial = new Complex(0.5 * (min + max), 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,133,"z = solve(c, initial);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,134,"if (isRootOK(min, max, z)) {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,135,"setResult(z.getReal(), iterationCount);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,136,return result;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,139,// solve all roots and select the one we're seeking
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,140,"root = solveAll(c, initial);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,141,for (int i = 0; i < root.length; i++) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,142,"if (isRootOK(min, max, root[i])) {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,143,"setResult(root[i].getReal(), iterationCount);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,144,return result;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,148,// should never happen
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,149,"throw new ConvergenceException(""Convergence failed."");"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,153,* Returns true iff the given complex root is actually a real zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,154,"* in the given interval, within the solver tolerance level."
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,156,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,157,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,158,* @param z the complex root
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,159,* @return true iff z is the sought-after real zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,161,"protected boolean isRootOK(double min, double max, Complex z) {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,162,"double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,163,"return (isSequence(min, z.getReal(), max)) &&"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,164,(Math.abs(z.getImaginary()) <= tolerance ||
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,165,z.abs() <= functionValueAccuracy);
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,169,"* Find all complex roots for the polynomial with the given coefficients,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,170,* starting from the given initial value.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,172,* @param coefficients the polynomial coefficients array
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,173,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,174,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,175,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,176,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,177,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,178,* function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,179,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,181,"public Complex[] solveAll(double coefficients[], double initial) throws"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,182,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,184,Complex c[] = new Complex[coefficients.length];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,185,"Complex z = new Complex(initial, 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,186,for (int i = 0; i < c.length; i++) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,187,"c[i] = new Complex(coefficients[i], 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,189,"return solveAll(c, z);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,193,"* Find all complex roots for the polynomial with the given coefficients,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,194,* starting from the given initial value.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,196,* @param coefficients the polynomial coefficients array
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,197,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,198,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,199,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,200,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,201,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,202,* function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,203,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,205,"public Complex[] solveAll(Complex coefficients[], Complex initial) throws"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,206,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,208,"int i, j, n, iterationCount = 0;"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,209,"Complex root[], c[], subarray[], oldc, newc;"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,211,n = coefficients.length - 1;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,212,if (n < 1) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,213,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,214,"(""Polynomial degree must be positive: degree="" + n);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,216,c = new Complex[n+1];    // coefficients for deflated polynomial
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,217,for (i = 0; i <= n; i++) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,218,c[i] = coefficients[i];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,221,// solve individual root successively
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,222,root = new Complex[n];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,223,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,224,subarray = new Complex[n-i+1];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,225,"System.arraycopy(c, 0, subarray, 0, subarray.length);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,226,"root[i] = solve(subarray, initial);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,227,// polynomial deflation using synthetic division
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,228,newc = c[n-i];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,229,for (j = n-i-1; j >= 0; j--) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,230,oldc = c[j];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,231,c[j] = newc;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,232,newc = oldc.add(newc.multiply(root[i]));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,234,iterationCount += this.iterationCount;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,237,resultComputed = true;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,238,this.iterationCount = iterationCount;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,239,return root;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,243,"* Find a complex root for the polynomial with the given coefficients,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,244,* starting from the given initial value.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,246,* @param coefficients the polynomial coefficients array
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,247,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,248,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,249,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,250,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,251,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,252,* function
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,253,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,255,"public Complex solve(Complex coefficients[], Complex initial) throws"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,256,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,258,"Complex z = initial, oldz, pv, dv, d2v, G, G2, H, delta, denominator;"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,260,int n = coefficients.length - 1;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,261,if (n < 1) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,262,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,263,"(""Polynomial degree must be positive: degree="" + n);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,265,"Complex N = new Complex((double)n, 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,266,"Complex N1 = new Complex((double)(n-1), 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,268,int i = 1;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,269,"oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,270,while (i <= maximalIterationCount) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,271,"// Compute pv (polynomial value), dv (derivative value), and"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,272,// d2v (second derivative value) simultaneously.
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,273,pv = coefficients[n];
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,274,"dv = d2v = new Complex(0.0, 0.0);"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,275,for (int j = n-1; j >= 0; j--) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,276,d2v = dv.add(z.multiply(d2v));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,277,dv = pv.add(z.multiply(dv));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,278,pv = coefficients[j].add(z.multiply(pv));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,280,"d2v = d2v.multiply(new Complex(2.0, 0.0));"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,282,// check for convergence
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,283,"double tolerance = Math.max(relativeAccuracy * z.abs(),"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,284,absoluteAccuracy);
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,285,if ((z.subtract(oldz)).abs() <= tolerance) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,286,resultComputed = true;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,287,iterationCount = i;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,288,return z;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,290,if (pv.abs() <= functionValueAccuracy) {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,291,resultComputed = true;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,292,iterationCount = i;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,293,return z;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,296,"// now pv != 0, calculate the new approximation"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,297,G = dv.divide(pv);
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,298,G2 = G.multiply(G);
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,299,H = G2.subtract(d2v.divide(pv));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,300,delta = N1.multiply((N.multiply(H)).subtract(G2));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,301,// choose a denominator larger in magnitude
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,302,Complex dplus = G.add(ComplexUtils.sqrt(delta));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,303,Complex dminus = G.subtract(ComplexUtils.sqrt(delta));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,304,denominator = dplus.abs() > dminus.abs() ? dplus : dminus;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,305,"// Perturb z if denominator is zero, for instance,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,306,"// p(x) = x^3 + 1, z = 0."
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,307,"if (denominator.equals(new Complex(0.0, 0.0))) {"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,308,"z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,309,"oldz = new Complex(Double.POSITIVE_INFINITY,"
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,310,Double.POSITIVE_INFINITY);
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,311,} else {
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,312,oldz = z;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,313,z = z.subtract(N.divide(denominator));
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,315,i++;
True,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,src/java/org/apache/commons/math/analysis/LaguerreSolver.java,317,"throw new ConvergenceException(""Maximum number of iterations exceeded."");"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,2,* Copyright 2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,18,import org.apache.commons.math.ConvergenceException;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,19,import org.apache.commons.math.FunctionEvaluationException;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,20,import org.apache.commons.math.util.MathUtils;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,23,"* Implements the <a href=""http://mathworld.wolfram.com/MullersMethod.html"">"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,24,* Muller's Method</a> for root finding of real univariate functions. For
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,25,"* reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,26,* chapter 3.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,27,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,28,"* Muller's method applies to both real and complex functions, but here we"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,29,* restrict ourselves to real functions. Methods solve() and solve2() find
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,30,"* real zeros, using different ways to bypass complex arithmetics."
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,32,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,34,public class MullerSolver extends UnivariateRealSolverImpl {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,36,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,37,static final long serialVersionUID = 2619993603551148137L;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,40,* Construct a solver for the given function.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,42,* @param f function to solve
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,44,public MullerSolver(UnivariateRealFunction f) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,45,"super(f, 100, 1E-6);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,49,* Find a real root in the given interval with initial value.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,50,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,51,* Requires bracketing condition.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,53,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,54,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,55,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,56,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,57,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,58,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,59,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,60,* function
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,61,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,63,"public double solve(double min, double max, double initial) throws"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,64,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,66,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,67,if (f.value(min) == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,68,if (f.value(max) == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,69,if (f.value(initial) == 0.0) { return initial; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,71,"verifyBracketing(min, max, f);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,72,"verifySequence(min, initial, max);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,73,"if (isBracketing(min, initial, f)) {"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,74,"return solve(min, initial);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,75,} else {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,76,"return solve(initial, max);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,81,* Find a real root in the given interval.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,82,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,83,* Original Muller's method would have function evaluation at complex point.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,84,"* Since our f(x) is real, we have to find ways to avoid that. Bracketing"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,85,"* condition is one way to go: by requiring bracketing in every iteration,"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,86,* the newly computed approximation is guaranteed to be real.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,87,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,88,* Normally Muller's method converges quadratically in the vicinity of a
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,89,"* zero, however it may be very slow in regions far away from zeros. For"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,90,"* example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,91,* bisection as a safety backup if it performs very poorly.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,92,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,93,* The formulas here use divided differences directly.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,95,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,96,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,97,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,98,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,99,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,100,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,101,* function
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,102,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,104,"public double solve(double min, double max) throws ConvergenceException,"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,105,FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,107,"// [x0, x2] is the bracketing interval in each iteration"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,108,"// x1 is the last approximation and an interpolation point in (x0, x2)"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,109,// x is the new root approximation and new x1 for next round
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,110,"// d01, d12, d012 are divided differences"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,111,"double x0, x1, x2, x, oldx, y0, y1, y2, y;"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,112,"double d01, d12, d012, c1, delta, xplus, xminus, tolerance;"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,114,x0 = min; y0 = f.value(x0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,115,x2 = max; y2 = f.value(x2);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,116,x1 = 0.5 * (x0 + x2); y1 = f.value(x1);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,118,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,119,if (y0 == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,120,if (y2 == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,121,"verifyBracketing(min, max, f);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,123,int i = 1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,124,oldx = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,125,while (i <= maximalIterationCount) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,126,// Muller's method employs quadratic interpolation through
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,127,"// x0, x1, x2 and x is the zero of the interpolating parabola."
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,128,"// Due to bracketing condition, this parabola must have two"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,129,"// real roots and we choose one in [x0, x2] to be x."
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,130,d01 = (y1 - y0) / (x1 - x0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,131,d12 = (y2 - y1) / (x2 - x1);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,132,d012 = (d12 - d01) / (x2 - x0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,133,c1 = d01 + (x1 - x0) * d012;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,134,delta = c1 * c1 - 4 * y1 * d012;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,135,xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,136,xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,137,// xplus and xminus are two roots of parabola and at least
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,138,"// one of them should lie in (x0, x2)"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,139,"x = isSequence(x0, xplus, x2) ? xplus : xminus;"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,140,y = f.value(x);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,142,// check for convergence
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,143,"tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,144,if (Math.abs(x - oldx) <= tolerance) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,145,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,146,return result;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,148,if (Math.abs(y) <= functionValueAccuracy) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,149,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,150,return result;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,153,// Bisect if convergence is too slow. Bisection would waste
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,154,"// our calculation of x, hopefully it won't happen often."
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,155,boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,156,(x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,157,(x == x1);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,158,// prepare the new bracketing interval for next iteration
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,159,if (!bisect) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,160,x0 = x < x1 ? x0 : x1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,161,y0 = x < x1 ? y0 : y1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,162,x2 = x > x1 ? x2 : x1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,163,y2 = x > x1 ? y2 : y1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,164,x1 = x; y1 = y;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,165,oldx = x;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,166,} else {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,167,double xm = 0.5 * (x0 + x2);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,168,double ym = f.value(xm);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,169,if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,170,x2 = xm; y2 = ym;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,171,} else {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,172,x0 = xm; y0 = ym;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,174,x1 = 0.5 * (x0 + x2);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,175,y1 = f.value(x1);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,176,oldx = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,178,i++;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,180,"throw new ConvergenceException(""Maximum number of iterations exceeded."");"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,184,* Find a real root in the given interval.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,185,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,186,* solve2() differs from solve() in the way it avoids complex operations.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,187,"* Except for the initial [min, max], solve2() does not require bracketing"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,188,"* condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,189,"* number arises in the computation, we simply use its modulus as real"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,190,* approximation.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,191,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,192,"* Because the interval may not be bracketing, bisection alternative is"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,193,* not applicable here. However in practice our treatment usually works
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,194,"* well, especially near real zeros where the imaginary part of complex"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,195,* approximation is often negligible.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,196,* <p>
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,197,* The formulas here do not use divided differences directly.
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,199,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,200,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,201,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,202,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,203,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,204,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,205,* function
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,206,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,208,"public double solve2(double min, double max) throws ConvergenceException,"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,209,FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,211,// x2 is the last root approximation
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,212,// x is the new approximation and new x2 for next round
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,213,// x0 < x1 < x2 does not hold here
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,214,"double x0, x1, x2, x, oldx, y0, y1, y2, y;"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,215,"double q, A, B, C, delta, denominator, tolerance;"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,217,x0 = min; y0 = f.value(x0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,218,x1 = max; y1 = f.value(x1);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,219,x2 = 0.5 * (x0 + x1); y2 = f.value(x2);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,221,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,222,if (y0 == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,223,if (y1 == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,224,"verifyBracketing(min, max, f);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,226,int i = 1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,227,oldx = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,228,while (i <= maximalIterationCount) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,229,"// quadratic interpolation through x0, x1, x2"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,230,q = (x2 - x1) / (x1 - x0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,231,A = q * (y2 - (1 + q) * y1 + q * y0);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,232,B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,233,C = (1 + q) * y2;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,234,delta = B * B - 4 * A * C;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,235,if (delta >= 0.0) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,236,// choose a denominator larger in magnitude
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,237,double dplus = B + Math.sqrt(delta);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,238,double dminus = B - Math.sqrt(delta);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,239,denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,240,} else {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,241,// take the modulus of (B +/- Math.sqrt(delta))
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,242,denominator = Math.sqrt(B * B - delta);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,244,if (denominator != 0) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,245,x = x2 - 2.0 * C * (x2 - x1) / denominator;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,246,// perturb x if it coincides with x1 or x2
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,247,while (x == x1 || x == x2) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,248,x += absoluteAccuracy;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,250,} else {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,251,"// extremely rare case, get a random number to skip it"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,252,x = min + Math.random() * (max - min);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,253,oldx = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,255,y = f.value(x);
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,257,// check for convergence
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,258,"tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,259,if (Math.abs(x - oldx) <= tolerance) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,260,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,261,return result;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,263,if (Math.abs(y) <= functionValueAccuracy) {
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,264,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,265,return result;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,268,// prepare the next iteration
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,269,x0 = x1; y0 = y1;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,270,x1 = x2; y1 = y2;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,271,x2 = x; y2 = y;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,272,oldx = x;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,273,i++;
True,src/java/org/apache/commons/math/analysis/MullerSolver.java,src/java/org/apache/commons/math/analysis/MullerSolver.java,275,"throw new ConvergenceException(""Maximum number of iterations exceeded."");"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,2,* Copyright 2003-2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,18,import java.io.Serializable;
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,19,import org.apache.commons.math.MathException;
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,22,"* Implements the <a href=""http://mathworld.wolfram.com/NevillesAlgorithm.html"">"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,23,* Neville's Algorithm</a> for interpolation of real univariate functions. For
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,24,"* reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,25,* chapter 2.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,26,* <p>
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,27,"* The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,28,* this class provides an easy-to-use interface to it.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,30,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,32,"public class NevilleInterpolator implements UnivariateRealInterpolator,"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,33,Serializable {
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,35,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,36,static final long serialVersionUID = 3003707660147873733L;
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,39,* Computes an interpolating function for the data set.
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,41,* @param x the interpolating points array
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,42,* @param y the interpolating values array
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,43,* @return a function which interpolates the data set
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,44,* @throws MathException if arguments are invalid
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,46,"public UnivariateRealFunction interpolate(double x[], double y[]) throws"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,47,MathException {
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,49,PolynomialFunctionLagrangeForm p;
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,50,"p = new PolynomialFunctionLagrangeForm(x, y);"
True,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,src/java/org/apache/commons/math/analysis/NevilleInterpolator.java,51,return p;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,2,* Copyright 2003-2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,18,import java.io.Serializable;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,19,import org.apache.commons.math.FunctionEvaluationException;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,22,* Implements the representation of a real polynomial function in
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,23,"* <a href=""http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html"">"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,24,"* Lagrange Form</a>. For reference, see <b>Introduction to Numerical"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,25,"* Analysis</b>, ISBN 038795452X, chapter 2."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,26,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,27,* The approximated function should be smooth enough for Lagrange polynomial
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,28,"* to work well. Otherwise, consider using splines instead."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,30,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,32,"public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,33,Serializable {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,35,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,36,static final long serialVersionUID = -3965199246151093920L;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,39,"* The coefficients of the polynomial, ordered by degree -- i.e."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,40,* coefficients[0] is the constant term and coefficients[n] is the
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,41,* coefficient of x^n where n is the degree of the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,43,private double coefficients[];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,46,* Interpolating points (abscissas) and the function values at these points.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,48,"private double x[], y[];"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,51,* Whether the polynomial coefficients are available.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,53,private boolean coefficientsComputed;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,56,* Construct a Lagrange polynomial with the given abscissas and function
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,57,* values. The order of interpolating points are not important.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,58,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,59,* The constructor makes copy of the input arrays and assigns them.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,61,* @param x interpolating points
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,62,* @param y function values at interpolating points
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,63,* @throws IllegalArgumentException if input arrays are not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,65,"PolynomialFunctionLagrangeForm(double x[], double y[]) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,66,IllegalArgumentException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,68,"verifyInterpolationArray(x, y);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,69,this.x = new double[x.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,70,this.y = new double[y.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,71,"System.arraycopy(x, 0, this.x, 0, x.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,72,"System.arraycopy(y, 0, this.y, 0, y.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,73,coefficientsComputed = false;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,77,* Calculate the function value at the given point.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,79,* @param z the point at which the function value is to be computed
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,80,* @return the function value
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,81,* @throws FunctionEvaluationException if a runtime error occurs
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,82,* @see UnivariateRealFunction#value(double)
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,84,public double value(double z) throws FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,85,"return evaluate(x, y, z);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,89,* Returns the degree of the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,91,* @return the degree of the polynomial
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,93,public int degree() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,94,return x.length - 1;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,98,* Returns a copy of the interpolating points array.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,99,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,100,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,102,* @return a fresh copy of the interpolating points array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,104,public double[] getInterpolatingPoints() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,105,double[] out = new double[x.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,106,"System.arraycopy(x, 0, out, 0, x.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,107,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,111,* Returns a copy of the interpolating values array.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,112,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,113,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,115,* @return a fresh copy of the interpolating values array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,117,public double[] getInterpolatingValues() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,118,double[] out = new double[y.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,119,"System.arraycopy(y, 0, out, 0, y.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,120,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,124,* Returns a copy of the coefficients array.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,125,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,126,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,128,* @return a fresh copy of the coefficients array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,130,public double[] getCoefficients() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,131,if (!coefficientsComputed) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,132,computeCoefficients();
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,134,double[] out = new double[coefficients.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,135,"System.arraycopy(coefficients, 0, out, 0, coefficients.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,136,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,140,* Evaluate the Lagrange polynomial using
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,141,"* <a href=""http://mathworld.wolfram.com/NevillesAlgorithm.html"">"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,142,* Neville's Algorithm</a>. It takes O(N^2) time.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,143,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,144,* This function is made public static so that users can call it directly
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,145,* without instantiating PolynomialFunctionLagrangeForm object.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,147,* @param x the interpolating points array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,148,* @param y the interpolating values array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,149,* @param z the point at which the function value is to be computed
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,150,* @return the function value
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,151,* @throws FunctionEvaluationException if a runtime error occurs
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,152,* @throws IllegalArgumentException if inputs are not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,154,"public static double evaluate(double x[], double y[], double z) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,155,"FunctionEvaluationException, IllegalArgumentException {"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,157,"int i, j, n, nearest = 0;"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,158,"double value, c[], d[], tc, td, divider, w, dist, min_dist;"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,160,"verifyInterpolationArray(x, y);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,162,n = x.length;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,163,c = new double[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,164,d = new double[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,165,min_dist = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,166,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,167,// initialize the difference arrays
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,168,c[i] = y[i];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,169,d[i] = y[i];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,170,// find out the abscissa closest to z
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,171,dist = Math.abs(z - x[i]);
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,172,if (dist < min_dist) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,173,nearest = i;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,174,min_dist = dist;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,178,// initial approximation to the function value at z
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,179,value = y[nearest];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,181,for (i = 1; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,182,for (j = 0; j < n-i; j++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,183,tc = x[j] - z;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,184,td = x[i+j] - z;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,185,divider = x[j] - x[i+j];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,186,if (divider == 0.0) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,187,// This happens only when two abscissas are identical.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,188,"throw new FunctionEvaluationException(z,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,189,"""Identical abscissas cause division by zero: x["" +"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,190,"i + ""] = x["" + (i+j) + ""] = "" + x[i]);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,192,// update the difference arrays
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,193,w = (c[j+1] - d[j]) / divider;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,194,c[j] = tc * w;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,195,d[j] = td * w;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,197,// sum up the difference terms to get the final value
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,198,if (nearest < 0.5*(n-i+1)) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,199,value += c[nearest];    // fork down
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,200,} else {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,201,nearest--;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,202,value += d[nearest];    // fork up
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,206,return value;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,210,* Calculate the coefficients of Lagrange polynomial from the
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,211,* interpolation data. It takes O(N^2) time.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,212,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,213,* Note this computation can be ill-conditioned. Use with caution
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,214,* and only when it is necessary.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,216,* @throws ArithmeticException if any abscissas coincide
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,218,protected void computeCoefficients() throws ArithmeticException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,219,"int i, j, n;"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,220,"double c[], tc[], d, t;"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,222,n = degree() + 1;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,223,coefficients = new double[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,224,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,225,coefficients[i] = 0.0;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,228,// c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,229,c = new double[n+1];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,230,c[0] = 1.0;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,231,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,232,for (j = i; j > 0; j--) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,233,c[j] = c[j-1] - c[j] * x[i];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,235,c[0] *= (-x[i]);
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,236,c[i+1] = 1;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,239,tc = new double[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,240,for (i = 0; i < n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,241,// d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,242,d = 1;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,243,for (j = 0; j < n; j++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,244,if (i != j) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,245,d *= (x[i] - x[j]);
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,248,if (d == 0.0) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,249,// This happens only when two abscissas are identical.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,250,throw new ArithmeticException
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,251,"(""Identical abscissas cause division by zero."");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,253,t = y[i] / d;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,254,"// Lagrange polynomial is the sum of n terms, each of which is a"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,255,// polynomial of degree n-1. tc[] are the coefficients of the i-th
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,256,// numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,257,tc[n-1] = c[n];     // actually c[n] = 1
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,258,coefficients[n-1] += t * tc[n-1];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,259,for (j = n-2; j >= 0; j--) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,260,tc[j] = c[j+1] + tc[j+1] * x[i];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,261,coefficients[j] += t * tc[j];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,265,coefficientsComputed = true;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,269,* Verifies that the interpolation arrays are valid.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,270,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,271,* The interpolating points must be distinct. However it is not
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,272,"* verified here, it is checked in evaluate() and computeCoefficients()."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,274,* @throws IllegalArgumentException if not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,275,"* @see #evaluate(double[], double[], double)"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,276,* @see #computeCoefficients()
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,278,"protected static void verifyInterpolationArray(double x[], double y[]) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,279,IllegalArgumentException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,281,if (x.length < 2 || y.length < 2) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,282,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,283,"(""Interpolation requires at least two points."");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,285,if (x.length != y.length) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,286,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java,287,"(""Abscissa and value arrays must have the same length."");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,2,* Copyright 2003-2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,18,import java.io.Serializable;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,19,import org.apache.commons.math.FunctionEvaluationException;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,22,* Implements the representation of a real polynomial function in
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,23,"* Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,24,"* ISBN 0070124477, chapter 2."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,25,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,26,* The formula of polynomial in Newton form is
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,27,*     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,28,*            a[n](x-c[0])(x-c[1])...(x-c[n-1])
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,29,* Note that the length of a[] is one more than the length of c[]
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,31,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,33,"public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,34,Serializable {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,36,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,37,static final long serialVersionUID = -3353896576191389897L;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,40,"* The coefficients of the polynomial, ordered by degree -- i.e."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,41,* coefficients[0] is the constant term and coefficients[n] is the
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,42,* coefficient of x^n where n is the degree of the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,44,private double coefficients[];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,47,* Members of c[] are called centers of the Newton polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,48,"* When all c[i] = 0, a[] becomes normal polynomial coefficients,"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,49,* i.e. a[i] = coefficients[i].
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,51,"private double a[], c[];"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,54,* Whether the polynomial coefficients are available.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,56,private boolean coefficientsComputed;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,59,* Construct a Newton polynomial with the given a[] and c[]. The order of
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,60,"* centers are important in that if c[] shuffle, then values of a[] would"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,61,"* completely change, not just a permutation of old a[]."
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,62,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,63,* The constructor makes copy of the input arrays and assigns them.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,65,* @param a the coefficients in Newton form formula
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,66,* @param c the centers
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,67,* @throws IllegalArgumentException if input arrays are not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,69,"PolynomialFunctionNewtonForm(double a[], double c[]) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,70,IllegalArgumentException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,72,"verifyInputArray(a, c);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,73,this.a = new double[a.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,74,this.c = new double[c.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,75,"System.arraycopy(a, 0, this.a, 0, a.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,76,"System.arraycopy(c, 0, this.c, 0, c.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,77,coefficientsComputed = false;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,81,* Calculate the function value at the given point.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,83,* @param z the point at which the function value is to be computed
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,84,* @return the function value
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,85,* @throws FunctionEvaluationException if a runtime error occurs
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,86,* @see UnivariateRealFunction#value(double)
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,88,public double value(double z) throws FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,89,"return evaluate(a, c, z);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,93,* Returns the degree of the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,95,* @return the degree of the polynomial
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,97,public int degree() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,98,return c.length;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,102,* Returns a copy of coefficients in Newton form formula.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,103,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,104,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,106,* @return a fresh copy of coefficients in Newton form formula
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,108,public double[] getNewtonCoefficients() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,109,double[] out = new double[a.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,110,"System.arraycopy(a, 0, out, 0, a.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,111,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,115,* Returns a copy of the centers array.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,116,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,117,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,119,* @return a fresh copy of the centers array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,121,public double[] getCenters() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,122,double[] out = new double[c.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,123,"System.arraycopy(c, 0, out, 0, c.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,124,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,128,* Returns a copy of the coefficients array.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,129,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,130,* Changes made to the returned copy will not affect the polynomial.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,132,* @return a fresh copy of the coefficients array
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,134,public double[] getCoefficients() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,135,if (!coefficientsComputed) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,136,computeCoefficients();
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,138,double[] out = new double[coefficients.length];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,139,"System.arraycopy(coefficients, 0, out, 0, coefficients.length);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,140,return out;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,144,* Evaluate the Newton polynomial using nested multiplication. It is
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,145,"* also called <a href=""http://mathworld.wolfram.com/HornersRule.html"">"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,146,* Horner's Rule</a> and takes O(N) time.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,148,* @param a the coefficients in Newton form formula
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,149,* @param c the centers
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,150,* @param z the point at which the function value is to be computed
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,151,* @return the function value
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,152,* @throws FunctionEvaluationException if a runtime error occurs
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,153,* @throws IllegalArgumentException if inputs are not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,155,"public static double evaluate(double a[], double c[], double z) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,156,"FunctionEvaluationException, IllegalArgumentException {"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,158,"verifyInputArray(a, c);"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,160,int n = c.length;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,161,double value = a[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,162,for (int i = n-1; i >= 0; i--) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,163,value = a[i] + (z - c[i]) * value;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,166,return value;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,170,* Calculate the normal polynomial coefficients given the Newton form.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,171,* It also uses nested multiplication but takes O(N^2) time.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,173,protected void computeCoefficients() {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,174,"int i, j, n = degree();"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,176,coefficients = new double[n+1];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,177,for (i = 0; i <= n; i++) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,178,coefficients[i] = 0.0;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,181,coefficients[0] = a[n];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,182,for (i = n-1; i >= 0; i--) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,183,for (j = n-i; j > 0; j--) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,184,coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,186,coefficients[0] = a[i] - c[i] * coefficients[0];
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,189,coefficientsComputed = true;
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,193,* Verifies that the input arrays are valid.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,194,* <p>
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,195,"* The centers must be distinct for interpolation purposes, but not"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,196,* for general use. Thus it is not verified here.
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,198,* @throws IllegalArgumentException if not valid
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,199,"* @see DividedDifferenceInterpolator#computeDividedDifference(double[],"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,200,* double[])
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,202,"protected static void verifyInputArray(double a[], double c[]) throws"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,203,IllegalArgumentException {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,205,if (a.length < 1 || c.length < 1) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,206,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,207,"(""Input arrays must not be empty."");"
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,209,if (a.length != c.length + 1) {
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,210,throw new IllegalArgumentException
True,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java,211,"(""Bad input array sizes, should have difference 1."");"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,2,* Copyright 2005 The Apache Software Foundation.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,4,"* Licensed under the Apache License, Version 2.0 (the ""License"");"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,5,* you may not use this file except in compliance with the License.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,6,* You may obtain a copy of the License at
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,8,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,10,"* Unless required by applicable law or agreed to in writing, software"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,11,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,12,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,13,* See the License for the specific language governing permissions and
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,14,* limitations under the License.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,16,package org.apache.commons.math.analysis;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,18,import org.apache.commons.math.ConvergenceException;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,19,import org.apache.commons.math.FunctionEvaluationException;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,20,import org.apache.commons.math.util.MathUtils;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,23,"* Implements the <a href=""http://mathworld.wolfram.com/RiddersMethod.html"">"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,24,* Ridders' Method</a> for root finding of real univariate functions. For
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,25,"* reference, see C. Ridders, <i>A new algorithm for computing a single root"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,26,"* of a real continuous function </i>, IEEE Transactions on Circuits and"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,27,"* Systems, 26 (1979), 979 - 980."
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,28,* <p>
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,29,* The function should be continuous but not necessarily smooth.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,31,* @version $Revision$ $Date$
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,33,public class RiddersSolver extends UnivariateRealSolverImpl {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,35,/** serializable version identifier */
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,36,static final long serialVersionUID = -4703139035737911735L;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,39,* Construct a solver for the given function.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,41,* @param f function to solve
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,43,public RiddersSolver(UnivariateRealFunction f) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,44,"super(f, 100, 1E-6);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,48,* Find a root in the given interval with initial value.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,49,* <p>
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,50,* Requires bracketing condition.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,52,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,53,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,54,* @param initial the start value to use
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,55,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,56,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,57,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,58,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,59,* function
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,60,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,62,"public double solve(double min, double max, double initial) throws"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,63,"ConvergenceException, FunctionEvaluationException {"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,65,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,66,if (f.value(min) == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,67,if (f.value(max) == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,68,if (f.value(initial) == 0.0) { return initial; }
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,70,"verifyBracketing(min, max, f);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,71,"verifySequence(min, initial, max);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,72,"if (isBracketing(min, initial, f)) {"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,73,"return solve(min, initial);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,74,} else {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,75,"return solve(initial, max);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,80,* Find a root in the given interval.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,81,* <p>
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,82,* Requires bracketing condition.
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,84,* @param min the lower bound for the interval
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,85,* @param max the upper bound for the interval
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,86,* @return the point at which the function value is zero
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,87,* @throws ConvergenceException if the maximum iteration count is exceeded
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,88,* or the solver detects convergence problems otherwise
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,89,* @throws FunctionEvaluationException if an error occurs evaluating the
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,90,* function
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,91,* @throws IllegalArgumentException if any parameters are invalid
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,93,"public double solve(double min, double max) throws ConvergenceException,"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,94,FunctionEvaluationException {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,96,"// [x1, x2] is the bracketing interval in each iteration"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,97,"// x3 is the midpoint of [x1, x2]"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,98,// x is the new root approximation and an endpoint of the new interval
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,99,"double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,101,x1 = min; y1 = f.value(x1);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,102,x2 = max; y2 = f.value(x2);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,104,// check for zeros before verifying bracketing
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,105,if (y1 == 0.0) { return min; }
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,106,if (y2 == 0.0) { return max; }
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,107,"verifyBracketing(min, max, f);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,109,int i = 1;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,110,oldx = Double.POSITIVE_INFINITY;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,111,while (i <= maximalIterationCount) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,112,// calculate the new root approximation
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,113,x3 = 0.5 * (x1 + x2);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,114,y3 = f.value(x3);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,115,if (Math.abs(y3) <= functionValueAccuracy) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,116,"setResult(x3, i);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,117,return result;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,119,delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,120,correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,121,(x3 - x1) / Math.sqrt(delta);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,122,x = x3 - correction;                // correction != 0
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,123,y = f.value(x);
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,125,// check for convergence
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,126,"tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,127,if (Math.abs(x - oldx) <= tolerance) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,128,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,129,return result;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,131,if (Math.abs(y) <= functionValueAccuracy) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,132,"setResult(x, i);"
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,133,return result;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,136,// prepare the new interval for next iteration
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,137,// Ridders' method guarantees x1 < x < x2
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,138,if (correction > 0.0) {             // x1 < x < x3
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,139,if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,140,x2 = x; y2 = y;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,141,} else {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,142,x1 = x; x2 = x3;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,143,y1 = y; y2 = y3;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,145,} else {                            // x3 < x < x2
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,146,if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,147,x1 = x; y1 = y;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,148,} else {
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,149,x1 = x3; x2 = x;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,150,y1 = y3; y2 = y;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,153,oldx = x;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,154,i++;
True,src/java/org/apache/commons/math/analysis/RiddersSolver.java,src/java/org/apache/commons/math/analysis/RiddersSolver.java,156,"throw new ConvergenceException(""Maximum number of iterations exceeded."");"
