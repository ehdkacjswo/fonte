is_addition,old_file_path,new_file_path,line_num,content
False,src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java,src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java,240,rivate void checkInterpolation() throws MathIllegalStateException {
True,src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java,src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java,240,private void checkInterpolation() throws MathIllegalStateException {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,253,** Convert an orthogonal rotation matrix to a quaternion.
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,254, @param ort orthogonal rotation matrix
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,255, @return quaternion corresponding to the matrix
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,257,rivate static double[] mat2quat(final double[][] ort) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,259,inal double[] quat = new double[4];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,261,/ There are different ways to compute the quaternions elements
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,262,/ from the matrix. They all involve computing one element from
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,263,"/ the diagonal of the matrix, and computing the three other ones"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,264,"/ using a formula involving a division by the first element,"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,265,/ which unfortunately can be zero. Since the norm of the
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,266,"/ quaternion is 1, we know at least one element has an absolute"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,267,"/ value greater or equal to 0.5, so it is always possible to"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,268,/ select the right formula and avoid division by zero and even
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,269,/ numerical inaccuracy. Checking the elements in turn and using
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,270,/ the first one greater than 0.45 is safe (this leads to a simple
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,271,/ test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,272,ouble s = ort[0][0] + ort[1][1] + ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,273,f (s > -0.19) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,274,"/ compute q0 and deduce q1, q2 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,275,uat[0] = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,276,ouble inv = 0.25 / quat[0];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,277,uat[1] = inv * (ort[1][2] - ort[2][1]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,278,uat[2] = inv * (ort[2][0] - ort[0][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,279,uat[3] = inv * (ort[0][1] - ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,280, else {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,281, = ort[0][0] - ort[1][1] - ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,282,f (s > -0.19) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,283,"/ compute q1 and deduce q0, q2 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,284,uat[1] = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,285,ouble inv = 0.25 / quat[1];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,286,uat[0] = inv * (ort[1][2] - ort[2][1]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,287,uat[2] = inv * (ort[0][1] + ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,288,uat[3] = inv * (ort[0][2] + ort[2][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,289, else {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,290, = ort[1][1] - ort[0][0] - ort[2][2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,291,f (s > -0.19) {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,292,"/ compute q2 and deduce q0, q1 and q3"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,293,uat[2] = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,294,ouble inv = 0.25 / quat[2];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,295,uat[0] = inv * (ort[2][0] - ort[0][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,296,uat[1] = inv * (ort[0][1] + ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,297,uat[3] = inv * (ort[2][1] + ort[1][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,298, else {
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,299,"/ compute q3 and deduce q0, q1 and q2"
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,300, = ort[2][2] - ort[0][0] - ort[1][1];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,301,uat[3] = 0.5 * FastMath.sqrt(s + 1.0);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,302,ouble inv = 0.25 / quat[3];
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,303,uat[0] = inv * (ort[0][1] - ort[1][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,304,uat[1] = inv * (ort[0][2] + ort[2][0]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,305,uat[2] = inv * (ort[2][1] + ort[1][2]);
False,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,310,eturn quat;
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,388,/** Convert an orthogonal rotation matrix to a quaternion.
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,389,* @param ort orthogonal rotation matrix
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,390,* @return quaternion corresponding to the matrix
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,392,private static double[] mat2quat(final double[][] ort) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,394,final double[] quat = new double[4];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,396,// There are different ways to compute the quaternions elements
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,397,// from the matrix. They all involve computing one element from
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,398,"// the diagonal of the matrix, and computing the three other ones"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,399,"// using a formula involving a division by the first element,"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,400,// which unfortunately can be zero. Since the norm of the
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,401,"// quaternion is 1, we know at least one element has an absolute"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,402,"// value greater or equal to 0.5, so it is always possible to"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,403,// select the right formula and avoid division by zero and even
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,404,// numerical inaccuracy. Checking the elements in turn and using
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,405,// the first one greater than 0.45 is safe (this leads to a simple
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,406,// test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,407,double s = ort[0][0] + ort[1][1] + ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,408,if (s > -0.19) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,409,"// compute q0 and deduce q1, q2 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,410,quat[0] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,411,double inv = 0.25 / quat[0];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,412,quat[1] = inv * (ort[1][2] - ort[2][1]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,413,quat[2] = inv * (ort[2][0] - ort[0][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,414,quat[3] = inv * (ort[0][1] - ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,415,} else {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,416,s = ort[0][0] - ort[1][1] - ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,417,if (s > -0.19) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,418,"// compute q1 and deduce q0, q2 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,419,quat[1] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,420,double inv = 0.25 / quat[1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,421,quat[0] = inv * (ort[1][2] - ort[2][1]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,422,quat[2] = inv * (ort[0][1] + ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,423,quat[3] = inv * (ort[0][2] + ort[2][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,424,} else {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,425,s = ort[1][1] - ort[0][0] - ort[2][2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,426,if (s > -0.19) {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,427,"// compute q2 and deduce q0, q1 and q3"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,428,quat[2] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,429,double inv = 0.25 / quat[2];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,430,quat[0] = inv * (ort[2][0] - ort[0][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,431,quat[1] = inv * (ort[0][1] + ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,432,quat[3] = inv * (ort[2][1] + ort[1][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,433,} else {
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,434,"// compute q3 and deduce q0, q1 and q2"
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,435,s = ort[2][2] - ort[0][0] - ort[1][1];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,436,quat[3] = 0.5 * FastMath.sqrt(s + 1.0);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,437,double inv = 0.25 / quat[3];
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,438,quat[0] = inv * (ort[0][1] - ort[1][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,439,quat[1] = inv * (ort[0][2] + ort[2][0]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,440,quat[2] = inv * (ort[2][1] + ort[1][2]);
True,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java,445,return quat;
