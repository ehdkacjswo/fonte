is_addition,old_file_path,new_file_path,line_num,content
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,148,f (!base64.hasData()) {
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,149,yte[] buf = new byte[doEncode ? 4096 : 8192];
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,150,nt c = in.read(buf);
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,151,/ A little optimization to avoid System.arraycopy()
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,152,/ when possible.
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,153,f (c > 0 && b.length == len) {
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,154,"ase64.setInitialBuffer(b, offset, len);"
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,156,f (doEncode) {
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,157,"ase64.encode(buf, 0, c);"
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,158, else {
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,159,"ase64.decode(buf, 0, c);"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,148,int readLen = 0;
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,150,Rationale for while-loop on (readLen == 0):
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,152,Base64.readResults() usually returns > 0 or EOF (-1).  In the
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,153,"rare case where it returns 0, we just keep trying."
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,155,This is essentially an undocumented contract for InputStream
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,156,implementors that want their code to work properly with
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,157,"java.io.InputStreamReader, since the latter hates it when"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,158,InputStream.read(byte[]) returns a zero.  Unfortunately our
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,159,readResults() call must return 0 if a large amount of the data
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,160,"being decoded was non-base64, so this while-loop enables proper"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,161,interop with InputStreamReader for that scenario.
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,163,This is a fix for CODEC-101
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,165,while (readLen == 0) {
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,166,if (!base64.hasData()) {
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,167,byte[] buf = new byte[doEncode ? 4096 : 8192];
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,168,int c = in.read(buf);
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,169,// A little optimization to avoid System.arraycopy()
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,170,// when possible.
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,171,if (c > 0 && b.length == len) {
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,172,"base64.setInitialBuffer(b, offset, len);"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,174,if (doEncode) {
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,175,"base64.encode(buf, 0, c);"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,176,} else {
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,177,"base64.decode(buf, 0, c);"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,180,"readLen = base64.readResults(b, offset, len);"
False,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,162,"eturn base64.readResults(b, offset, len);"
True,src/java/org/apache/commons/codec/binary/Base64InputStream.java,src/java/org/apache/commons/codec/binary/Base64InputStream.java,182,return readLen;
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,50,* Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,51,* because Java's builtin InputStreamReader hates that.
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,53,* @throws Exception for some failure scenarios.
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,55,public void testCodec101() throws Exception {
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,56,byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,57,ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,58,Base64InputStream in = new Base64InputStream(bais);
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,59,byte[] result = new byte[8192];
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,60,int c = in.read(result);
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,61,"assertTrue(""Codec101: First read successful [c="" + c + ""]"", c > 0);"
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,63,c = in.read(result);
True,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java,64,"assertTrue(""Codec101: Second read should report end-of-stream [c="" + c + ""]"", c < 0);"
True,src/test/org/apache/commons/codec/binary/Base64TestData.java,src/test/org/apache/commons/codec/binary/Base64TestData.java,35,"public static final String CODEC_101_MULTIPLE_OF_3 = ""123"";"
