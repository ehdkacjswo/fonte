is_addition,old_file_path,new_file_path,line_num,content
False,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1163,ash = (hash * 31) + ch;
True,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1163,hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
False,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1208,ash = (hash * 31) + i;
True,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1208,hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;
False,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1278,ash = (hash * 31) + ch;
True,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1278,hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
False,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1309,ash = (hash * 31) + ch;
True,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1309,hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;
False,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1426,ash = (hash * 31) + i;
True,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,1426,hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,71,inal BytesToNameCanonicalizer _parent;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,71,final protected BytesToNameCanonicalizer _parent;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,74,* Seed value we use as the base to make hash codes non-static between
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,75,"* different runs, but still stable for lifetime of a single symbol table"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,76,* instance.
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,77,"* This is done for security reasons, to avoid potential DoS attack via"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,78,* hash collisions.
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,80,* @since 2.1
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,82,final private int _hashSeed;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,207,* Factory method to call to create a symbol table instance with a
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,208,* randomized seed value.
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,197,"eturn new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true);"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,212,"/* [Issue-21]: Need to use a variable seed, to thwart hash-collision"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,213,* based attacks.
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,215,long now = System.currentTimeMillis();
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,216,// ensure it's not 0; and might as well require to be odd so:
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,217,int seed = (((int) now) + ((int) now >>> 32)) | 1;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,218,return createRoot(seed);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,222,"* Factory method that should only be called from unit tests, where seed"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,223,* value should remain the same.
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,225,protected static BytesToNameCanonicalizer createRoot(int hashSeed) {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,226,"return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed);"
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,207,"eturn new BytesToNameCanonicalizer(this, intern);"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,236,"return new BytesToNameCanonicalizer(this, intern, _hashSeed);"
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,229,"rivate BytesToNameCanonicalizer(int hashSize, boolean intern)"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,258,"private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed)"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,261,_hashSeed = seed;
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,233,* Sanity check: let's now allow hash sizes below certain
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,234, min. value
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,263,// Sanity check: let's now allow hash sizes below certain minimum value
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,256,"rivate BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern)"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,284,"private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern,"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,285,int seed)
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,288,_hashSeed = seed;
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,355,ublic boolean maybeDirty()
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,385,public boolean maybeDirty() {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,390,* @since 2.1
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,392,public int hashSeed() { return _hashSeed; }
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,511,"* // Not needed, never gets called"
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,562,"nt hash = calcHash(quads, qlen);"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,594,int hash;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,595,if (qlen < 3) {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,596,"hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]);"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,597,} else {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,598,"hash = calcHash(quads, qlen);"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,611,/* Note on hash calculation: we try to make it more difficult to
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,612,* generate collisions automatically; part of this is to avoid
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,613,"* simple ""multiply-add"" algorithm (like JDK String.hashCode()),"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,614,* and add bit of shifting. And other part is to make this
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,615,"* non-linear, at least for shorter symbols."
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,575,/ JDK uses 33; other fine choices are 31 and 65599
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,618,"// JDK uses 31; other fine choices are 33 and 65599, let's use 33"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,619,// as it seems to give fewest collisions for us
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,579,ublic final static int calcHash(int firstQuad)
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,623,public final int calcHash(int firstQuad)
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,581,nt hash = firstQuad;
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,582,ash ^= (hash >>> 16); // to xor hi- and low- 16-bits
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,583,ash ^= (hash >>> 8); // as well as lowest 2 bytes
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,625,int hash = firstQuad ^ _hashSeed;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,626,hash += (hash >>> 15); // to xor hi- and low- 16-bits
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,627,hash ^= (hash >>> 9); // as well as lowest 2 bytes
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,587,"ublic final static int calcHash(int firstQuad, int secondQuad)"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,631,"public final int calcHash(int firstQuad, int secondQuad)"
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,589,nt hash = (firstQuad * MULT) + secondQuad;
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,591,/ If this was called for single-quad instance:
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,592,/int hash = (secondQuad == 0) ? firstQuad : ((firstQuad * MULT) + secondQuad);
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,594,ash ^= (hash >>> 16); // to xor hi- and low- 16-bits
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,595,ash ^= (hash >>> 8); // as well as lowest 2 bytes
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,633,"/* For two quads, let's change algorithm a bit, to spice"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,634,* things up (can do bit more processing anyway)
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,637,int hash = firstQuad;
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,638,hash += (hash >>> 15); // try mixing first and second byte pairs first
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,639,hash ^= ((secondQuad + _hashSeed) * MULT); // then add second quad
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,640,hash += (hash >>> 9); // and shuffle some more
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,599,"ublic final static int calcHash(int[] quads, int qlen)"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,644,"public final int calcHash(int[] quads, int qlen)"
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,601,/ Note: may be called for qlen < 3
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,646,// Note: may be called for qlen < 3; but has at least one int
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,647,if (qlen < 3) {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,648,throw new IllegalArgumentException();
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,651,"/* And then change handling again for ""multi-quad"" case; mostly"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,652,"* to make calculation of collisions less fun. For example,"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,653,"* add seed bit later in the game, and switch plus/xor around,"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,654,* use different shift lengths.
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,603,or (int i = 1; i < qlen; ++i) {
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,604,ash = (hash * MULT) + quads[i];
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,657,hash ^= (hash >>> 9);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,658,hash += ((quads[1] + _hashSeed) * MULT);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,659,hash ^= (hash >>> 15);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,660,hash ^= (quads[2] * MULT);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,661,hash += (hash >>> 17);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,663,for (int i = 3; i < qlen; ++i) {
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,664,hash = (hash * MULT) + (quads[i] + 1);
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,665,"// for longer entries, mess a bit in-between too"
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,666,hash ^= (hash >>> 3);
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,607,ash ^= (hash >>> 16); // to xor hi- and low- 16-bits
False,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,608,ash ^= (hash >>> 8); // as well as lowest 2 bytes
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,669,// and finally shuffle some more once done
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,670,hash += (hash >>> 15); // to get high-order bits to mix more
True,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java,671,hash ^= (hash >>> 9); // as well as lowest 2 bytes
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,44,"/* If we use ""multiply-add"" based hash algorithm, this is the multiplier"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,45,* we use.
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,47,public final static int HASH_MULT = 33;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,118,inal protected int _hashSeed;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,123,final private int _hashSeed;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,213,nt seed = ((int) now) + ((int) now >>> 32);
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,218,// ensure it's not 0; and might as well require to be odd so:
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,219,int seed = (((int) now) + ((int) now >>> 32)) | 1;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,425,"ublic String findSymbol(char[] buffer, int start, int len, int hash)"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,431,"public String findSymbol(char[] buffer, int start, int len, int h)"
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,434,ash &= _indexMask;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,436,tring sym = _symbols[hash];
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,440,/* Related to problems with sub-standard hashing (somewhat
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,441,"* relevant for collision attacks too), let's try little"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,442,* bit of shuffling to improve hash codes.
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,443,"* (note, however, that this can't help with full collisions)"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,445,int index = _hashToIndex(h);
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,446,String sym = _symbols[index];
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,454,ucket b = _buckets[hash >> 1];
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,464,Bucket b = _buckets[index >> 1];
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,468,* Need to recalc hash; rare occurence (index mask has been
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,469, recalculated as part of rehash)
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,471,"ash = calcHash(buffer, start, len) & _indexMask;"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,478,/* Need to recalc hash; rare occurence (index mask has been
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,479,* recalculated as part of rehash)
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,481,"index = _hashToIndex(calcHash(buffer, start, len));"
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,480,f (_symbols[hash] == null) {
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,481,symbols[hash] = newSymbol;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,490,if (_symbols[index] == null) {
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,491,_symbols[index] = newSymbol;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,483,nt bix = (hash >> 1);
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,493,int bix = (index >> 1);
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,506,"* Helper method that takes in a ""raw"" hash value, shuffles it as necessary,"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,507,* and truncates to be used as the index.
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,509,public final int _hashToIndex(int rawHash)
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,511,"rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,512,return (rawHash & _indexMask);
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,504,"ublic int calcHash(char[] buffer, int start, int len) {"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,524,"public int calcHash(char[] buffer, int start, int len)"
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,507,ash = (hash * 31) + (int) buffer[i];
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,528,hash = (hash * HASH_MULT) + (int) buffer[i];
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,509,eturn hash;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,530,"// NOTE: shuffling, if any, is done in 'findSymbol()', not here:"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,531,return (hash == 0) ? 1 : hash;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,512,ublic int calcHash(String key) {
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,534,public int calcHash(String key)
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,536,final int len = key.length();
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,514,"or (int i = 0, len = key.length(); i < len; ++i) {"
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,515,ash = (hash * 31) + (int) key.charAt(i);
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,539,for (int i = 0; i < len; ++i) {
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,540,hash = (hash * HASH_MULT) + (int) key.charAt(i);
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,517,eturn hash;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,542,"// NOTE: shuffling, if any, is done in 'findSymbol()', not here:"
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,543,return (hash == 0) ? 1 : hash;
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,587,nt index = calcHash(symbol) & _indexMask;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,613,int index = _hashToIndex(calcHash(symbol));
False,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,605,nt index = calcHash(symbol) & _indexMask;
True,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java,631,int index = _hashToIndex(calcHash(symbol));
False,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,21, neither too small (low hit ratio) nor too large (waste of memory)
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,21,* neither too small (low hit ratio) nor too large (waste of memory).
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,22,*<p>
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,23,"* 11-Jul-2012, tatu: Also, consider the nasty case of String hashCode()"
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,24,*    collisions; size needs to be small enough to survive linear list
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,25,*    lookup... so let's go down a notch (from 192 to 100)
False,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,23,rivate final static int MAX_ENTRIES = 192;
True,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,src/main/java/com/fasterxml/jackson/core/util/InternCache.java,27,private final static int MAX_ENTRIES = 100;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,1,import java.util.HashSet;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,4,public class CollGenerator
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,6,protected final HashFunc hashFunc;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,8,public CollGenerator(HashFunc hashFunc)
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,10,this.hashFunc = hashFunc;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,13,public static void main(String[] args)
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,15,//        final int TARGET_HASH_CODE = 0xBEEF; // or (1 << 20)
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,16,final int TARGET_HASH_CODE = 0xFFFF; // or (1 << 20)
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,17,//        final int TARGET_HASH_CODE = (1 << 20);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,18,final int COLLISIONS_TO_GENERATE = 20;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,20,"// first, Java default (seed=0, mult=31)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,21,"//        new CollGenerator(new MultPlusHashFunc(0, 31))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,22,"//        new CollGenerator(new MultPlusHashFunc(0x77654321, 31))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,23,"new CollGenerator(new MultPlusHashFunc(0, 31))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,24,".generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,27,"// then alternative, djb2 (see [http://www.cse.yorku.ca/~oz/hash.html]),"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,28,"// (see=5381, mult=33)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,29,"new CollGenerator(new MultPlusHashFunc(5381, 33))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,30,".generate3(1<<20, COLLISIONS_TO_GENERATE, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,31,"new CollGenerator(new MultXorHashFunc(5381, 33))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,32,".generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,34,"// one more, ""sdbm"" (from [http://www.cse.yorku.ca/~oz/hash.html] as well)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,35,"new CollGenerator(new MultPlusHashFunc(5381, 65599))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,36,".generate3(0xff0000, COLLISIONS_TO_GENERATE, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,37,"new CollGenerator(new MultXorHashFunc(0, 65599))"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,38,".generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,43,* @param targetHash the hash code of the generated strings
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,45,"public void generate3(int targetHash, int maxEntries,"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,46,boolean isStdHash)
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,48,final char minChar = 0x21; // after space
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,49,//      final int maxChar = Character.MAX_VALUE;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,50,final int maxChar = 0x7f;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,52,"System.out.println(""// target hash=0x""+Integer.toHexString(targetHash)+"", with-> ""+hashFunc);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,53,"System.out.println(""final static String[] COLLISIONS = {"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,55,final HashFunc modHashFunc = hashFunc.withSeed(hashFunc.getSeed() + 0x7FFF);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,57,int count = 0;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,59,StringBuilder sb = new StringBuilder();
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,61,// first try simple analytic solutions...
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,62,final HashSet<String> found = new HashSet<String>();
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,64,main_loop:
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,65,for (int c0 = minChar; c0 <= maxChar; ++c0) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,66,for (int c1 = minChar; c1 <= maxChar; ++c1) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,67,"// first, see if there's an ""easy solution"""
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,68,"int c2 = hashFunc.findLastChar(c0, c1, targetHash);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,69,//                if (c2 < 0 || c2 > 0xFFFF) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,70,if (c2 < minChar || c2 > maxChar) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,71,continue;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,73,"String key = new String(new char[] { (char) c0, (char) c1, (char) c2 } );"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,75,// double-check for fun:
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,76,if (isStdHash) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,77,if (key.hashCode() != targetHash) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,78,"throw new RuntimeException(""Should get STD hash of 0x""+Integer.toHexString(targetHash)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,79,"+"" for ""+asQuoted(key)+""; instead got 0x""+Integer.toHexString(key.hashCode()));"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,81,} else {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,82,"int actual = hashFunc.hashCode(key.charAt(0), key.charAt(1), key.charAt(2));"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,83,if (actual != targetHash) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,84,"throw new RuntimeException(""Should get hash of 0x""+Integer.toHexString(targetHash)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,85,"+"" for ""+asQuoted(key)+""; instead got 0x""+Integer.toHexString(actual));"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,88,found.add(key);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,89,sb.append(asQuoted(key));
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,90,"// also, indicate alternate hash"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,91,int altHash = modHashFunc.hashCode(key);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,92,"sb.append(""/*0x"").append(Integer.toHexString(altHash)).append(""*/"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,94,if (++count >= maxEntries) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,95,break main_loop;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,98,"sb.append("", "");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,99,if (sb.length() > 72) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,100,System.out.println(sb.toString());
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,101,sb.setLength(0);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,106,System.out.println(sb.toString());
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,108,// enough?
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,109,if (found.size() < maxEntries) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,110,"System.out.println("" // not enough easy entries found... have to work harder?"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,112,"System.out.println(""};"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,115,"private final static char[] HEX = ""0123456789ABCDEF"".toCharArray();"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,117,private String asQuoted(String s) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,118,"StringBuilder result = new StringBuilder().append('""');"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,119,for (int i = 0; i < s.length(); ++i) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,120,char c = s.charAt(i);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,121,"if (c == '""' || c == '\\') {"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,122,result.append('\\');
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,123,result.append(c);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,124,} else if (c < 32 || c > 127) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,125,result.append('\\').append('u');
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,126,result.append(HEX[(c >> 12)]);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,127,result.append(HEX[(c >> 8) & 0xF]);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,128,result.append(HEX[(c >> 4) & 0xF]);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,129,result.append(HEX[c & 0xF]);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,130,} else {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,131,result.append(c);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,134,"return result.append('""').toString();"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,137,abstract static class HashFunc
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,139,protected final int seed;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,141,protected HashFunc(int s) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,142,seed = s;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,145,public abstract HashFunc withSeed(int s);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,147,public int getSeed() { return seed; }
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,149,public final int hashCode(String key) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,150,"return hashCode(key.charAt(0), key.charAt(1), key.charAt(2));"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,153,"public abstract int hashCode(int c0, int c1, int c2);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,155,"public abstract int findLastChar(int c0, int c1, int targetHash);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,158,abstract static class MultHashFunc extends HashFunc
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,160,protected final int multiplier;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,162,protected final int base;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,164,"protected MultHashFunc(int s, int mult)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,166,super(s);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,167,multiplier = mult;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,168,base = (s * mult);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,172,final static class MultPlusHashFunc extends MultHashFunc
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,174,protected final boolean multiplySeed;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,177,"public MultPlusHashFunc(int s, int mult)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,179,"this(s, mult, false);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,182,"public MultPlusHashFunc(int s, int mult, boolean multSeed)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,184,"super(s, mult);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,185,multiplySeed = multSeed;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,188,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,189,public MultPlusHashFunc withSeed(int newSeed) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,190,"if (newSeed == seed) throw new IllegalArgumentException(""Should not re-create with same seed"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,191,"return new MultPlusHashFunc(newSeed, multiplier, true);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,194,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,195,"public int hashCode(int c0, int c1, int c2)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,197,int h1 = multiplySeed ? (base * c0) : (base + c0);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,198,int h2 = (h1 * multiplier) + c1;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,199,return (h2 * multiplier) + c2;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,202,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,203,"public int findLastChar(int c0, int c1, int targetHash)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,205,int afterC1 = ((base + c0) * multiplier) + c1;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,206,int afterC1Mult = afterC1 * multiplier;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,208,"// we know that 'hash = (afterC1 * MULT) + c2',"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,209,"// so ignoring overflow, easy solution would be"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,210,// 'c2 = targetHash - (afterC1 * MULT)'
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,211,if (afterC1Mult >= 0) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,212,return targetHash - afterC1Mult;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,214,// otherwise there's overflow; simple enough...
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,215,return targetHash - (afterC1 * multiplier);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,218,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,219,public String toString()
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,221,"return ""seed: ""+seed+"", multiplier: ""+multiplier+"" (0x"""
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,222,"+Integer.toHexString(multiplier)+"", operation: +)"";"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,226,final static class MultXorHashFunc extends MultHashFunc
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,228,"public MultXorHashFunc(int s, int mult)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,230,"super(s, mult);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,233,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,234,public MultXorHashFunc withSeed(int newSeed) {
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,235,"if (newSeed == seed) throw new IllegalArgumentException(""Should not re-create with same seed"");"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,236,"return new MultXorHashFunc(newSeed, multiplier);"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,239,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,240,"public int hashCode(int c0, int c1, int c2)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,242,int h1 = base + c0;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,243,int h2 = (h1 * multiplier) ^ c1;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,244,return (h2 * multiplier) ^ c2;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,247,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,248,"public int findLastChar(int c0, int c1, int targetHash)"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,250,int afterC1 = ((base + c0) * multiplier) ^ c1;
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,251,"// we know that 'hash = (afterC1 * MULT) ^ c2',"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,252,"// so ignoring overflow, easy solution would be"
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,253,// 'c2 = targetHash ^ (afterC1 * MULT)'
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,254,return targetHash ^ (afterC1 * multiplier);
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,257,@Override
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,258,public String toString()
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,260,"return ""seed: ""+seed+"", multiplier: ""+multiplier+"" (0x"""
True,src/test/java/CollGenerator.java,src/test/java/CollGenerator.java,261,"+Integer.toHexString(multiplier)+"", operation: ^)"";"
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,10,inal static String[] CHAR_COLLISION_SNIPPETS = {
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,11,"@~}"", ""@^"", ""A_}"", ""A`^"","
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,10,final static String[] CHAR_COLLISION_SNIPPETS_31 = {
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,11,"""@~}"", ""@\u007f^"", ""A_}"", ""A`^"","
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,17,inal int len = CHAR_COLLISION_SNIPPETS.length;
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,18,final String[] SNIPPETS = CHAR_COLLISION_SNIPPETS_31;
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,20,final int len = SNIPPETS.length;
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,23,HAR_COLLISIONS[ix++] = CHAR_COLLISION_SNIPPETS[i1]
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,24,CHAR_COLLISION_SNIPPETS[i2] + CHAR_COLLISION_SNIPPETS[i3];
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,26,CHAR_COLLISIONS[ix++] = SNIPPETS[i1]+SNIPPETS[i2] + SNIPPETS[i3];
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,61,harsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(0);
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,62,or (int i = 0; i < 5000; ++i) {
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,65,"// pass seed, to keep results consistent:"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,66,CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,67,final int COUNT = 6000;
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,68,for (int i = 0; i < COUNT; ++i) {
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,69,"ssertEquals(5000, symbols.size());"
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,70,/ holy guacamoley... there are way too many:
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,71,"ssertEquals(3053, symbols.collisionCount());"
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,72,/ but spread more evenly than byte-based ones?
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,73,"ssertEquals(29, symbols.maxCollisionLength());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,75,"assertEquals(COUNT, symbols.size());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,77,"//System.out.printf(""Char stuff: collisions %d, max-coll %d\n"", symbols.collisionCount(), symbols.maxCollisionLength());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,79,"// holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,80,"// ... at least before shuffling. Shuffling helps quite a lot, so:"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,81,"assertEquals(1401, symbols.collisionCount());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,82,// esp. with collisions; first got about 30
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,83,"assertEquals(4, symbols.maxCollisionLength());"
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,80,ytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot();
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,81,or (int i = 0; i < 5000; ++i) {
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,90,"// pass seed, to keep results consistent:"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,91,BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(1);
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,92,final int COUNT = 6000;
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,93,for (int i = 0; i < COUNT; ++i) {
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,86,"ssertEquals(5000, symbols.size());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,98,"assertEquals(COUNT, symbols.size());"
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,89,/ holy guacamoley... even here we have too many; but surprisingly (?)
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,90,/ less than with chars
False,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,91,"ssertEquals(1697, symbols.collisionCount());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,101,"//System.out.printf(""Byte stuff: collisions %d, max-coll %d\n"", symbols.collisionCount(), symbols.maxCollisionLength());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,103,"// Fewer collisions than with chars, but still quite a few"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,104,"assertEquals(1770, symbols.collisionCount());"
True,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java,105,// but not super long collision chains:
