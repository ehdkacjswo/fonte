is_addition,old_file_path,new_file_path,line_num,content
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,19,import java.util.ArrayList;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,20,import java.util.Collection;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,21,import java.util.Comparator;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,22,import java.util.Iterator;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,23,import java.util.TreeSet;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,25,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,26,import org.apache.commons.math.geometry.Vector;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,28,"/** Abstract class for all regions, independently of geometry type or dimension."
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,30,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,31,* @param <T> Type of the sub-space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,33,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,34,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,36,"public abstract class AbstractRegion<S extends Space, T extends Space> implements Region<S> {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,38,/** Inside/Outside BSP tree. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,39,private BSPTree<S> tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,41,/** Size of the instance. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,42,private double size;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,44,/** Barycenter. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,45,private Vector<S> barycenter;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,47,/** Build a region representing the whole space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,49,protected AbstractRegion() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,50,tree = new BSPTree<S>(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,53,/** Build a region from an inside/outside BSP tree.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,54,* <p>The leaf nodes of the BSP tree <em>must</em> have a
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,55,* {@code Boolean} attribute representing the inside status of
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,56,"* the corresponding cell (true for inside cells, false for outside"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,57,"* cells). In order to avoid building too many small objects, it is"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,58,* recommended to use the predefined constants
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,59,* {@code Boolean.TRUE} and {@code Boolean.FALSE}. The
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,60,* tree also <em>must</em> have either null internal nodes or
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,61,* internal nodes representing the boundary as specified in the
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,62,* {@link #getTree getTree} method).</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,63,* @param tree inside/outside BSP tree representing the region
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,65,protected AbstractRegion(final BSPTree<S> tree) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,66,this.tree = tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,69,/** Build a Region from a Boundary REPresentation (B-rep).
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,70,* <p>The boundary is provided as a collection of {@link
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,71,* SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,72,* interior part of the region on its minus side and the exterior on
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,73,* its plus side.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,74,"* <p>The boundary elements can be in any order, and can form"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,75,* several non-connected sets (like for example polygons with holes
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,76,* or a set of disjoints polyhedrons considered as a whole). In
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,77,"* fact, the elements do not even need to be connected together"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,78,"* (their topological connections are not used here). However, if the"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,79,* boundary does not really separate an inside open from an outside
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,80,"* open (open having here its topological meaning), then subsequent"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,81,* calls to the {@link #checkPoint(Vector) checkPoint} method will not be
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,82,* meaningful anymore.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,83,"* <p>If the boundary is empty, the region will represent the whole"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,84,* space.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,85,"* @param boundary collection of boundary elements, as a"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,86,* collection of {@link SubHyperplane SubHyperplane} objects
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,88,protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,90,if (boundary.size() == 0) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,92,// the tree represents the whole space
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,93,tree = new BSPTree<S>(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,95,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,97,// sort the boundary elements in decreasing size order
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,98,"// (we don't want equal size elements to be removed, so"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,99,// we use a trick to fool the TreeSet)
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,100,final TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,101,"public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,102,final double size1 = o1.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,103,final double size2 = o2.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,104,return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,107,ordered.addAll(boundary);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,109,// build the tree top-down
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,110,tree = new BSPTree<S>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,111,"insertCuts(tree, ordered);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,113,// set up the inside/outside flags
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,114,tree.visit(new BSPTreeVisitor<S>() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,116,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,117,public Order visitOrder(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,118,return Order.PLUS_SUB_MINUS;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,121,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,122,public void visitInternalNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,125,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,126,public void visitLeafNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,127,node.setAttribute((node == node.getParent().getPlus()) ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,128,Boolean.FALSE : Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,136,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,137,"public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,139,/** Recursively build a tree by inserting cut sub-hyperplanes.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,140,* @param node current tree node (it is a leaf node at the beginning
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,141,* of the call)
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,142,* @param boundary collection of edges belonging to the cell defined
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,143,* by the node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,145,"private void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,147,final Iterator<SubHyperplane<S>> iterator = boundary.iterator();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,149,// build the current level
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,150,Hyperplane<S> inserted = null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,151,while ((inserted == null) && iterator.hasNext()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,152,inserted = iterator.next().getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,153,if (!node.insertCut(inserted.copySelf())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,154,inserted = null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,158,if (!iterator.hasNext()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,159,return;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,162,// distribute the remaining edges in the two sub-trees
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,163,final ArrayList<SubHyperplane<S>> plusList  = new ArrayList<SubHyperplane<S>>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,164,final ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,165,while (iterator.hasNext()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,166,final SubHyperplane<S> other = iterator.next();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,167,switch (other.side(inserted)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,168,case PLUS:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,169,plusList.add(other);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,170,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,171,case MINUS:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,172,minusList.add(other);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,173,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,174,case BOTH:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,175,final SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,176,plusList.add(split.getPlus());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,177,minusList.add(split.getMinus());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,178,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,179,default:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,180,// ignore the sub-hyperplanes belonging to the cut hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,184,// recurse through lower levels
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,185,"insertCuts(node.getPlus(),  plusList);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,186,"insertCuts(node.getMinus(), minusList);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,190,/** Build a convex region from an array of bounding hyperplanes.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,191,"* @param hyperplanes array of bounding hyperplanes (if null, an"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,192,* empty region will be built)
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,193,"* @return a new convex region, or null if the collection is empty"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,195,public AbstractRegion(final Hyperplane<S>[] hyperplanes) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,196,if ((hyperplanes == null) || (hyperplanes.length == 0)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,197,tree = new BSPTree<S>(Boolean.FALSE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,198,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,200,// use the first hyperplane to build the right class
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,201,tree = hyperplanes[0].wholeSpace().getTree(false);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,203,// chop off parts of the space
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,204,BSPTree<S> node = tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,205,node.setAttribute(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,206,for (final Hyperplane<S> hyperplane : hyperplanes) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,207,if (node.insertCut(hyperplane)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,208,node.setAttribute(null);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,209,node.getPlus().setAttribute(Boolean.FALSE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,210,node = node.getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,211,node.setAttribute(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,219,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,220,"public AbstractRegion<S, T> copySelf() {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,221,return buildNew(tree.copySelf());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,224,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,225,public boolean isEmpty() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,226,return isEmpty(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,229,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,230,public boolean isEmpty(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,232,// we use a recursive function rather than the BSPTreeVisitor
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,233,// interface because we can stop visiting the tree as soon as we
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,234,// have found an inside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,236,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,237,"// if we find an inside node, the region is not empty"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,238,return !((Boolean) node.getAttribute());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,241,// check both sides of the sub-tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,242,return isEmpty(node.getMinus()) && isEmpty(node.getPlus());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,246,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,247,public boolean contains(final Region<S> region) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,248,"return new RegionFactory<S>().difference(region, this).isEmpty();"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,251,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,252,public Location checkPoint(final Vector<S> point) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,253,"return checkPoint(tree, point);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,256,/** Check a point with respect to the region starting at a given node.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,257,* @param node root node of the region
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,258,* @param point point to check
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,259,* @return a code representing the point status: either {@link
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,260,"* Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,262,"protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,263,final BSPTree<S> cell = node.getCell(point);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,264,if (cell.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,265,"// the point is in the interior of a cell, just check the attribute"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,266,return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,269,"// the point is on a cut-sub-hyperplane, is it on a boundary ?"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,270,"final Location minusCode = checkPoint(cell.getMinus(), point);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,271,"final Location plusCode  = checkPoint(cell.getPlus(),  point);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,272,return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,276,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,277,public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,278,if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,279,// we need to compute the boundary attributes
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,280,recurseBuildBoundary(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,282,return tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,285,/** Recursively build the boundary shell tree.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,286,* @param node current node in the inout tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,288,private void recurseBuildBoundary(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,289,if (node.getCut() != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,291,SubHyperplane<S> plusOutside = null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,292,SubHyperplane<S> plusInside  = null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,294,"// characterize the cut sub-hyperplane,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,295,// first with respect to the plus sub-tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,296,final Characterization<S> plusChar = new Characterization<S>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,297,"characterize(node.getPlus(), node.getCut().copySelf(), plusChar);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,299,if (plusChar.hasOut()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,300,// plusChar.out corresponds to a subset of the cut
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,301,// sub-hyperplane known to have outside cells on its plus
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,302,"// side, we want to check if parts of this subset do have"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,303,// inside cells on their minus side
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,304,final Characterization<S> minusChar = new Characterization<S>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,305,"characterize(node.getMinus(), plusChar.getOut(), minusChar);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,306,if (minusChar.hasIn()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,307,plusOutside = minusChar.getIn();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,311,if (plusChar.hasIn()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,312,// plusChar.in corresponds to a subset of the cut
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,313,// sub-hyperplane known to have inside cells on its plus
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,314,"// side, we want to check if parts of this subset do have"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,315,// outside cells on their minus side
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,316,final Characterization<S> minusChar = new Characterization<S>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,317,"characterize(node.getMinus(), plusChar.getIn(), minusChar);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,318,if (minusChar.hasOut()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,319,plusInside = minusChar.getOut();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,323,"node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,324,recurseBuildBoundary(node.getPlus());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,325,recurseBuildBoundary(node.getMinus());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,330,/** Filter the parts of an hyperplane belonging to the boundary.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,331,* <p>The filtering consist in splitting the specified
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,332,* sub-hyperplane into several parts lying in inside and outside
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,333,* cells of the tree. The principle is to call this method twice for
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,334,"* each cut sub-hyperplane in the tree, once one the plus node and"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,335,* once on the minus node. The parts that have the same flag
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,336,* (inside/inside or outside/outside) do not belong to the boundary
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,337,* while parts that have different flags (inside/outside or
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,338,* outside/inside) do belong to the boundary.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,339,* @param node current BSP tree node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,340,* @param sub sub-hyperplane to characterize
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,341,* @param characterization placeholder where to put the characterized parts
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,343,"private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,344,final Characterization<S> characterization) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,345,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,346,// we have reached a leaf node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,347,final boolean inside = (Boolean) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,348,"characterization.add(sub, inside);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,349,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,350,final Hyperplane<S> hyperplane = node.getCut().getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,351,switch (sub.side(hyperplane)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,352,case PLUS:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,353,"characterize(node.getPlus(), sub, characterization);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,354,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,355,case MINUS:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,356,"characterize(node.getMinus(), sub, characterization);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,357,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,358,case BOTH:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,359,final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,360,"characterize(node.getPlus(),  split.getPlus(),  characterization);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,361,"characterize(node.getMinus(), split.getMinus(), characterization);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,362,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,363,default:
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,364,// this should not happen
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,365,"throw new RuntimeException(""internal error"");"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,370,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,371,public double getBoundarySize() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,372,final BoundarySizeVisitor<S> visitor = new BoundarySizeVisitor<S>();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,373,getTree(true).visit(visitor);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,374,return visitor.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,377,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,378,public double getSize() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,379,if (barycenter == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,380,computeGeometricalProperties();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,382,return size;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,385,/** Set the size of the instance.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,386,* @param size size of the instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,388,protected void setSize(final double size) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,389,this.size = size;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,392,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,393,public Vector<S> getBarycenter() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,394,if (barycenter == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,395,computeGeometricalProperties();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,397,return barycenter;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,400,/** Set the barycenter of the instance.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,401,* @param barycenter barycenter of the instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,403,protected void setBarycenter(final Vector<S> barycenter) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,404,this.barycenter = barycenter;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,407,/** Compute some geometrical properties.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,408,* <p>The properties to compute are the barycenter and the size.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,410,protected abstract void computeGeometricalProperties();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,412,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,413,public Side side(final Hyperplane<S> hyperplane) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,414,final Sides sides = new Sides();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,415,"recurseSides(tree, hyperplane.wholeHyperplane(), sides);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,416,return sides.plusFound() ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,417,(sides.minusFound() ? Side.BOTH  : Side.PLUS) :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,418,(sides.minusFound() ? Side.MINUS : Side.HYPER);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,421,/** Search recursively for inside leaf nodes on each side of the given hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,423,* <p>The algorithm used here is directly derived from the one
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,424,* described in section III (<i>Binary Partitioning of a BSP
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,425,"* Tree</i>) of the Bruce Naylor, John Amanatides and William"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,426,* Thibault paper <a
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,427,"* href=""http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf"">Merging"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,428,* BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,429,"* '90, Computer Graphics 24(4), August 1990, pp 115-124, published"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,430,* by the Association for Computing Machinery (ACM)..</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,432,* @param node current BSP tree node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,433,* @param sub sub-hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,434,* @param sides object holding the sides found
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,436,"private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,438,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,439,if ((Boolean) node.getAttribute()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,440,// this is an inside cell expanding across the hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,441,sides.rememberPlusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,442,sides.rememberMinusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,444,return;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,447,final Hyperplane<S> hyperplane = node.getCut().getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,448,switch (sub.side(hyperplane)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,449,case PLUS :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,450,// the sub-hyperplane is entirely in the plus sub-tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,451,if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,452,if (!isEmpty(node.getMinus())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,453,sides.rememberPlusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,455,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,456,if (!isEmpty(node.getMinus())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,457,sides.rememberMinusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,460,if (!(sides.plusFound() && sides.minusFound())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,461,"recurseSides(node.getPlus(), sub, sides);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,463,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,464,case MINUS :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,465,// the sub-hyperplane is entirely in the minus sub-tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,466,if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,467,if (!isEmpty(node.getPlus())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,468,sides.rememberPlusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,470,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,471,if (!isEmpty(node.getPlus())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,472,sides.rememberMinusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,475,if (!(sides.plusFound() && sides.minusFound())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,476,"recurseSides(node.getMinus(), sub, sides);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,478,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,479,case BOTH :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,480,// the sub-hyperplane extends in both sub-trees
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,481,final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,483,// explore first the plus sub-tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,484,"recurseSides(node.getPlus(), split.getPlus(), sides);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,486,"// if needed, explore the minus sub-tree"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,487,if (!(sides.plusFound() && sides.minusFound())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,488,"recurseSides(node.getMinus(), split.getMinus(), sides);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,490,break;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,491,default :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,492,// the sub-hyperplane and the cut sub-hyperplane share the same hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,493,if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,494,if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,495,sides.rememberPlusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,497,if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,498,sides.rememberMinusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,500,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,501,if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,502,sides.rememberMinusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,504,if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,505,sides.rememberPlusFound();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,512,/** Utility class holding the already found sides. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,513,private static final class Sides {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,515,/** Indicator of inside leaf nodes found on the plus side. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,516,private boolean plusFound;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,518,/** Indicator of inside leaf nodes found on the plus side. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,519,private boolean minusFound;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,521,/** Simple constructor.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,523,public Sides() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,524,plusFound  = false;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,525,minusFound = false;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,528,/** Remember the fact that inside leaf nodes have been found on the plus side.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,530,public void rememberPlusFound() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,531,plusFound = true;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,534,/** Check if inside leaf nodes have been found on the plus side.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,535,* @return true if inside leaf nodes have been found on the plus side
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,537,public boolean plusFound() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,538,return plusFound;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,541,/** Remember the fact that inside leaf nodes have been found on the minus side.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,543,public void rememberMinusFound() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,544,minusFound = true;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,547,/** Check if inside leaf nodes have been found on the minus side.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,548,* @return true if inside leaf nodes have been found on the minus side
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,550,public boolean minusFound() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,551,return minusFound;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,556,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,557,public SubHyperplane<S> intersection(final SubHyperplane<S> sub) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,558,"return recurseIntersection(tree, sub);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,561,/** Recursively compute the parts of a sub-hyperplane that are
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,562,* contained in the region.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,563,* @param node current BSP tree node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,564,* @param sub sub-hyperplane traversing the region
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,565,* @return filtered sub-hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,567,"private SubHyperplane<S> recurseIntersection(final BSPTree<S> node, final SubHyperplane<S> sub) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,569,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,570,return (Boolean) node.getAttribute() ? sub.copySelf() : null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,573,final Hyperplane<S> hyperplane = node.getCut().getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,574,switch (sub.side(hyperplane)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,575,case PLUS :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,576,"return recurseIntersection(node.getPlus(), sub);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,577,case MINUS :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,578,"return recurseIntersection(node.getMinus(), sub);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,579,case BOTH :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,580,final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,581,"final SubHyperplane<S> plus  = recurseIntersection(node.getPlus(),  split.getPlus());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,582,"final SubHyperplane<S> minus = recurseIntersection(node.getMinus(), split.getMinus());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,583,if (plus == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,584,return minus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,585,} else if (minus == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,586,return plus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,587,} else {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,588,return plus.reunite(minus);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,590,default :
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,591,"return recurseIntersection(node.getPlus(),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,592,"recurseIntersection(node.getMinus(), sub));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,597,/** Transform a region.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,598,* <p>Applying a transform to a region consist in applying the
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,599,* transform to all the hyperplanes of the underlying BSP tree and
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,600,* of the boundary (and also to the sub-hyperplanes embedded in
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,601,* these hyperplanes) and to the barycenter. The instance is not
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,602,"* modified, a new instance is built.</p>"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,603,* @param transform transform to apply
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,604,"* @return a new region, resulting from the application of the"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,605,* transform to the instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,607,"public AbstractRegion<S, T> applyTransform(final Transform<S, T> transform) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,608,"return (AbstractRegion<S, T>) buildNew(recurseTransform(getTree(false), transform));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,611,/** Recursively transform an inside/outside BSP-tree.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,612,* @param node current BSP tree node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,613,* @param transform transform to apply
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,614,* @return a new tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,616,"@SuppressWarnings(""unchecked"")"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,617,"private BSPTree<S> recurseTransform(final BSPTree<S> node, final Transform<S, T> transform) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,619,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,620,return new BSPTree<S>(node.getAttribute());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,623,final SubHyperplane<S>  sub = node.getCut();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,624,"final SubHyperplane<S> tSub = ((AbstractSubHyperplane<S, T>) sub).applyTransform(transform);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,625,BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,626,if (attribute != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,627,final SubHyperplane<S> tPO = (attribute.getPlusOutside() == null) ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,628,"null : ((AbstractSubHyperplane<S, T>) attribute.getPlusOutside()).applyTransform(transform);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,629,final SubHyperplane<S> tPI = (attribute.getPlusInside()  == null) ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,630,"null  : ((AbstractSubHyperplane<S, T>) attribute.getPlusInside()).applyTransform(transform);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,631,"attribute = new BoundaryAttribute<S>(tPO, tPI);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,634,"return new BSPTree<S>(tSub,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,635,"recurseTransform(node.getPlus(),  transform),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,636,"recurseTransform(node.getMinus(), transform),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java,637,attribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,20,import org.apache.commons.math.geometry.partitioning.SubHyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,22,/** This class implements the dimension-independent parts of {@link SubHyperplane}.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,24,* <p>sub-hyperplanes are obtained when parts of an {@link
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,25,* Hyperplane hyperplane} are chopped off by other hyperplanes that
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,26,* intersect it. The remaining part is a convex region. Such objects
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,27,* appear in {@link BSPTree BSP trees} as the intersection of a cut
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,28,"* hyperplane with the convex region which it splits, the chopping"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,29,* hyperplanes are the cut hyperplanes closer to the tree root.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,31,* @param <S> Type of the embedding space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,33,* @version $Revision$
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,34,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,36,"public abstract class AbstractSubHyperplane<S extends Space, T extends Space>"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,37,implements SubHyperplane<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,39,/** Underlying hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,40,private final Hyperplane<S> hyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,42,/** Remaining region of the hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,43,private final Region<T> remainingRegion;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,45,/** Build a sub-hyperplane from an hyperplane and a region.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,46,* @param hyperplane underlying hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,47,* @param remainingRegion remaining region of the hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,49,"protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,50,final Region<T> remainingRegion) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,51,this.hyperplane      = hyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,52,this.remainingRegion = remainingRegion;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,55,/** Build a sub-hyperplane from an hyperplane and a region.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,56,* @param hyperplane underlying hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,57,* @param remainingRegion remaining region of the hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,59,"protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyperplane,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,60,final Region<T> remainingRegion);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,62,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,63,"public AbstractSubHyperplane<S, T> copySelf() {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,64,"return buildNew(hyperplane, remainingRegion);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,67,/** Get the underlying hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,68,* @return underlying hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,70,public Hyperplane<S> getHyperplane() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,71,return hyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,74,/** Get the remaining region of the hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,75,* <p>The returned region is expressed in the canonical hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,76,* frame and has the hyperplane dimension. For example a chopped
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,77,* hyperplane in the 3D euclidean is a 2D plane and the
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,78,* corresponding region is a convex 2D polygon.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,79,* @return remaining region of the hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,81,public Region<T> getRemainingRegion() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,82,return remainingRegion;
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,85,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,86,public double getSize() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,87,return remainingRegion.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,90,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,91,"public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,92,"@SuppressWarnings(""unchecked"")"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,93,"AbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,94,"return buildNew(hyperplane,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,95,"new RegionFactory<T>().union(remainingRegion, o.remainingRegion));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,98,/** Apply a transform to the instance.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,99,* <p>The instance must be a (D-1)-dimension sub-hyperplane with
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,100,* respect to the transform <em>not</em> a (D-2)-dimension
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,101,* sub-hyperplane the transform knows how to transform by
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,102,* itself. The transform will consist in transforming first the
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,103,* hyperplane and then the all region using the various methods
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,104,* provided by the transform.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,105,* @param transform D-dimension transform to apply
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,106,* @return the transformed instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,108,"public AbstractSubHyperplane<S, T> applyTransform(final Transform<S, T> transform) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,109,final Hyperplane<S> tHyperplane = transform.apply(hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,110,final BSPTree<T> tTree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,111,"recurseTransform(remainingRegion.getTree(false), tHyperplane, transform);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,112,"return buildNew(tHyperplane, remainingRegion.buildNew(tTree));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,115,/** Recursively transform a BSP-tree from a sub-hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,116,* @param node current BSP tree node
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,117,* @param transformed image of the instance hyperplane by the transform
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,118,* @param transform transform to apply
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,119,* @return a new tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,121,"private BSPTree<T> recurseTransform(final BSPTree<T> node,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,122,"final Hyperplane<S> transformed,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,123,"final Transform<S, T> transform) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,124,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,125,return new BSPTree<T>(node.getAttribute());
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,128,"@SuppressWarnings(""unchecked"")"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,129,BoundaryAttribute<T> attribute =
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,130,(BoundaryAttribute<T>) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,131,if (attribute != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,132,final SubHyperplane<T> tPO = (attribute.getPlusOutside() == null) ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,133,"null : transform.apply(attribute.getPlusOutside(), hyperplane, transformed);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,134,final SubHyperplane<T> tPI = (attribute.getPlusInside() == null) ?
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,135,"null : transform.apply(attribute.getPlusInside(), hyperplane, transformed);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,136,"attribute = new BoundaryAttribute<T>(tPO, tPI);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,139,"return new BSPTree<T>(transform.apply(node.getCut(), hyperplane, transformed),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,140,"recurseTransform(node.getPlus(), transformed, transform),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,141,"recurseTransform(node.getMinus(), transformed, transform),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,142,attribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,146,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,147,public abstract Side side(Hyperplane<S> hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,149,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,150,public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,152,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,153,public boolean isEmpty() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java,154,return remainingRegion.isEmpty();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,19,mport org.apache.commons.math.geometry.partitioning.Hyperplane.Side;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,19,import org.apache.commons.math.geometry.Vector;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,20,import org.apache.commons.math.geometry.Space;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,56, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,57,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,59,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,60,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,58,ublic class BSPTree {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,62,public class BSPTree<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,61,rivate SubHyperplane cut;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,65,private SubHyperplane<S> cut;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,64,rivate BSPTree plus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,68,private BSPTree<S> plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,67,rivate BSPTree minus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,71,private BSPTree<S> minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,70,rivate BSPTree parent;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,74,private BSPTree<S> parent;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,109,"ublic BSPTree(final SubHyperplane cut, final BSPTree plus, final BSPTree minus,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,113,"public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,143,ublic boolean insertCut(final Hyperplane hyperplane) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,147,public boolean insertCut(final Hyperplane<S> hyperplane) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,150,inal SubHyperplane chopped = fitToCell(new SubHyperplane(hyperplane));
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,151,f (chopped.getRemainingRegion().isEmpty()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,154,final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane());
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,155,if (chopped.isEmpty()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,159,lus         = new BSPTree();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,163,plus         = new BSPTree<S>();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,161,inus        = new BSPTree();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,165,minus        = new BSPTree<S>();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,174,ublic BSPTree copySelf() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,178,public BSPTree<S> copySelf() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,177,eturn new BSPTree(attribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,181,return new BSPTree<S>(attribute);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,180,"eturn new BSPTree(cut.copySelf(), plus.copySelf(), minus.copySelf(),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,184,"return new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,188,ublic SubHyperplane getCut() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,192,public SubHyperplane<S> getCut() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,196,ublic BSPTree getPlus() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,200,public BSPTree<S> getPlus() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,204,ublic BSPTree getMinus() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,208,public BSPTree<S> getMinus() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,211,ublic BSPTree getParent() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,215,public BSPTree<S> getParent() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,236,ublic void visit(final BSPTreeVisitor visitor) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,240,public void visit(final BSPTreeVisitor<S> visitor) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,286,rivate SubHyperplane fitToCell(final SubHyperplane sub) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,287,ubHyperplane s = sub;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,288,or (BSPTree tree = this; tree.parent != null; tree = tree.parent) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,290,private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,291,SubHyperplane<S> s = sub;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,292,for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,290, = tree.parent.cut.getHyperplane().split(s).getPlus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,294,s = s.split(tree.parent.cut.getHyperplane()).getPlus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,292, = tree.parent.cut.getHyperplane().split(s).getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,296,s = s.split(tree.parent.cut.getHyperplane()).getMinus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,305,ublic BSPTree getCell(final Point point) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,309,public BSPTree<S> getCell(final Vector<S> point) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,359,"ublic BSPTree merge(final BSPTree tree, final LeafMerger leafMerger) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,363,"public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,378,"rivate BSPTree merge(final BSPTree tree, final LeafMerger leafMerger,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,379,"inal BSPTree parentTree, final boolean isPlusChild) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,382,"private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,383,"final BSPTree<S> parentTree, final boolean isPlusChild) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,388,inal BSPTree merged = tree.split(cut);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,392,final BSPTree<S> merged = tree.split(cut);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,404,erged.fitToCell(new SubHyperplane(merged.cut.getHyperplane()));
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,408,merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,430,* @param <SpacePoint> Type of the space points.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,431,* @param <SubSpacePoint> Type of the sub-space points.
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,428,ublic static interface LeafMerger {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,434,public static interface LeafMerger<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,459,"SPTree merge(BSPTree leaf, BSPTree tree,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,460,"SPTree parentTree, boolean isPlusChild,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,461,oolean leafFromInstance);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,465,"BSPTree<S> merge(BSPTree<S> leaf, BSPTree<S> tree, BSPTree<S> parentTree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,466,"boolean isPlusChild, boolean leafFromInstance);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,483,ublic BSPTree split(final SubHyperplane sub) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,488,public BSPTree<S> split(final SubHyperplane<S> sub) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,486,"eturn new BSPTree(sub, copySelf(), new BSPTree(attribute), null);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,491,"return new BSPTree<S>(sub, copySelf(),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,492,"new BSPTree<S>(attribute), null);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,489,inal Hyperplane cHyperplane = cut.getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,490,inal Hyperplane sHyperplane = sub.getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,491,witch (cHyperplane.side(sub)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,495,final Hyperplane<S> cHyperplane = cut.getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,496,final Hyperplane<S> sHyperplane = sub.getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,497,switch (sub.side(cHyperplane)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,494,inal BSPTree split = plus.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,495,f (sHyperplane.side(cut) == Side.PLUS) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,496,"plit.plus = new BSPTree(cut.copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,497,"plit.plus, minus.copySelf(), attribute);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,500,final BSPTree<S> split = plus.split(sub);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,501,if (cut.side(sHyperplane) == Side.PLUS) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,502,split.plus =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,503,"new BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,501,"plit.minus = new BSPTree(cut.copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,502,"plit.minus, minus.copySelf(), attribute);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,507,split.minus =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,508,"new BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,510,inal BSPTree split = minus.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,511,f (sHyperplane.side(cut) == Side.PLUS) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,512,"plit.plus = new BSPTree(cut.copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,513,"lus.copySelf(), split.plus, attribute);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,516,final BSPTree<S> split = minus.split(sub);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,517,if (cut.side(sHyperplane) == Side.PLUS) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,518,split.plus =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,519,"new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,517,"plit.minus = new BSPTree(cut.copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,518,"lus.copySelf(), split.minus, attribute);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,523,split.minus =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,524,"new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,526,inal Hyperplane.SplitSubHyperplane cutParts = sHyperplane.split(cut);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,527,inal Hyperplane.SplitSubHyperplane subParts = cHyperplane.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,528,"inal BSPTree split = new BSPTree(sub,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,529,"lus.split(subParts.getPlus()),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,530,"inus.split(subParts.getMinus()),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,531,ull);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,532,final SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,533,final SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,534,final BSPTree<S> split =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,535,"new BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,536,null);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,534,inal BSPTree tmp       = split.plus.minus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,539,final BSPTree<S> tmp    = split.plus.minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,545,"ew BSPTree(sub, plus.copySelf(), minus.copySelf(), attribute) :"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,546,"ew BSPTree(sub, minus.copySelf(), plus.copySelf(), attribute);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,550,"new BSPTree<S>(sub, plus.copySelf(),  minus.copySelf(), attribute) :"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,551,"new BSPTree<S>(sub, minus.copySelf(), plus.copySelf(),  attribute);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,560,"ublic void insertInTree(final BSPTree parentTree, final boolean isPlusChild) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,565,"public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,576,or (BSPTree tree = this; tree.parent != null; tree = tree.parent) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,581,for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,579,inal Hyperplane hyperplane = tree.parent.cut.getHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,584,final Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,584,ut = hyperplane.split(cut).getPlus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,589,cut = cut.split(hyperplane).getPlus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,588,ut = hyperplane.split(cut).getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,593,cut = cut.split(hyperplane).getMinus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,605," the minus side of the chopping hyperplane are disgarded, only the"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,610,"* the minus side of the chopping hyperplane are discarded, only the"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,609,rivate void chopOffMinus(final Hyperplane hyperplane) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,614,private void chopOffMinus(final Hyperplane<S> hyperplane) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,611,ut = hyperplane.split(cut).getPlus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,616,cut = cut.split(hyperplane).getPlus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,619," the plus side of the chopping hyperplane are disgarded, only the"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,624,"* the plus side of the chopping hyperplane are discarded, only the"
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,623,rivate void chopOffPlus(final Hyperplane hyperplane) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,628,private void chopOffPlus(final Hyperplane<S> hyperplane) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,625,ut = hyperplane.split(cut).getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java,630,cut = cut.split(hyperplane).getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,43,* @param <SpacePoint> Type of the space points.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,44,* @param <SubSpacePoint> Type of the sub-space points.
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,44, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,49,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,50,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,46,ublic interface BSPTreeVisitor {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,52,public interface BSPTreeVisitor<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,93,rder visitOrder(BSPTree node);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,99,Order visitOrder(BSPTree<S> node);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,102,oid visitInternalNode(BSPTree node);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,108,void visitInternalNode(BSPTree<S> node);
False,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,108,oid visitLeafNode(BSPTree node);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java,114,void visitLeafNode(BSPTree<S> node);
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,21,/** Class holding boundary attributes.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,22,* <p>This class is used for the attributes associated with the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,23,* nodes of region boundary shell trees returned by the {@link
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,24,* Region#getTree Region.getTree}. It contains the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,25,* parts of the node cut sub-hyperplane that belong to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,26,* boundary.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,27,"* <p>This class is a simple placeholder, it does not provide any"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,28,* processing methods.</p>
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,29,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,30,* @see Region#getTree
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,31,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,32,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,34,public class BoundaryAttribute<S extends Space> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,36,/** Part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,37,* boundary and has the outside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,38,* its underlying hyperplane (may be null).
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,40,final SubHyperplane<S> plusOutside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,42,/** Part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,43,* boundary and has the inside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,44,* its underlying hyperplane (may be null).
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,46,final SubHyperplane<S> plusInside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,48,/** Simple constructor.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,49,* @param plusOutside part of the node cut sub-hyperplane that
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,50,* belongs to the boundary and has the outside of the region on
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,51,* the plus side of its underlying hyperplane (may be null)
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,52,* @param plusInside part of the node cut sub-hyperplane that
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,53,* belongs to the boundary and has the inside of the region on the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,54,* plus side of its underlying hyperplane (may be null)
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,56,"public BoundaryAttribute(final SubHyperplane<S> plusOutside,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,57,final SubHyperplane<S> plusInside) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,58,this.plusOutside = plusOutside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,59,this.plusInside  = plusInside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,62,/** Get the part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,63,* boundary and has the outside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,64,* its underlying hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,65,* @return part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,66,* boundary and has the outside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,67,* its underlying hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,69,public SubHyperplane<S> getPlusOutside() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,70,return plusOutside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,73,/** Get the part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,74,* boundary and has the inside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,75,* its underlying hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,76,* @return part of the node cut sub-hyperplane that belongs to the
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,77,* boundary and has the inside of the region on the plus side of
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,78,* its underlying hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,80,public SubHyperplane<S> getPlusInside() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java,81,return plusInside;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,21,/** Visitor computing the boundary size.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,22,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,23,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,24,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,26,class BoundarySizeVisitor<S extends Space> implements BSPTreeVisitor<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,28,/** Size of the boundary. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,29,private double boundarySize;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,31,/** Simple constructor.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,33,public BoundarySizeVisitor() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,34,boundarySize = 0;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,37,/** {@inheritDoc}*/
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,38,public Order visitOrder(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,39,return Order.MINUS_SUB_PLUS;
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,42,/** {@inheritDoc}*/
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,43,public void visitInternalNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,44,"@SuppressWarnings(""unchecked"")"
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,45,final BoundaryAttribute<S> attribute =
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,46,(BoundaryAttribute<S>) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,47,if (attribute.plusOutside != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,48,boundarySize += attribute.plusOutside.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,50,if (attribute.plusInside != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,51,boundarySize += attribute.plusInside.getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,55,/** {@inheritDoc}*/
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,56,public void visitLeafNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,59,/** Get the size of the boundary.
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,60,* @return size of the boundary
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,62,public double getSize() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java,63,return boundarySize;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,19,import org.apache.commons.math.geometry.Space;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,20, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,22,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,23,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,24,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,22,lass Characterization {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,26,class Characterization<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,25,rivate SubHyperplane in;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,29,private SubHyperplane<S> in;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,28,rivate SubHyperplane out;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,32,private SubHyperplane<S> out;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,41,eturn (in != null) && (!in.getRemainingRegion().isEmpty());
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,45,return (in != null) && (!in.isEmpty());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,47,ublic SubHyperplane getIn() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,51,public SubHyperplane<S> getIn() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,55,eturn (out != null) && (!out.getRemainingRegion().isEmpty());
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,59,return (out != null) && (!out.isEmpty());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,61,ublic SubHyperplane getOut() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,65,public SubHyperplane<S> getOut() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,70,"ublic void add(final SubHyperplane sub, final boolean inside) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,74,"public void add(final SubHyperplane<S> sub, final boolean inside) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,75,"n = new SubHyperplane(in.getHyperplane(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,76,"egion.union(in.getRemainingRegion(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,77,ub.getRemainingRegion()));
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,79,in = in.reunite(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,83,"ut = new SubHyperplane(out.getHyperplane(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,84,"egion.union(out.getRemainingRegion(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,85,ub.getRemainingRegion()));
True,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java,85,out = out.reunite(sub);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,19,import org.apache.commons.math.geometry.Vector;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,20,import org.apache.commons.math.geometry.Space;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,30, @version $Revision$ $Date$
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,32,ublic interface Hyperplane extends SubSpace {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,34,** Enumerate for specifying sides of the hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,35,num Side {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,37,** Code for the plus side of the hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,38,"LUS,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,40,** Code for the minus side of the hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,41,"INUS,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,43,** Code for elements crossing the hyperplane from plus to minus side. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,44,"OTH,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,33,* @param <SpacePoint> Type of the space points.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,46,** Code for the hyperplane itself. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,47,YPER;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,35,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,36,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,38,public interface Hyperplane<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,57,yperplane copySelf();
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,46,Hyperplane<S> copySelf();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,67,ouble getOffset(Point point);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,56,double getOffset(Vector<S> point);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,81,oolean sameOrientationAs(Hyperplane other);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,70,boolean sameOrientationAs(Hyperplane<S> other);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,83,** Build the sub-space shared by the instance and another hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,84, @param other other hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,85, @return a sub-space at the intersection of the instance and the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,86, other sub-space (it has a dimension one unit less than the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,87, instance)
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,72,/** Build a sub-hyperplane covering the whole hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,73,* @return a sub-hyperplane covering the whole hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,89,ubSpace intersection(Hyperplane other);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,91,** Build a region covering the whole hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,92, <p>The region build is restricted to the sub-space defined by the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,93, hyperplane. This means that the regions points are consistent
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,94, with the argument of the {@link SubSpace#toSpace toSpace} method
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,95, and with the return value of the {@link SubSpace#toSubSpace
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,96, toSubSpace} method.<p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,97, @return a region covering the whole hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,99,egion wholeHyperplane();
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,75,SubHyperplane<S> wholeHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,104,egion wholeSpace();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,106,** Compute the relative position of a sub-hyperplane with respect
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,107, to the instance.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,108, @param sub sub-hyperplane to check
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,109," @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,110, {@link Side#HYPER}
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,112,ide side(SubHyperplane sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,114,** Split a sub-hyperplane in two parts by the instance.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,115, @param sub sub-hyperplane to split
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,116, @return an object containing both the part of the sub-hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,117, on the plus side of the instance and the part of the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,118, sub-hyperplane on the minus side of the instance
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,120,plitSubHyperplane split(SubHyperplane sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,122,** Class holding the results of the {@link Hyperplane#split Hyperplane.split}
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,123, method. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,124,lass SplitSubHyperplane {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,126,** Part of the sub-hyperplane on the plus side of the splitting hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,127,rivate final SubHyperplane plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,129,** Part of the sub-hyperplane on the minus side of the splitting hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,130,rivate final SubHyperplane minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,132,** Build a SplitSubHyperplane from its parts.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,133, @param plus part of the sub-hyperplane on the plus side of the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,134, splitting hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,135, @param minus part of the sub-hyperplane on the minus side of the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,136, splitting hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,138,"ublic SplitSubHyperplane(final SubHyperplane plus, final SubHyperplane minus) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,139,his.plus  = plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,140,his.minus = minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,143,** Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,144, @return part of the sub-hyperplane on the plus side of the splitting hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,146,ublic SubHyperplane getPlus() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,147,eturn plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,150,** Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,151, @return part of the sub-hyperplane on the minus side of the splitting hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,153,ublic SubHyperplane getMinus() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,154,eturn minus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java,80,Region<S> wholeSpace();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,19,mport java.util.Collection;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,20,mport java.util.TreeSet;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,21,mport java.util.Comparator;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,22,mport java.util.Iterator;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,23,mport java.util.ArrayList;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,20,import org.apache.commons.math.geometry.Vector;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,25,** This class represent a region of a space as a partition.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,22,/** This interface represents a region of a space as a partition.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,45, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,42,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,44,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,45,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,47,ublic abstract class Region {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,47,public interface Region<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,61,** Inside/Outside BSP tree. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,62,rivate BSPTree tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,64,** Size of the instance. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,65,rivate double size;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,67,** Barycenter. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,68,rivate Point barycenter;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,70,** Build a region representing the whole space.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,72,rotected Region() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,73,ree = new BSPTree(Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,76,** Build a region from an inside/outside BSP tree.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,77, <p>The leaf nodes of the BSP tree <em>must</em> have a
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,78, {@code Boolean} attribute representing the inside status of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,79," the corresponding cell (true for inside cells, false for outside"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,80," cells). In order to avoid building too many small objects, it is"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,81, recommended to use the predefined constants
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,82, {@code Boolean.TRUE} and {@code Boolean.FALSE}. The
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,83, tree also <em>must</em> have either null internal nodes or
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,84, internal nodes representing the boundary as specified in the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,85, {@link #getTree getTree} method).</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,86, @param tree inside/outside BSP tree representing the region
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,88,rotected Region(final BSPTree tree) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,89,his.tree = tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,92,** Build a Region from a Boundary REPresentation (B-rep).
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,93, <p>The boundary is provided as a collection of {@link
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,94, SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,95, interior part of the region on its minus side and the exterior on
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,96, its plus side.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,97," <p>The boundary elements can be in any order, and can form"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,98, several non-connected sets (like for example polygons with holes
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,99, or a set of disjoints polyhedrons considered as a whole). In
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,100," fact, the elements do not even need to be connected together"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,101," (their topological connections are not used here). However, if the"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,102, boundary does not really separate an inside open from an outside
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,103," open (open having here its topological meaning), then subsequent"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,104, calls to the {@link #checkPoint(Point) checkPoint} method will not be
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,105, meaningful anymore.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,106," <p>If the boundary is empty, the region will represent the whole"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,107, space.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,108," @param boundary collection of boundary elements, as a"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,109, collection of {@link SubHyperplane SubHyperplane} objects
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,111,rotected Region(final Collection<SubHyperplane> boundary) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,113,f (boundary.size() == 0) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,115,/ the tree represents the whole space
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,116,ree = new BSPTree(Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,118, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,120,/ sort the boundary elements in decreasing size order
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,121,"/ (we don't want equal size elements to be removed, so"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,122,/ we use a trick to fool the TreeSet)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,123,inal TreeSet<SubHyperplane> ordered = new TreeSet<SubHyperplane>(new Comparator<SubHyperplane>() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,124,"ublic int compare(final SubHyperplane o1, final SubHyperplane o2) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,125,inal double size1 = o1.getRemainingRegion().getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,126,inal double size2 = o2.getRemainingRegion().getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,127,eturn (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,130,rdered.addAll(boundary);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,132,/ build the tree top-down
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,133,ree = new BSPTree();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,134,"nsertCuts(tree, ordered);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,136,/ set up the inside/outside flags
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,137,ree.visit(new BSPTreeVisitor() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,139,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,140,ublic Order visitOrder(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,141,eturn Order.PLUS_SUB_MINUS;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,144,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,145,ublic void visitInternalNode(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,148,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,149,ublic void visitLeafNode(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,150,ode.setAttribute((node == node.getParent().getPlus()) ?
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,151,oolean.FALSE : Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,175,ublic abstract Region buildNew(BSPTree newTree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,177,** Recursively build a tree by inserting cut sub-hyperplanes.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,178, @param node current tree node (it is a leaf node at the beginning
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,179, of the call)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,180, @param boundary collection of edges belonging to the cell defined
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,181, by the node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,183,"rivate void insertCuts(final BSPTree node, final Collection<SubHyperplane> boundary) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,185,inal Iterator<SubHyperplane> iterator = boundary.iterator();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,187,/ build the current level
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,188,yperplane inserted = null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,189,hile ((inserted == null) && iterator.hasNext()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,190,nserted = iterator.next().getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,191,f (!node.insertCut(inserted.copySelf())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,192,nserted = null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,196,f (!iterator.hasNext()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,197,eturn;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,200,/ distribute the remaining edges in the two sub-trees
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,201,inal ArrayList<SubHyperplane> plusList  = new ArrayList<SubHyperplane>();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,202,inal ArrayList<SubHyperplane> minusList = new ArrayList<SubHyperplane>();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,203,hile (iterator.hasNext()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,204,inal SubHyperplane other = iterator.next();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,205,witch (inserted.side(other)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,206,ase PLUS:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,207,lusList.add(other);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,208,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,209,ase MINUS:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,210,inusList.add(other);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,211,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,212,ase BOTH:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,213,inal Hyperplane.SplitSubHyperplane split = inserted.split(other);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,214,lusList.add(split.getPlus());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,215,inusList.add(split.getMinus());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,216,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,217,efault:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,218,/ ignore the sub-hyperplanes belonging to the cut hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,222,/ recurse through lower levels
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,223,"nsertCuts(node.getPlus(),  plusList);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,224,"nsertCuts(node.getMinus(), minusList);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,228,** Build a convex region from a collection of bounding hyperplanes.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,229, @param hyperplanes collection of bounding hyperplanes
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,230," @return a new convex region, or null if the collection is empty"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,232,ublic static Region buildConvex(final Collection<Hyperplane> hyperplanes) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,233,f (hyperplanes.isEmpty()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,234,eturn null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,237,/ use the first hyperplane to build the right class
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,238,inal Region region = hyperplanes.iterator().next().wholeSpace();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,240,/ chop off parts of the space
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,241,SPTree node = region.tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,242,ode.setAttribute(Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,243,or (final Hyperplane hyperplane : hyperplanes) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,244,f (node.insertCut(hyperplane)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,245,ode.setAttribute(null);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,246,ode.getPlus().setAttribute(Boolean.FALSE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,247,ode = node.getMinus();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,248,ode.setAttribute(Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,252,eturn region;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,77,Region<S> buildNew(BSPTree<S> newTree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,263,ublic Region copySelf() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,264,eturn buildNew(tree.copySelf());
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,86,Region<S> copySelf();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,270,ublic boolean isEmpty() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,271,eturn isEmpty(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,91,boolean isEmpty();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,281,ublic static boolean isEmpty(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,283,/ we use a recursive function rather than the BSPTreeVisitor
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,284,/ interface because we can stop visiting the tree as soon as we
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,285,/ have found an inside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,287,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,288,"/ if we find an inside node, the region is not empty"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,289,eturn !isInside(node);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,292,/ check both sides of the sub-tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,293,eturn isEmpty(node.getMinus()) && isEmpty(node.getPlus());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,297,** Check a leaf node inside attribute.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,298, @param node leaf node to check
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,299, @return true if the leaf node is an inside node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,301,rivate static boolean isInside(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,302,eturn (Boolean) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,100,boolean isEmpty(final BSPTree<S> node);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,309,ublic boolean contains(final Region region) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,310,"eturn difference(region, this).isEmpty();"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,106,boolean contains(final Region<S> region);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,318,ublic Location checkPoint(final Point point) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,319,"eturn checkPoint(tree, point);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,322,** Check a point with respect to the region starting at a given node.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,323, @param node root node of the region
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,324, @param point point to check
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,325, @return a code representing the point status: either {@link
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,326," Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,328,"rotected Location checkPoint(final BSPTree node, final Point point) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,329,inal BSPTree cell = node.getCell(point);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,330,f (cell.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,331,"/ the point is in the interior of a cell, just check the attribute"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,332,eturn isInside(cell) ? Location.INSIDE : Location.OUTSIDE;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,335,"/ the point is on a cut-sub-hyperplane, is it on a boundary ?"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,336,"inal Location minusCode = checkPoint(cell.getMinus(), point);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,337,"inal Location plusCode  = checkPoint(cell.getPlus(),  point);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,338,eturn (minusCode == plusCode) ? minusCode : Location.BOUNDARY;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,342,** Get the complement of the region (exchanged interior/exterior).
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,343," <p>The instance is not modified, a new region is built.</p>"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,344," @return a new region, complement of the instance"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,346,ublic Region getComplement() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,347,eturn buildNew(recurseComplement(tree));
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,350,** Recursively build the complement of a BSP tree.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,351, @param node current node of the original tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,352," @return new tree, complement of the node"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,354,rivate static BSPTree recurseComplement(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,355,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,356,eturn new BSPTree(isInside(node) ? Boolean.FALSE : Boolean.TRUE);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,359,oundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,360,f (attribute != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,361,inal SubHyperplane plusOutside =
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,362,attribute.plusInside == null) ? null : attribute.plusInside.copySelf();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,363,inal SubHyperplane plusInside  =
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,364,attribute.plusOutside == null) ? null : attribute.plusOutside.copySelf();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,365,"ttribute = new BoundaryAttribute(plusOutside, plusInside);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,368,"eturn new BSPTree(node.getCut().copySelf(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,369,"ecurseComplement(node.getPlus()),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,370,"ecurseComplement(node.getMinus()),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,371,ttribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,113,Location checkPoint(final Vector<S> point);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,414,ublic BSPTree getTree(final boolean includeBoundaryAttributes) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,415,f (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,416,/ we need to compute the boundary attributes
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,417,ecurseBuildBoundary(tree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,419,eturn tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,422,** Class holding boundary attributes.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,423, <p>This class is used for the attributes associated with the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,424, nodes of region boundary shell trees returned by the {@link
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,425, Region#getTree Region.getTree}. It contains the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,426, parts of the node cut sub-hyperplane that belong to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,427, boundary.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,428," <p>This class is a simple placeholder, it does not provide any"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,429, processing methods.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,430, @see Region#getTree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,432,ublic static class BoundaryAttribute {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,434,** Part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,435, boundary and has the outside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,436, its underlying hyperplane (may be null).
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,438,rivate final SubHyperplane plusOutside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,440,** Part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,441, boundary and has the inside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,442, its underlying hyperplane (may be null).
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,444,rivate final SubHyperplane plusInside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,446,** Simple constructor.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,447, @param plusOutside part of the node cut sub-hyperplane that
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,448, belongs to the boundary and has the outside of the region on
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,449, the plus side of its underlying hyperplane (may be null)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,450, @param plusInside part of the node cut sub-hyperplane that
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,451, belongs to the boundary and has the inside of the region on the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,452, plus side of its underlying hyperplane (may be null)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,454,"ublic BoundaryAttribute(final SubHyperplane plusOutside,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,455,inal SubHyperplane plusInside) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,456,his.plusOutside = plusOutside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,457,his.plusInside  = plusInside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,460,** Get the part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,461, boundary and has the outside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,462, its underlying hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,463, @return part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,464, boundary and has the outside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,465, its underlying hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,467,ublic SubHyperplane getPlusOutside() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,468,eturn plusOutside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,471,** Get the part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,472, boundary and has the inside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,473, its underlying hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,474, @return part of the node cut sub-hyperplane that belongs to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,475, boundary and has the inside of the region on the plus side of
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,476, its underlying hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,478,ublic SubHyperplane getPlusInside() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,479,eturn plusInside;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,485,** Recursively build the boundary shell tree.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,486, @param node current node in the inout tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,488,rivate void recurseBuildBoundary(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,489,f (node.getCut() != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,491,ubHyperplane plusOutside = null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,492,ubHyperplane plusInside  = null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,494,"/ characterize the cut sub-hyperplane,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,495,/ first with respect to the plus sub-tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,496,inal Characterization plusChar = new Characterization();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,497,"haracterize(node.getPlus(), node.getCut().copySelf(), plusChar);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,499,f (plusChar.hasOut()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,500,/ plusChar.out corresponds to a subset of the cut
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,501,/ sub-hyperplane known to have outside cells on its plus
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,502,"/ side, we want to check if parts of this subset do have"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,503,/ inside cells on their minus side
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,504,inal Characterization minusChar = new Characterization();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,505,"haracterize(node.getMinus(), plusChar.getOut(), minusChar);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,506,f (minusChar.hasIn()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,507,lusOutside = minusChar.getIn();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,511,f (plusChar.hasIn()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,512,/ plusChar.in corresponds to a subset of the cut
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,513,/ sub-hyperplane known to have inside cells on its plus
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,514,"/ side, we want to check if parts of this subset do have"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,515,/ outside cells on their minus side
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,516,inal Characterization minusChar = new Characterization();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,517,"haracterize(node.getMinus(), plusChar.getIn(), minusChar);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,518,f (minusChar.hasOut()) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,519,lusInside = minusChar.getOut();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,523,"ode.setAttribute(new BoundaryAttribute(plusOutside, plusInside));"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,524,ecurseBuildBoundary(node.getPlus());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,525,ecurseBuildBoundary(node.getMinus());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,530,** Filter the parts of an hyperplane belonging to the boundary.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,531, <p>The filtering consist in splitting the specified
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,532, sub-hyperplane into several parts lying in inside and outside
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,533, cells of the tree. The principle is to call this method twice for
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,534," each cut sub-hyperplane in the tree, once one the plus node and"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,535, once on the minus node. The parts that have the same flag
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,536, (inside/inside or outside/outside) do not belong to the boundary
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,537, while parts that have different flags (inside/outside or
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,538, outside/inside) do belong to the boundary.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,539, @param node current BSP tree node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,540, @param sub sub-hyperplane to characterize
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,541, @param characterization placeholder where to put the characterized parts
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,543,"rivate static void characterize(final BSPTree node, final SubHyperplane sub,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,544,inal Characterization characterization) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,545,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,546,/ we have reached a leaf node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,547,inal boolean inside = (Boolean) node.getAttribute();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,548,"haracterization.add(sub, inside);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,549, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,550,inal Hyperplane hyperplane = node.getCut().getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,551,witch (hyperplane.side(sub)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,552,ase PLUS:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,553,"haracterize(node.getPlus(), sub, characterization);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,554,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,555,ase MINUS:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,556,"haracterize(node.getMinus(), sub, characterization);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,557,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,558,ase BOTH:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,559,inal Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,560,"haracterize(node.getPlus(),  split.getPlus(),  characterization);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,561,"haracterize(node.getMinus(), split.getMinus(), characterization);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,562,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,563,efault:
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,564,/ this should not happen
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,565,"hrow new RuntimeException(""internal error"");"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,154,BSPTree<S> getTree(final boolean includeBoundaryAttributes);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,574,ublic double getBoundarySize() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,575,inal BoundarySizeVisitor visitor = new BoundarySizeVisitor();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,576,etTree(true).visit(visitor);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,577,eturn visitor.getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,580,** Visitor computing the boundary size. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,581,rivate static class BoundarySizeVisitor implements BSPTreeVisitor {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,583,** Size of the boundary. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,584,rivate double boundarySize;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,586,** Simple constructor.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,588,ublic BoundarySizeVisitor() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,589,oundarySize = 0;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,592,** {@inheritDoc}*/
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,593,ublic Order visitOrder(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,594,eturn Order.MINUS_SUB_PLUS;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,597,** {@inheritDoc}*/
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,598,ublic void visitInternalNode(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,599,inal BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,600,f (attribute.plusOutside != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,601,oundarySize += attribute.plusOutside.getRemainingRegion().getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,603,f (attribute.plusInside != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,604,oundarySize += attribute.plusInside.getRemainingRegion().getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,608,** {@inheritDoc}*/
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,609,ublic void visitLeafNode(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,612,** Get the size of the boundary.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,613, @return size of the boundary
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,615,ublic double getSize() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,616,eturn boundarySize;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,160,double getBoundarySize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,625,ublic double getSize() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,626,f (barycenter == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,627,omputeGeometricalProperties();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,629,eturn size;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,632,** Set the size of the instance.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,633, @param size size of the instance
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,635,rotected void setSize(final double size) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,636,his.size = size;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,166,double getSize();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,642,ublic Point getBarycenter() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,643,f (barycenter == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,644,omputeGeometricalProperties();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,646,eturn barycenter;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,649,** Set the barycenter of the instance.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,650, @param barycenter barycenter of the instance
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,652,rotected void setBarycenter(final Point barycenter) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,653,his.barycenter = barycenter;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,656,** Compute some geometrical properties.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,657, <p>The properties to compute are the barycenter and the size.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,659,rotected abstract void computeGeometricalProperties();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,661,** Transform a region.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,662, <p>Applying a transform to a region consist in applying the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,663, transform to all the hyperplanes of the underlying BSP tree and
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,664, of the boundary (and also to the sub-hyperplanes embedded in
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,665, these hyperplanes) and to the barycenter. The instance is not
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,666," modified, a new instance is built.</p>"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,667, @param transform transform to apply
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,668," @return a new region, resulting from the application of the"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,669, transform to the instance
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,671,ublic Region applyTransform(final Transform transform) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,673,/ transform the BSP tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,674,"inal Region tRegion = buildNew(recurseTransform(tree, transform));"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,676,/ transform the barycenter
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,677,f (barycenter != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,678,Region.size = size;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,679,Region.barycenter = transform.apply(barycenter);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,682,eturn tRegion;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,686,** Recursively transform an inside/outside BSP-tree.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,687, @param node current BSP tree node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,688, @param transform transform to apply
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,689, @return a new tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,691,"rivate BSPTree recurseTransform(final BSPTree node, final Transform transform) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,693,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,694,eturn new BSPTree(node.getAttribute());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,697,inal SubHyperplane  sub = node.getCut();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,698,inal SubHyperplane tSub = sub.applyTransform(transform);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,699,oundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,700,f (attribute != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,701,inal SubHyperplane tPO =
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,702,attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().applyTransform(transform);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,703,inal SubHyperplane tPI =
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,704,attribute.getPlusInside()  == null) ? null  : attribute.getPlusInside().applyTransform(transform);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,705,"ttribute = new BoundaryAttribute(tPO, tPI);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,708,"eturn new BSPTree(tSub,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,709,"ecurseTransform(node.getPlus(),  transform),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,710,"ecurseTransform(node.getMinus(), transform),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,711,ttribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,171,Vector<S> getBarycenter();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,724,ublic Hyperplane.Side side(final Hyperplane hyperplane) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,725,inal Sides sides = new Sides();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,726,"ecurseSides(tree, new SubHyperplane(hyperplane), sides);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,727,eturn sides.plusFound() ?
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,728,sides.minusFound() ? Hyperplane.Side.BOTH  : Hyperplane.Side.PLUS) :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,729,sides.minusFound() ? Hyperplane.Side.MINUS : Hyperplane.Side.HYPER);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,732,** Search recursively for inside leaf nodes on each side of the given hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,734, <p>The algorithm used here is directly derived from the one
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,735, described in section III (<i>Binary Partitioning of a BSP
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,736," Tree</i>) of the Bruce Naylor, John Amanatides and William"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,737, Thibault paper <a
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,738," href=""http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf"">Merging"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,739, BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,740," '90, Computer Graphics 24(4), August 1990, pp 115-124, published"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,741, by the Association for Computing Machinery (ACM)..</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,743, @param node current BSP tree node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,744, @param sub sub-hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,745, @param sides object holding the sides found
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,747,"rivate void recurseSides(final BSPTree node, final SubHyperplane sub, final Sides sides) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,749,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,750,f (isInside(node)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,751,/ this is an inside cell expanding across the hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,752,ides.rememberPlusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,753,ides.rememberMinusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,755,eturn;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,758,inal Hyperplane hyperplane = node.getCut().getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,759,witch (hyperplane.side(sub)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,760,ase PLUS :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,761,/ the sub-hyperplane is entirely in the plus sub-tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,762,f (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,763,f (!isEmpty(node.getMinus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,764,ides.rememberPlusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,766, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,767,f (!isEmpty(node.getMinus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,768,ides.rememberMinusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,771,f (!(sides.plusFound() && sides.minusFound())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,772,"ecurseSides(node.getPlus(), sub, sides);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,774,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,775,ase MINUS :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,776,/ the sub-hyperplane is entirely in the minus sub-tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,777,f (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,778,f (!isEmpty(node.getPlus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,779,ides.rememberPlusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,781, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,782,f (!isEmpty(node.getPlus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,783,ides.rememberMinusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,786,f (!(sides.plusFound() && sides.minusFound())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,787,"ecurseSides(node.getMinus(), sub, sides);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,789,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,790,ase BOTH :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,791,/ the sub-hyperplane extends in both sub-trees
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,792,inal Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,794,/ explore first the plus sub-tree
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,795,"ecurseSides(node.getPlus(), split.getPlus(), sides);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,797,"/ if needed, explore the minus sub-tree"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,798,f (!(sides.plusFound() && sides.minusFound())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,799,"ecurseSides(node.getMinus(), split.getMinus(), sides);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,801,reak;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,802,efault :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,803,/ the sub-hyperplane and the cut sub-hyperplane share the same hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,804,f (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,805,f ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,806,ides.rememberPlusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,808,f ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,809,ides.rememberMinusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,811, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,812,f ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,813,ides.rememberMinusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,815,f ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,816,ides.rememberPlusFound();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,823,** Utility class holding the already found sides. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,824,rivate static final class Sides {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,826,** Indicator of inside leaf nodes found on the plus side. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,827,rivate boolean plusFound;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,829,** Indicator of inside leaf nodes found on the plus side. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,830,rivate boolean minusFound;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,832,** Simple constructor.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,834,ublic Sides() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,835,lusFound  = false;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,836,inusFound = false;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,839,** Remember the fact that inside leaf nodes have been found on the plus side.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,841,ublic void rememberPlusFound() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,842,lusFound = true;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,845,** Check if inside leaf nodes have been found on the plus side.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,846, @return true if inside leaf nodes have been found on the plus side
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,848,ublic boolean plusFound() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,849,eturn plusFound;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,852,** Remember the fact that inside leaf nodes have been found on the minus side.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,854,ublic void rememberMinusFound() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,855,inusFound = true;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,858,** Check if inside leaf nodes have been found on the minus side.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,859, @return true if inside leaf nodes have been found on the minus side
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,861,ublic boolean minusFound() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,862,eturn minusFound;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,182,Side side(final Hyperplane<S> hyperplane);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,873,ublic SubHyperplane intersection(final SubHyperplane sub) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,874,"eturn recurseIntersection(tree, sub);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,877,** Recursively compute the parts of a sub-hyperplane that are
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,878, contained in the region.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,879, @param node current BSP tree node
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,880, @param sub sub-hyperplane traversing the region
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,881, @return filtered sub-hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,883,"rivate SubHyperplane recurseIntersection(final BSPTree node, final SubHyperplane sub) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,885,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,886,eturn isInside(node) ? sub.copySelf() : null;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,889,inal Hyperplane hyperplane = node.getCut().getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,890,witch (hyperplane.side(sub)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,891,ase PLUS :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,892,"eturn recurseIntersection(node.getPlus(), sub);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,893,ase MINUS :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,894,"eturn recurseIntersection(node.getMinus(), sub);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,895,ase BOTH :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,896,inal Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,897,"inal SubHyperplane plus  = recurseIntersection(node.getPlus(),  split.getPlus());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,898,"inal SubHyperplane minus = recurseIntersection(node.getMinus(), split.getMinus());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,899,f (plus == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,900,eturn minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,901, else if (minus == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,902,eturn plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,903, else {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,904,"eturn new SubHyperplane(plus.getHyperplane(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,905,"egion.union(plus.getRemainingRegion(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,906,inus.getRemainingRegion()));
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,908,efault :
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,909,"eturn recurseIntersection(node.getPlus(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,910,"ecurseIntersection(node.getMinus(), sub));"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,915,** Compute the union of two regions.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,916, @param region1 first region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,917, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,918, @param region2 second region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,919, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,920," @return a new region, result of {@code region1 union region2}"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,922,"ublic static Region union(final Region region1, final Region region2) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,923,"inal BSPTree tree = region1.tree.merge(region2.tree, new UnionMerger());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,924,ree.visit(new InternalNodesCleaner());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,925,eturn region1.buildNew(tree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,928,** Compute the intersection of two regions.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,929, @param region1 first region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,930, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,931, @param region2 second region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,932, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,933," @return a new region, result of {@code region1 intersection region2}"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,935,"ublic static Region intersection(final Region region1, final Region region2) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,936,"inal BSPTree tree = region1.tree.merge(region2.tree, new IntersectionMerger());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,937,ree.visit(new InternalNodesCleaner());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,938,eturn region1.buildNew(tree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,941,** Compute the symmetric difference (exclusive or) of two regions.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,942, @param region1 first region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,943, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,944, @param region2 second region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,945, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,946," @return a new region, result of {@code region1 xor region2}"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,948,"ublic static Region xor(final Region region1, final Region region2) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,949,"inal BSPTree tree = region1.tree.merge(region2.tree, new XORMerger());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,950,ree.visit(new InternalNodesCleaner());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,951,eturn region1.buildNew(tree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,954,** Compute the difference of two regions.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,955, @param region1 first region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,956, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,957, @param region2 second region (will be unusable after the operation as
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,958, parts of it will be reused in the new region)
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,959," @return a new region, result of {@code region1 minus region2}"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,961,"ublic static Region difference(final Region region1, final Region region2) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,962,"inal BSPTree tree = region1.tree.merge(region2.tree, new DifferenceMerger());"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,963,ree.visit(new InternalNodesCleaner());
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,964,eturn region1.buildNew(tree);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,967,** Leaf node / tree merger for union operation. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,968,rivate static final class UnionMerger implements BSPTree.LeafMerger {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,969,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,970,"ublic BSPTree merge(final BSPTree leaf, final BSPTree tree,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,971,"inal BSPTree parentTree, final boolean isPlusChild,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,972,inal boolean leafFromInstance) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,973,f (isInside(leaf)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,974,/ the leaf node represents an inside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,975,"eaf.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,976,eturn leaf;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,978,/ the leaf node represents an outside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,979,"ree.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,980,eturn tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,984,** Leaf node / tree merger for intersection operation. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,985,rivate static final class IntersectionMerger implements BSPTree.LeafMerger {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,986,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,987,"ublic BSPTree merge(final BSPTree leaf, final BSPTree tree,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,988,"inal BSPTree parentTree, final boolean isPlusChild,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,989,inal boolean leafFromInstance) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,990,f (isInside(leaf)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,991,/ the leaf node represents an inside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,992,"ree.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,993,eturn tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,995,/ the leaf node represents an outside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,996,"eaf.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,997,eturn leaf;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1001,** Leaf node / tree merger for xor operation. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1002,rivate static final class XORMerger implements BSPTree.LeafMerger {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1003,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1004,"ublic BSPTree merge(final BSPTree leaf, final BSPTree tree,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1005,"inal BSPTree parentTree, final boolean isPlusChild,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1006,inal boolean leafFromInstance) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1007,SPTree t = tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1008,f (isInside(leaf)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1009,/ the leaf node represents an inside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1010, = recurseComplement(t);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1012,".insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1013,eturn t;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1017,** Leaf node / tree merger for difference operation.
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1018, <p>The algorithm used here is directly derived from the one
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1019, described in section III (<i>Binary Partitioning of a BSP
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1020," Tree</i>) of the Naylor, Amanatides and Thibault paper. An error"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1021, was detected and corrected in the figure 5.1 of the article for
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1022, merging leaf nodes with complete trees. Contrary to what is said
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1023," in the figure, the {@code ELSE} part of if is not the same"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1024, as the first part with {@code T1} and {@codeT2}
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1025, swapped. {@code T1} and {@codeT2} must be swapped
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1026, everywhere <em>except</em> in the {@code RETURN} part of the
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1027, {@code DIFFERENCE} operation: if {@codeT2} is an
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1028," in-cell, we must return {@code Complement_Bspt(T2)}, not"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1029," {@code Complement_Bspt(T1)}, and if {@codeT2} is an"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1030," out-cell, we must return {@code T1}, not {@codeT2}</p>"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1032,rivate static final class DifferenceMerger implements BSPTree.LeafMerger {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1033,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1034,"ublic BSPTree merge(final BSPTree leaf, final BSPTree tree,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1035,"inal BSPTree parentTree, final boolean isPlusChild,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1036,inal boolean leafFromInstance) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1037,f (isInside(leaf)) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1038,/ the leaf node represents an inside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1039,inal BSPTree argTree = recurseComplement(leafFromInstance ? tree : leaf);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1040,"rgTree.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1041,eturn argTree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1043,/ the leaf node represents an outside cell
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1044,inal BSPTree instanceTree = leafFromInstance ? leaf : tree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1045,"nstanceTree.insertInTree(parentTree, isPlusChild);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1046,eturn instanceTree;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1050,** Visitor removing internal nodes attributes. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1051,rivate static final class InternalNodesCleaner implements BSPTreeVisitor {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1053,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1054,ublic Order visitOrder(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1055,eturn Order.PLUS_SUB_MINUS;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1058,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1059,ublic void visitInternalNode(final BSPTree node) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1060,ode.setAttribute(null);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1063,** {@inheritDoc} */
False,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,1064,ublic void visitLeafNode(final BSPTree node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,src/main/java/org/apache/commons/math/geometry/partitioning/Region.java,190,SubHyperplane<S> intersection(final SubHyperplane<S> sub);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,19,import org.apache.commons.math.geometry.Space;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,21,/** This class is a factory for {@link Region}.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,23,* @param <S> Type of the space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,25,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,26,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,28,public class RegionFactory<S extends Space> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,30,/** Visitor removing internal nodes attributes. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,31,private final NodesCleaner nodeCleaner;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,33,/** Simple constructor.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,35,public RegionFactory() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,36,nodeCleaner = new NodesCleaner();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,39,/** Build a convex region from a collection of bounding hyperplanes.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,40,* @param hyperplanes collection of bounding hyperplanes
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,41,"* @return a new convex region, or null if the collection is empty"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,43,public Region<S> buildConvex(final Hyperplane<S> ... hyperplanes) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,44,if ((hyperplanes == null) || (hyperplanes.length == 0)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,45,return null;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,48,// use the first hyperplane to build the right class
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,49,final Region<S> region = hyperplanes[0].wholeSpace();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,51,// chop off parts of the space
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,52,BSPTree<S> node = region.getTree(false);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,53,node.setAttribute(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,54,for (final Hyperplane<S> hyperplane : hyperplanes) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,55,if (node.insertCut(hyperplane)) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,56,node.setAttribute(null);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,57,node.getPlus().setAttribute(Boolean.FALSE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,58,node = node.getMinus();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,59,node.setAttribute(Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,63,return region;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,67,/** Compute the union of two regions.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,68,* @param region1 first region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,69,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,70,* @param region2 second region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,71,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,72,"* @return a new region, result of {@code region1 union region2}"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,74,"public Region<S> union(final Region<S> region1, final Region<S> region2) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,75,final BSPTree<S> tree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,76,"region1.getTree(false).merge(region2.getTree(false), new UnionMerger());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,77,tree.visit(nodeCleaner);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,78,return region1.buildNew(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,81,/** Compute the intersection of two regions.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,82,* @param region1 first region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,83,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,84,* @param region2 second region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,85,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,86,"* @return a new region, result of {@code region1 intersection region2}"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,88,"public Region<S> intersection(final Region<S> region1, final Region<S> region2) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,89,final BSPTree<S> tree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,90,"region1.getTree(false).merge(region2.getTree(false), new IntersectionMerger());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,91,tree.visit(nodeCleaner);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,92,return region1.buildNew(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,95,/** Compute the symmetric difference (exclusive or) of two regions.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,96,* @param region1 first region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,97,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,98,* @param region2 second region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,99,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,100,"* @return a new region, result of {@code region1 xor region2}"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,102,"public Region<S> xor(final Region<S> region1, final Region<S> region2) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,103,final BSPTree<S> tree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,104,"region1.getTree(false).merge(region2.getTree(false), new XorMerger());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,105,tree.visit(nodeCleaner);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,106,return region1.buildNew(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,109,/** Compute the difference of two regions.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,110,* @param region1 first region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,111,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,112,* @param region2 second region (will be unusable after the operation as
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,113,* parts of it will be reused in the new region)
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,114,"* @return a new region, result of {@code region1 minus region2}"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,116,"public Region<S> difference(final Region<S> region1, final Region<S> region2) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,117,final BSPTree<S> tree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,118,"region1.getTree(false).merge(region2.getTree(false), new DifferenceMerger());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,119,tree.visit(nodeCleaner);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,120,return region1.buildNew(tree);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,123,/** Get the complement of the region (exchanged interior/exterior).
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,124,"* @param region region to complement, it will not modified, a new"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,125,* region independent region will be built
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,126,"* @return a new region, complement of the specified one"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,128,public Region<S> getComplement(final Region<S> region) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,129,return region.buildNew(recurseComplement(region.getTree(false)));
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,132,/** Recursively build the complement of a BSP tree.
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,133,* @param node current node of the original tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,134,"* @return new tree, complement of the node"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,136,private BSPTree<S> recurseComplement(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,137,if (node.getCut() == null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,138,return new BSPTree<S>(((Boolean) node.getAttribute()) ? Boolean.FALSE : Boolean.TRUE);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,141,"@SuppressWarnings(""unchecked"")"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,142,BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,143,if (attribute != null) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,144,final SubHyperplane<S> plusOutside =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,145,(attribute.getPlusInside() == null) ? null : attribute.getPlusInside().copySelf();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,146,final SubHyperplane<S> plusInside  =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,147,(attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().copySelf();
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,148,"attribute = new BoundaryAttribute<S>(plusOutside, plusInside);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,151,"return new BSPTree<S>(node.getCut().copySelf(),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,152,"recurseComplement(node.getPlus()),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,153,"recurseComplement(node.getMinus()),"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,154,attribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,158,/** BSP tree leaf merger computing union of two regions. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,159,private class UnionMerger implements BSPTree.LeafMerger<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,160,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,161,"public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,162,"final BSPTree<S> parentTree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,163,"final boolean isPlusChild, final boolean leafFromInstance) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,164,if ((Boolean) leaf.getAttribute()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,165,// the leaf node represents an inside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,166,"leaf.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,167,return leaf;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,169,// the leaf node represents an outside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,170,"tree.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,171,return tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,175,/** BSP tree leaf merger computing union of two regions. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,176,private class IntersectionMerger implements BSPTree.LeafMerger<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,177,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,178,"public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,179,"final BSPTree<S> parentTree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,180,"final boolean isPlusChild, final boolean leafFromInstance) {"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,181,if ((Boolean) leaf.getAttribute()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,182,// the leaf node represents an inside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,183,"tree.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,184,return tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,186,// the leaf node represents an outside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,187,"leaf.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,188,return leaf;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,192,/** BSP tree leaf merger computing union of two regions. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,193,private class XorMerger implements BSPTree.LeafMerger<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,194,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,195,"public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,196,"final BSPTree<S> parentTree, final boolean isPlusChild,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,197,final boolean leafFromInstance) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,198,BSPTree<S> t = tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,199,if ((Boolean) leaf.getAttribute()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,200,// the leaf node represents an inside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,201,t = recurseComplement(t);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,203,"t.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,204,return t;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,208,/** BSP tree leaf merger computing union of two regions. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,209,private class DifferenceMerger implements BSPTree.LeafMerger<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,210,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,211,"public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,212,"final BSPTree<S> parentTree, final boolean isPlusChild,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,213,final boolean leafFromInstance) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,214,if ((Boolean) leaf.getAttribute()) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,215,// the leaf node represents an inside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,216,final BSPTree<S> argTree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,217,recurseComplement(leafFromInstance ? tree : leaf);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,218,"argTree.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,219,return argTree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,221,// the leaf node represents an outside cell
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,222,final BSPTree<S> instanceTree =
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,223,leafFromInstance ? leaf : tree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,224,"instanceTree.insertInTree(parentTree, isPlusChild);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,225,return instanceTree;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,229,/** Visitor removing internal nodes attributes. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,230,private class NodesCleaner implements  BSPTreeVisitor<S> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,232,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,233,public Order visitOrder(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,234,return Order.PLUS_SUB_MINUS;
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,237,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,238,public void visitInternalNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,239,node.setAttribute(null);
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,242,/** {@inheritDoc} */
True,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java,243,public void visitLeafNode(final BSPTree<S> node) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,2,* Licensed to the Apache Software Foundation (ASF) under one or more
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,3,* contributor license agreements.  See the NOTICE file distributed with
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,4,* this work for additional information regarding copyright ownership.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,5,"* The ASF licenses this file to You under the Apache License, Version 2.0"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,6,"* (the ""License""); you may not use this file except in compliance with"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,7,* the License.  You may obtain a copy of the License at
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,9,*      http://www.apache.org/licenses/LICENSE-2.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,11,"* Unless required by applicable law or agreed to in writing, software"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,12,"* distributed under the License is distributed on an ""AS IS"" BASIS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,13,"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,14,* See the License for the specific language governing permissions and
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,15,* limitations under the License.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,17,package org.apache.commons.math.geometry.partitioning;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,19,/** Enumerate representing the location of an element with respect to an
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,20,* {@link Hyperplane hyperplane} of a space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,21,* @version $Id$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,22,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,24,public enum Side {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,26,/** Code for the plus side of the hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,27,"PLUS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,29,/** Code for the minus side of the hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,30,"MINUS,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,32,/** Code for elements crossing the hyperplane from plus to minus side. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,33,"BOTH,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,35,/** Code for the hyperplane itself. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,src/main/java/org/apache/commons/math/geometry/partitioning/Side.java,36,HYPER;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,19,import org.apache.commons.math.geometry.Space;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,29, @version $Revision$ $Date$
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,31,ublic class SubHyperplane {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,33,** Underlying hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,34,rivate final Hyperplane hyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,31,* @param <S> Type of the embedding space.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,36,** Remaining region of the hyperplane. */
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,37,rivate final Region remainingRegion;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,39,** Build a chopped hyperplane that is not chopped at all.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,40, @param hyperplane underlying hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,42,ublic SubHyperplane(final Hyperplane hyperplane) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,43,his.hyperplane = hyperplane;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,44,emainingRegion = hyperplane.wholeHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,47,** Build a sub-hyperplane from an hyperplane and a region.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,48, @param hyperplane underlying hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,49, @param remainingRegion remaining region of the hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,51,"ublic SubHyperplane(final Hyperplane hyperplane, final Region remainingRegion) {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,52,his.hyperplane      = hyperplane;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,53,his.remainingRegion = remainingRegion;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,33,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,34,* @since 3.0
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,36,public interface SubHyperplane<S extends Space> {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,63,ublic SubHyperplane copySelf() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,64,"eturn new SubHyperplane(hyperplane.copySelf(), remainingRegion.copySelf());"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,45,SubHyperplane<S> copySelf();
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,70,ublic Hyperplane getHyperplane() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,71,eturn hyperplane;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,50,Hyperplane<S> getHyperplane();
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,74,** Get the remaining region of the hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,75, <p>The returned region is expressed in the canonical hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,76, frame and has the hyperplane dimension. For example a chopped
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,77, hyperplane in the 3D euclidean is a 2D plane and the
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,78, corresponding region is a convex 2D polygon.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,79, @return remaining region of the hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,52,/** Check if the instance is empty.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,53,* @return true if the instance is empty
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,81,ublic Region getRemainingRegion() {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,82,eturn remainingRegion;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,55,boolean isEmpty();
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,85,** Apply a transform to the instance.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,86, <p>The instance must be a (D-1)-dimension sub-hyperplane with
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,87, respect to the transform <em>not</em> a (D-2)-dimension
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,88, sub-hyperplane the transform knows how to transform by
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,89, itself. The transform will consist in transforming first the
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,90, hyperplane and then the all region using the various methods
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,91, provided by the transform.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,92, @param transform D-dimension transform to apply
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,93, @return the transformed instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,57,/** Get the size of the instance.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,58,"* @return the size of the instance (this is a length in 1D, an area"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,59,"* in 2D, a volume in 3D ...)"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,95,ublic SubHyperplane applyTransform(final Transform transform) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,96,inal Hyperplane tHyperplane = transform.apply(hyperplane);
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,97,inal BSPTree tTree =
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,98,"ecurseTransform(remainingRegion.getTree(false), tHyperplane, transform);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,99,"eturn new SubHyperplane(tHyperplane, remainingRegion.buildNew(tTree));"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,61,double getSize();
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,63,/** Compute the relative position of the instance with respect
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,64,* to an hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,65,* @param hyperplane hyperplane to check instane against
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,66,"* @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,67,* {@link Side#HYPER}
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,69,Side side(Hyperplane<S> hyperplane);
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,102,** Recursively transform a BSP-tree from a sub-hyperplane.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,103, @param node current BSP tree node
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,104, @param transformed image of the instance hyperplane by the transform
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,105, @param transform transform to apply
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,106, @return a new tree
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,71,/** Split the instance in two parts by an hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,72,* @param hyperplane splitting hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,73,* @return an object containing both the part of the instance
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,74,* on the plus side of the instance and the part of the
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,75,* instance on the minus side of the instance
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,108,"rivate BSPTree recurseTransform(final BSPTree node, final Hyperplane transformed,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,109,inal Transform transform) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,110,f (node.getCut() == null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,111,eturn new BSPTree(node.getAttribute());
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,77,SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,79,/** Compute the union of the instance and another sub-hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,80,* @param other other sub-hyperplane to union (<em>must</em> be in the
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,81,* same hyperplane as the instance)
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,82,"* @return a new sub-hyperplane, union of the instane and other"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,84,SubHyperplane<S> reunite(SubHyperplane<S> other);
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,86,/** Class holding the results of the {@link Hyperplane#split Hyperplane.split}
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,87,* method.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,88,* @param <S> Type of the embedding space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,89,* @param <T> Type of the embedded sub-space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,91,public static class SplitSubHyperplane<U extends Space> {
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,93,/** Part of the sub-hyperplane on the plus side of the splitting hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,94,private final SubHyperplane<U> plus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,96,/** Part of the sub-hyperplane on the minus side of the splitting hyperplane. */
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,97,private final SubHyperplane<U> minus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,99,/** Build a SplitSubHyperplane from its parts.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,100,* @param plus part of the sub-hyperplane on the plus side of the
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,101,* splitting hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,102,* @param minus part of the sub-hyperplane on the minus side of the
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,103,* splitting hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,105,"public SplitSubHyperplane(final SubHyperplane<U> plus,"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,106,final SubHyperplane<U> minus) {
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,107,this.plus  = plus;
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,108,this.minus = minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,114,egion.BoundaryAttribute attribute =
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,115,Region.BoundaryAttribute) node.getAttribute();
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,116,f (attribute != null) {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,117,inal SubHyperplane tPO = (attribute.getPlusOutside() == null) ?
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,118,ull :
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,119,"ransform.apply(attribute.getPlusOutside(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,120,"yperplane, transformed);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,121,inal SubHyperplane tPI = (attribute.getPlusInside() == null) ?
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,122,ull :
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,123,"ransform.apply(attribute.getPlusInside(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,124,"yperplane, transformed);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,125,"ttribute = new Region.BoundaryAttribute(tPO, tPI);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,111,/** Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,112,* @return part of the sub-hyperplane on the plus side of the splitting hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,114,public SubHyperplane<U> getPlus() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,115,return plus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,128,"eturn new BSPTree(transform.apply(node.getCut(),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,129,"yperplane, transformed),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,130,"ecurseTransform(node.getPlus(), transformed,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,131,"ransform),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,132,"ecurseTransform(node.getMinus(), transformed,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,133,"ransform),"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,134,ttribute);
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,118,/** Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,119,* @return part of the sub-hyperplane on the minus side of the splitting hyperplane
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,121,public SubHyperplane<U> getMinus() {
True,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java,122,return minus;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,2, Licensed to the Apache Software Foundation (ASF) under one or more
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,3, contributor license agreements.  See the NOTICE file distributed with
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,4, this work for additional information regarding copyright ownership.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,5," The ASF licenses this file to You under the Apache License, Version 2.0"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,6," (the ""License""); you may not use this file except in compliance with"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,7, the License.  You may obtain a copy of the License at
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,9,      http://www.apache.org/licenses/LICENSE-2.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,11," Unless required by applicable law or agreed to in writing, software"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,12," distributed under the License is distributed on an ""AS IS"" BASIS,"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,13," WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,14, See the License for the specific language governing permissions and
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,15, limitations under the License.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,17,ackage org.apache.commons.math.geometry.partitioning;
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,20,** This interface represents a sub-space of a space.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,22, <p>Sub-spaces are the lower dimensions subsets of a n-dimensions
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,23, space. The (n-1)-dimension sub-spaces are specific sub-spaces known
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,24, as {@link Hyperplane hyperplanes}.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,26," <p>In the 3D euclidean space, hyperplanes are 2D planes, and the 1D"
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,27, sub-spaces are lines.</p>
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,29, @see Hyperplane
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,30, @version $Revision$ $Date$
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,32,ublic interface SubSpace {
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,34,** Transform a space point into a sub-space point.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,35, @param point n-dimension point of the space
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,36, @return (n-1)-dimension point of the sub-space corresponding to
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,37, the specified space point
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,38, @see #toSpace
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,40,oint toSubSpace(Point point);
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,42,** Transform a sub-space point into a space point.
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,43, @param point (n-1)-dimension point of the sub-space
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,44, @return n-dimension point of the space corresponding to the
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,45, specified sub-space point
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,46, @see #toSubSpace
False,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java,48,oint toSpace(Point point);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,19,import org.apache.commons.math.geometry.Vector;
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,20,import org.apache.commons.math.geometry.Space;
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,30,     D-dimension space using its {@link #apply(Point)}
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,33,*     D-dimension space using its {@link #apply(Vector)}
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,46, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,49,* @param <S> Type of the embedding space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,50,* @param <T> Type of the embedded sub-space.
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,52,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,53,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,48,ublic interface Transform {
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,55,"public interface Transform<S extends Space, T extends Space> {"
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,54,oint apply(Point point);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,61,Vector<S> apply(Vector<S> point);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,60,yperplane apply(Hyperplane hyperplane);
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,67,Hyperplane<S> apply(Hyperplane<S> hyperplane);
False,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,72,"ubHyperplane apply(SubHyperplane sub, Hyperplane original, Hyperplane transformed);"
True,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java,79,"SubHyperplane<T> apply(SubHyperplane<T> sub, Hyperplane<S> original, Hyperplane<S> transformed);"
False,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,44, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,44,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java,45,* @since 3.0
False,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,91, @version $Revision$ $Date$
True,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,91,* @version $Id:$
True,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java,92,* @since 3.0
