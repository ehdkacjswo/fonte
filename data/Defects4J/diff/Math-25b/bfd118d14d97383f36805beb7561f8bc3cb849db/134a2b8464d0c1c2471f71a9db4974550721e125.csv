is_addition,old_file_path,new_file_path,line_num,content
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,155, This method simply bounds the unbounded point using the mappings
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,156, set up at construction and calls the underlying function using
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,157, the bounded point.
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,155,* This method simply returns the value of the underlying function
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,156,"* if the unbounded point already fulfills the bounds, and compute"
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,157,* a replacement value using the offset and scale if bounds are
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,158,"* violated, without calling the function at all."
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,159, @see #unboundedToBounded(double[])
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,160,* @return either underlying function value or penalty function value
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,170,vershoot = lower[j] - point[j];
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,171,overshoot = scale[j] * (lower[j] - point[j]);
False,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,172,vershoot = point[j] - upper[j];
True,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java,173,overshoot = scale[j] * (point[j] - upper[j]);
