is_addition,old_file_path,new_file_path,line_num,content
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,483,"nsureTyped(t, n, getJSType(expr));"
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,485,"/ If the cast, tightens the type apply it, so it is available post"
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,486,/ normalization.
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,487,SType castType = getJSType(n);
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,489,f (castType.isSubtype(exprType)) {
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,484,JSType castType = getJSType(n);
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,486,// TODO(johnlenz): determine if we can limit object literals in some
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,487,// way.
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,488,if (!expr.isObjectLit()) {
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,489,"validator.expectCanCast(t, n, castType, exprType);"
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,491,"ensureTyped(t, n, castType);"
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,493,if (castType.isSubtype(exprType) || expr.isObjectLit()) {
True,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1995,"// TODO(johnlenz): this seems like a strange place to check ""@implicitCast"""
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1993,f (info.hasType()) {
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1994,/ TODO(johnlenz): Change this so that we only look for casts on CAST
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1995,/ nodes one the misplaced type annotation warning is on by default and
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1996,"/ people have been given a chance to fix them.  As is, this is here"
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1997,/ simply for legacy casts.
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1998,"SType infoType = info.getType().evaluate(t.getScope(), typeRegistry);"
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,1999,"alidator.expectCanCast(t, n, infoType, type);"
False,src/com/google/javascript/jscomp/TypeCheck.java,src/com/google/javascript/jscomp/TypeCheck.java,2000,ype = infoType;
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,450,reak;
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,453,/ TODO(johnlenz): remove this after the CAST node change has shaken out.
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,454,f (!n.isFunction()) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,455,SDocInfo info = n.getJSDocInfo();
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,456,f (info != null && info.hasType()) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,457,"SType castType = info.getType().evaluate(syntacticScope, registry);"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,459,/ A stubbed type declaration on a qualified name should take
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,460,"/ effect for all subsequent accesses of that name,"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,461,/ so treat it the same as an assign to that name.
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,462,f (n.isQualifiedName() &&
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,463,.getParent().isExprResult()) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,464,"pdateScopeForTypeChange(scope, n, n.getJSType(), castType);"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,450,JSDocInfo info = n.getJSDocInfo();
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,451,if (info != null && info.hasType()) {
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,452,"n.setJSType(info.getType().evaluate(syntacticScope, registry));"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,467,.setJSType(castType);
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,454,break;
False,src/com/google/javascript/jscomp/TypeValidator.java,src/com/google/javascript/jscomp/TypeValidator.java,76,/ TODO(johnlenz): reenable this after after the next release.
False,src/com/google/javascript/jscomp/TypeValidator.java,src/com/google/javascript/jscomp/TypeValidator.java,78,"iagnosticType.disabled(""JSC_INVALID_CAST"","
True,src/com/google/javascript/jscomp/TypeValidator.java,src/com/google/javascript/jscomp/TypeValidator.java,77,"DiagnosticType.warning(""JSC_INVALID_CAST"","
False,src/com/google/javascript/jscomp/parsing/IRFactory.java,src/com/google/javascript/jscomp/parsing/IRFactory.java,366,& info.hasType()
False,src/com/google/javascript/jscomp/parsing/IRFactory.java,src/com/google/javascript/jscomp/parsing/IRFactory.java,367,"/ TODO(johnlenz): for now, attach object literal type directly."
False,src/com/google/javascript/jscomp/parsing/IRFactory.java,src/com/google/javascript/jscomp/parsing/IRFactory.java,368,& !irNode.isObjectLit()) {
True,src/com/google/javascript/jscomp/parsing/IRFactory.java,src/com/google/javascript/jscomp/parsing/IRFactory.java,366,&& info.hasType()) {
False,test/com/google/javascript/jscomp/IntegrationTest.java,test/com/google/javascript/jscomp/IntegrationTest.java,2435,nt numAdds = 4750;
True,test/com/google/javascript/jscomp/IntegrationTest.java,test/com/google/javascript/jscomp/IntegrationTest.java,2435,int numAdds = 4500;
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7687,"assignment to property foo of Object\n"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7687,"""assignment to property foo of {foo: string}\n"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7707,ublic void testCast18() throws Exception {
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7708,/ Mostly verifying that legacy annotations are applied
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7709,/ despite the parser warning.
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7710,"estTypes(""/** @constructor */ function Foo() {} \n"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7711,"/** @type {Foo} */ var x = (/** @type {Foo} */ {})"","
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7712,"Type annotations are not allowed here. "" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7713,"Are you missing parentheses?"");"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7715,/ Not really encourage because of possible ambiguity but it works.
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7716,"estTypes(""/** @constructor */ function Foo() {} \n"" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7717,"/** @type {Foo} */ var x = /** @type {Foo} */ {}"","
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7718,"Type annotations are not allowed here. "" +"
False,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,7719,"Are you missing parentheses?"");"
