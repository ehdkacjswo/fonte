is_addition,old_file_path,new_file_path,line_num,content
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,27,import com.google.common.collect.HashMultiset;
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,29,import com.google.common.collect.ImmutableMultiset;
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,32,import com.google.common.collect.Multiset;
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,786,/** Gets the number of times each variable has been assigned. */
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,787,Multiset<String> getAssignedNameCounts();
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,828,@Override
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,829,public Multiset<String> getAssignedNameCounts() {
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,830,return ImmutableMultiset.of();
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,839,private final Multiset<String> assignedVarNames = HashMultiset.create();
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,896,@Override
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,897,public Multiset<String> getAssignedNameCounts() {
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,898,return assignedVarNames;
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,901,void recordAssignedName(String name) {
True,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,src/com/google/javascript/jscomp/FunctionTypeBuilder.java,902,assignedVarNames.add(name);
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1915,* Returns whether this is a bleeding function (an anonymous named function
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1916,* that bleeds into the inner scope).
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1918,static boolean isBleedingFunctionName(Node n) {
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1919,return n.isName() && !n.getString().isEmpty() &&
True,src/com/google/javascript/jscomp/NodeUtil.java,src/com/google/javascript/jscomp/NodeUtil.java,1920,isFunctionExpression(n.getParent());
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,123,/** @see isMarkedEscaped */
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,126,/** @see isMarkedAssignedExactlyOnce */
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,127,private boolean markedAssignedExactlyOnce = false;
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,188, that bleeds into the inner scope.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,192,* that bleeds into the inner scope).
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,336,** Record that this is escaped by an inner scope. */
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,341,* Record that this is escaped by an inner scope.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,343,"* In other words, it's assigned in an inner scope so that it's much harder"
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,344,* to make assertions about its value at a given point.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,359,* Record that this is assigned exactly once..
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,361,"* In other words, it's assigned in an inner scope so that it's much harder"
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,362,* to make assertions about its value at a given point.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,364,void markAssignedExactlyOnce() {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,365,markedAssignedExactlyOnce = true;
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,369,* Whether this is assigned exactly once.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,370,* Notice that not all scope creators record this information.
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,372,boolean isMarkedAssignedExactlyOnce() {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,373,return markedAssignedExactlyOnce;
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,527,ublic StaticSlot<JSType> getSlot(String name) {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,554,public Var getSlot(String name) {
False,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,532,ublic StaticSlot<JSType> getOwnSlot(String name) {
True,src/com/google/javascript/jscomp/Scope.java,src/com/google/javascript/jscomp/Scope.java,559,public Var getOwnSlot(String name) {
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,612,"/ 1) The var is escaped in a weird way, e.g.,"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,612,"// 1) The var is escaped and assigned in an inner scope, e.g.,"
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,619,/ inferred variable.
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,620,/ var t = null; function f() { (t); }
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,621,oolean nonLocalInferredSlot =
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,622,sInferred &&
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,623,yntacticScope.getParent() != null &&
False,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,624,ar == syntacticScope.getParent().getSlot(varName);
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,619,"// inferred variable. That variable is assigned more than once,"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,620,// and we can't know which type we're getting.
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,622,// var t = null; function f() { (t); } doStuff(); t = {};
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,624,"// Notice that this heuristic isn't perfect. For example, you might"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,625,// have:
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,627,// function f() { (t); } f(); var t = 3;
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,629,"// In this case, we would infer the first reference to t as"
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,630,"// type {number}, even though it's undefined."
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,631,boolean nonLocalInferredSlot = false;
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,632,if (isInferred && syntacticScope.isLocal()) {
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,633,Var maybeOuterVar = syntacticScope.getParent().getVar(varName);
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,634,if (var == maybeOuterVar &&
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,635,!maybeOuterVar.isMarkedAssignedExactlyOnce()) {
True,src/com/google/javascript/jscomp/TypeInference.java,src/com/google/javascript/jscomp/TypeInference.java,636,nonLocalInferredSlot = true;
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,54,import com.google.common.collect.Multiset;
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1876,for (Multiset.Entry<String> entry :
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1877,contents.getAssignedNameCounts().entrySet()) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1878,Var v = scope.getVar(entry.getElement());
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1879,Preconditions.checkState(v.getScope() == scope);
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1880,if (entry.getCount() == 1) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1881,v.markAssignedExactlyOnce();
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1986,f (t.getScopeDepth() <= 2) {
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1987,/ We only need to worry about escaped variables at depth 3.
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1988,"/ An variable escaped at depth 2 is, by definition, a global variable."
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1996,if (t.getScopeDepth() <= 1) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1997,// The first-order function analyzer looks at two types of variables:
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1999,"// 1) Local variables that are assigned in inner scopes (""escaped vars"")"
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2001,// 2) Local variables that are assigned more than once.
False,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,1994,f (n.isName() && NodeUtil.isLValue(n)) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2008,if (n.isName() && NodeUtil.isLValue(n) &&
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2009,"// Be careful of bleeding functions, which create variables"
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2010,"// in the inner scope, not the scope where the name appears."
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2011,!NodeUtil.isBleedingFunctionName(n)) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2017,if (ownerScope.isLocal()) {
True,src/com/google/javascript/jscomp/TypedScopeCreator.java,src/com/google/javascript/jscomp/TypedScopeCreator.java,2018,data.get(ownerScope.getRootNode()).recordAssignedName(name);
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5976,public void testIssue726() throws Exception {
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5977,testTypes(
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5978,"""/** @constructor */ function Foo() {}"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5979,"""/** @param {number} x */ Foo.prototype.bar = function(x) {};"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5980,"""/** @return {!Function} */ "" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5981,"""Foo.prototype.getDeferredBar = function() { "" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5982,"""  var self = this;"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5983,"""  return function() {"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5984,"""    self.bar(true);"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5987,"""actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5988,"""found   : boolean\n"" +"
True,test/com/google/javascript/jscomp/TypeCheckTest.java,test/com/google/javascript/jscomp/TypeCheckTest.java,5989,"""required: number"");"
